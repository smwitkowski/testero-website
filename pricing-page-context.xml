This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/pricing/**/*, components/pricing/**/*, components/patterns/**/*, components/ui/**/*, lib/pricing/**/*, lib/utils.ts, lib/analytics/**/*, components/providers/AuthProvider.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  pricing/
    page.tsx
components/
  patterns/
    __tests__/
      section.test.tsx
    container.stories.tsx
    Container.tsx
    index.ts
    section.stories.tsx
    section.tsx
  pricing/
    ComparisonTable.tsx
    PricingCard.stories.tsx
    PricingCard.tsx
  providers/
    AuthProvider.tsx
  ui/
    __stories__/
      docs/
        EmptyState.mdx
        PageHeader.mdx
        Table.mdx
        Toast.mdx
      Badge.stories.tsx
      EmptyState.stories.tsx
      PageHeader.stories.tsx
      Table.stories.tsx
      Toast.stories.tsx
    __tests__/
      button.a11y.test.tsx
    badge.tsx
    button.tsx
    card.tsx
    checkbox.tsx
    dialog.tsx
    dropdown-menu.tsx
    empty-state.tsx
    form.tsx
    index.ts
    input.tsx
    label.tsx
    navigator-tile.tsx
    page-header.tsx
    progress.tsx
    radio-group.tsx
    select.tsx
    table.tsx
    textarea.tsx
    theme-toggle.tsx
    toast.tsx
lib/
  analytics/
    hooks/
      useSessionTracking.ts
    analytics.ts
    campaign-analytics-integration.ts
    campaign-attribution.ts
    campaign-dashboard-integration.ts
    campaign-metrics.ts
    funnels.ts
    server-analytics.ts
  pricing/
    __mocks__/
      constants.ts
    constants.ts
    price-utils.ts
  utils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/pricing/page.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/providers/AuthProvider";
import {
  CheckCircle,
  Shield,
  TrendingUp,
  Award,
  ChevronDown,
  ChevronUp,
  Star,
  Zap,
  RefreshCw,
} from "lucide-react";
import { usePostHog } from "posthog-js/react";
import { trackEvent, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";
import {
  getTierNameFromPriceId,
  getPaymentMode,
  getPlanType,
} from "@/lib/pricing/price-utils";
import { PricingCard } from "@/components/pricing/PricingCard";
import { ComparisonTable } from "@/components/pricing/ComparisonTable";
import { Container, Section } from "@/components/patterns";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import {
  SUBSCRIPTION_TIERS,
  EXAM_PACKAGES,
  VALUE_PROPS,
  FEATURE_COMPARISON,
  PRICING_FAQ,
  PRICING_TESTIMONIALS,
  AI_CREDIT_USAGE,
} from "@/lib/pricing/constants";
import { cn } from "@/lib/utils";

export default function PricingPage() {
  const [billingInterval, setBillingInterval] = useState<"monthly" | "annual">("annual");
  const [showComparison, setShowComparison] = useState(false);
  const [openFaqIndex, setOpenFaqIndex] = useState<number | null>(null);
  const [showExamPackages, setShowExamPackages] = useState(false);
  const [loading, setLoading] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const { user } = useAuth();
  const router = useRouter();
  const posthog = usePostHog();

  // Track page view
  useEffect(() => {
    trackEvent(posthog, ANALYTICS_EVENTS.PRICING_PAGE_VIEWED, {
      user_id: user?.id,
      billing_interval: billingInterval,
    });
  }, [posthog, user, billingInterval]);

  const handleCheckout = async (priceId: string, planName: string) => {
    try {
      // Calculate analytics properties
      const tierName = getTierNameFromPriceId(priceId);
      const paymentMode = getPaymentMode(priceId);
      const planType = getPlanType(priceId);

      // Track checkout intent
      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_INITIATED, {
        plan_name: planName,
        tier_name: tierName,
        billing_interval: billingInterval,
        price_id: priceId,
        payment_mode: paymentMode,
        plan_type: planType,
        user_id: user?.id,
      });

      // Require authentication
      if (!user) {
        trackEvent(posthog, ANALYTICS_EVENTS.SIGNUP_ATTEMPT, {
          plan_name: planName,
          source: "pricing_checkout_redirect",
        });
        router.push("/signup?redirect=/pricing");
        return;
      }

      setLoading(priceId);

      const response = await fetch("/api/billing/checkout", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          priceId,
        }),
      });

      const data = (await response.json()) as { error?: string; url?: string };

      if (!response.ok) {
        throw new Error(data.error || "Failed to create checkout session");
      }

      // Track successful checkout session creation
      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_SESSION_CREATED, {
        plan_name: planName,
        tier_name: tierName,
        billing_interval: billingInterval,
        price_id: priceId,
        payment_mode: paymentMode,
        plan_type: planType,
        user_id: user?.id,
      });

      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      }
    } catch (error) {
      console.error("Checkout error:", error);
      // Calculate analytics properties for error tracking
      const tierName = getTierNameFromPriceId(priceId);
      const paymentMode = getPaymentMode(priceId);
      const planType = getPlanType(priceId);

      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_ERROR, {
        error: error instanceof Error ? error.message : "Unknown error",
        plan_name: planName,
        tier_name: tierName,
        billing_interval: billingInterval,
        price_id: priceId,
        payment_mode: paymentMode,
        plan_type: planType,
        user_id: user?.id,
      });
      setError("Failed to start checkout. Please try again.");
      setTimeout(() => setError(null), 5000);
    } finally {
      setLoading(null);
    }
  };

  const toggleBillingInterval = () => {
    const newInterval = billingInterval === "monthly" ? "annual" : "monthly";
    setBillingInterval(newInterval);
    trackEvent(posthog, ANALYTICS_EVENTS.PRICING_PLAN_SELECTED, {
      from_interval: billingInterval,
      to_interval: newInterval,
      action: "toggle_billing",
    });
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-50 to-white">
      {/* Hero Section with Value Proposition */}
      <Section
        contained={false}
        size="xl"
        surface="brand"
        className="relative overflow-hidden bg-gradient-to-br from-blue-600 via-blue-700 to-cyan-600 text-white"
      >
        <div className="absolute inset-0 bg-grid-white/10 [mask-image:linear-gradient(0deg,transparent,rgba(255,255,255,0.1))]" />
        <Container className="relative">
          <div className="text-center">
            <h1 className="text-4xl sm:text-5xl lg:text-6xl font-bold mb-6">
              {VALUE_PROPS.mainHeadline}
            </h1>
            <p className="text-xl sm:text-2xl mb-8 text-blue-100 max-w-3xl mx-auto">
              {VALUE_PROPS.subHeadline}
            </p>

            {/* Trust Badges */}
            <div className="flex flex-wrap justify-center gap-4 sm:gap-8 mb-8">
              {VALUE_PROPS.trustBadges.map((badge) => (
                <div
                  key={badge}
                  className="flex items-center gap-2 bg-white/10 backdrop-blur-sm rounded-lg px-4 py-2"
                >
                  <CheckCircle className="h-5 w-5 text-green-400" />
                  <span className="text-sm sm:text-base font-medium">{badge}</span>
                </div>
              ))}
            </div>

            {/* Guarantees */}
            <div className="flex flex-wrap justify-center gap-6 text-sm sm:text-base mb-8">
              {VALUE_PROPS.guarantees.map((guarantee) => (
                <div key={guarantee} className="flex items-center gap-2">
                  <Shield className="h-5 w-5 text-yellow-400" />
                  <span>{guarantee}</span>
                </div>
              ))}
            </div>
          </div>
        </Container>
      </Section>

      {/* Error Alert */}
      {error && (
        <Container className="mt-6">
          <div className="rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="ml-3">
                <p className="text-sm font-medium text-red-800">{error}</p>
              </div>
            </div>
          </div>
        </Container>
      )}

      {/* Billing Toggle */}
      <Container className="mt-8 mb-10 relative z-10">
        <div className="flex justify-center">
          <div className="inline-flex items-center bg-white rounded-full shadow-lg p-1">
            <button
              onClick={() => billingInterval === "annual" && toggleBillingInterval()}
              className={cn(
                "px-6 py-3 rounded-full text-sm font-semibold transition-all duration-200",
                billingInterval === "monthly"
                  ? "bg-blue-600 text-white"
                  : "text-gray-600 hover:text-gray-900"
              )}
            >
              Monthly
            </button>
            <button
              onClick={() => billingInterval === "monthly" && toggleBillingInterval()}
              className={cn(
                "px-6 py-3 rounded-full text-sm font-semibold transition-all duration-200 flex items-center gap-2",
                billingInterval === "annual"
                  ? "bg-blue-600 text-white"
                  : "text-gray-600 hover:text-gray-900"
              )}
            >
              Annual
              {billingInterval === "annual" && (
                <Badge tone="success" variant="soft" size="sm" className="bg-emerald-700 text-white">
                  SAVE 25%
                </Badge>
              )}
            </button>
          </div>
        </div>
      </Container>

      {/* Main Pricing Cards */}
      <Section
        id="pricing-cards"
        size="lg"
        surface="subtle"
        divider="both"
      >
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 lg:gap-10">
          {SUBSCRIPTION_TIERS.map((tier) => (
            <PricingCard
              key={tier.id}
              tier={tier}
              billingInterval={billingInterval}
              onCheckout={handleCheckout}
              loading={!!loading}
              loadingId={loading}
            />
          ))}
        </div>

        {/* One-Time Exam Packages Toggle */}
        <div className="mt-16 text-center">
          <button
            onClick={() => setShowExamPackages(!showExamPackages)}
            className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-semibold"
          >
            <span>Prefer a one-time purchase? View exam packages</span>
            {showExamPackages ? (
              <ChevronUp className="h-5 w-5" />
            ) : (
              <ChevronDown className="h-5 w-5" />
            )}
          </button>
        </div>

        {/* Exam Packages Section */}
        {showExamPackages && (
          <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
            {EXAM_PACKAGES.map((pkg) => (
              <div
                key={pkg.id}
                className="border border-gray-200 rounded-lg p-6 bg-white hover:shadow-lg transition-shadow"
              >
                <h3 className="text-lg font-bold text-gray-900 mb-2">{pkg.duration}</h3>
                <div className="text-3xl font-bold text-gray-900 mb-4">${pkg.price}</div>
                <ul className="space-y-2 mb-6">
                  {pkg.features.map((feature) => (
                    <li key={feature} className="flex items-start gap-2">
                      <CheckCircle className="h-5 w-5 text-green-500 flex-shrink-0 mt-0.5" />
                      <span className="text-sm text-gray-600">{feature}</span>
                    </li>
                  ))}
                </ul>
                <button
                  onClick={() => pkg.priceId && handleCheckout(pkg.priceId, pkg.duration)}
                  disabled={!!loading || !pkg.priceId}
                  className="w-full rounded-lg bg-gray-900 px-4 py-2 text-white font-semibold hover:bg-gray-800 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Get Started
                </button>
              </div>
            ))}
          </div>
        )}
      </Section>

      {/* AI Credits Explanation */}
      <Section size="lg" surface="subtle" divider="bottom">
        <div className="mx-auto max-w-4xl">
          <div className="text-center mb-8">
            <h2 className="text-2xl font-bold text-gray-900 dark:text-slate-100 mb-4">How AI Credits Work</h2>
            <p className="text-gray-600 dark:text-slate-300">
              AI credits power our adaptive learning engine. Use them for personalized practice
              exams and detailed explanations.
            </p>
          </div>
          <div className="grid grid-cols-1 gap-6 md:grid-cols-3">
            <div
              className="rounded-lg border border-slate-200 bg-white p-6 text-center shadow-sm transition-colors dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
            >
              <Zap className="mx-auto mb-3 h-10 w-10 text-blue-600 dark:text-sky-200" />
              <h3 className="mb-2 font-semibold text-gray-900 dark:text-slate-100">Full Practice Exam</h3>
              <p className="text-2xl font-bold text-blue-600 dark:text-sky-200">{AI_CREDIT_USAGE.fullExam} Credit</p>
              <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">Complete 60-question adaptive exam</p>
            </div>
            <div
              className="rounded-lg border border-slate-200 bg-white p-6 text-center shadow-sm transition-colors dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
            >
              <TrendingUp className="mx-auto mb-3 h-10 w-10 text-blue-600 dark:text-sky-200" />
              <h3 className="mb-2 font-semibold text-gray-900 dark:text-slate-100">Domain Quiz</h3>
              <p className="text-2xl font-bold text-blue-600 dark:text-sky-200">
                {AI_CREDIT_USAGE.domainQuiz} Credit
              </p>
              <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">25-question focused practice</p>
            </div>
            <div
              className="rounded-lg border border-slate-200 bg-white p-6 text-center shadow-sm transition-colors dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
            >
              <Award className="mx-auto mb-3 h-10 w-10 text-blue-600 dark:text-sky-200" />
              <h3 className="mb-2 font-semibold text-gray-900 dark:text-slate-100">AI Explanation</h3>
              <p className="text-2xl font-bold text-blue-600 dark:text-sky-200">
                {AI_CREDIT_USAGE.explanation} Credit
              </p>
              <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">Detailed answer explanation</p>
            </div>
          </div>
          <p className="text-center text-sm text-gray-600 dark:text-slate-300 mt-6">
            Need more credits? Purchase additional at ${AI_CREDIT_USAGE.additionalCreditPrice}
            /credit or upgrade your plan
          </p>
        </div>
      </Section>

      {/* Social Proof Section */}
      <Section size="lg" surface="default">
          <h2 className="text-3xl font-bold text-center text-gray-900 mb-12">
            Trusted by Cloud Professionals Worldwide
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            {PRICING_TESTIMONIALS.map((testimonial, index) => (
              <div key={index} className="bg-gray-50 rounded-lg p-6">
                <div className="flex mb-4">
                  {[...Array(5)].map((_, i) => (
                    <Star key={i} className="h-5 w-5 text-yellow-400 fill-current" />
                  ))}
                </div>
                <p className="text-gray-700 mb-4 italic">&ldquo;{testimonial.quote}&rdquo;</p>
                <div className="border-t pt-4">
                  <p className="font-semibold text-gray-900">{testimonial.author}</p>
                  <p className="text-sm text-gray-600">{testimonial.role}</p>
                  <p className="text-sm text-blue-600 font-medium mt-1">
                    {testimonial.tier} Customer
                  </p>
                </div>
              </div>
            ))}
          </div>
      </Section>

      {/* Feature Comparison */}
      <Section size="lg" surface="subtle" divider="bottom">
          <div className="text-center mb-12">
            <h2 className="text-3xl font-bold text-gray-900 mb-4">Compare Plans in Detail</h2>
            <button
              onClick={() => setShowComparison(!showComparison)}
              className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-semibold"
            >
              {showComparison ? "Hide" : "Show"} detailed comparison
              {showComparison ? (
                <ChevronUp className="h-5 w-5" />
              ) : (
                <ChevronDown className="h-5 w-5" />
              )}
            </button>
          </div>

          {showComparison && (
            <ComparisonTable
                categories={FEATURE_COMPARISON}
                onSelectPlan={(planId) => {
                  const element = document.getElementById("pricing-cards");
                  element?.scrollIntoView({ behavior: "smooth" });
                  // Find the matching tier and trigger checkout
                  const tier = SUBSCRIPTION_TIERS.find((t) => t.id === planId);
                  if (tier) {
                    const priceId =
                      billingInterval === "monthly" ? tier.monthlyPriceId : tier.annualPriceId;
                    if (priceId) handleCheckout(priceId, tier.name);
                  }
                }}
              />
          )}
      </Section>

      {/* FAQ Section */}
      <Section size="lg" surface="default" divider="bottom">
        <div className="mx-auto max-w-3xl">
          <h2 className="text-3xl font-bold text-center text-gray-900 mb-12">
            Frequently Asked Questions
          </h2>
          <div className="space-y-4">
            {PRICING_FAQ.map((faq, index) => (
              <div key={index} className="border border-gray-200 rounded-lg">
                <button
                  onClick={() => setOpenFaqIndex(openFaqIndex === index ? null : index)}
                  className="w-full px-6 py-4 text-left flex items-center justify-between hover:bg-gray-50 transition-colors"
                >
                  <span className="font-semibold text-gray-900">{faq.question}</span>
                  {openFaqIndex === index ? (
                    <ChevronUp className="h-5 w-5 text-gray-500" />
                  ) : (
                    <ChevronDown className="h-5 w-5 text-gray-500" />
                  )}
                </button>
                {openFaqIndex === index && (
                  <div className="px-6 pb-4">
                    <p className="text-gray-600">{faq.answer}</p>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      </Section>

      {/* Final CTA */}
      <Section
        contained={false}
        size="xl"
        surface="brand"
        divider="top"
        className="bg-gradient-to-r from-blue-600 to-cyan-600"
      >
        <Container className="max-w-4xl text-center text-white">
          <h2 className="text-3xl font-bold text-white mb-4">Ready to Pass Your Certification?</h2>
          <p className="text-xl text-blue-100 mb-8">
            Join thousands of professionals who achieved their certification goals with Testero
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button
              asChild
              size="lg"
              tone="accent"
              className="text-lg"
            >
              <Link href="/signup">Start Free Diagnostic</Link>
            </Button>
            <Button
              size="lg"
              variant="outline"
              tone="accent"
              className="text-lg"
              onClick={() => {
                const element = document.getElementById("pricing-cards");
                element?.scrollIntoView({ behavior: "smooth" });
              }}
            >
              View Pricing Plans
            </Button>
          </div>
          <div className="mt-8 flex items-center justify-center gap-2 text-white">
            <RefreshCw className="h-5 w-5" />
            <span>30-day money-back guarantee on all plans</span>
          </div>
        </Container>
      </Section>

      {/* Pricing Cards Anchor handled via Section id */}
    </div>
  );
}
</file>

<file path="components/patterns/__tests__/section.test.tsx">
import { render } from "@testing-library/react"

import { Section } from "../section"

describe("Section", () => {
  it("renders with default variants and container", () => {
    const { container } = render(<Section>Content</Section>)

    const section = container.querySelector("section")
    expect(section).toBeInTheDocument()
    expect(section).toHaveClass("bg-surface")

    const inner = section?.querySelector(":scope > div")
    expect(inner).toHaveClass("py-section_lg")

    const contained = inner?.firstElementChild as HTMLElement | null
    expect(contained).toHaveClass("mx-auto")
    expect(contained?.textContent).toBe("Content")
  })

  it("supports variant overrides and uncontained layout", () => {
    const { container } = render(
      <Section
        as="article"
        size="sm"
        surface="muted"
        divider="both"
        contained={false}
        className="custom"
      >
        <p>Inner content</p>
      </Section>,
    )

    const section = container.querySelector("article")
    expect(section).toBeInTheDocument()
    expect(section).toHaveClass("bg-surface-muted", "border-y", "border-divider", "custom")

    const inner = section?.querySelector(":scope > div")
    expect(inner).toHaveClass("py-section_sm")

    const contained = inner?.firstElementChild as HTMLElement | null
    expect(contained).not.toHaveClass("mx-auto")
    expect(contained?.tagName.toLowerCase()).toBe("p")
  })
})
</file>

<file path="components/patterns/container.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { Container, type ContainerProps } from "./Container"

const meta: Meta<typeof Container> = {
  title: "Patterns/Container",
  component: Container,
  parameters: {
    docs: {
      description: {
        component:
          "Tokenised width wrapper that centers content and applies responsive horizontal padding consistent with the design system.",
      },
    },
  },
  argTypes: {
    as: { control: false },
    className: { control: false },
    children: { control: false },
    size: {
      control: { type: "inline-radio" },
      options: ["sm", "md", "lg", "xl", "2xl", "full"],
    },
  },
  args: {
    size: "xl",
  },
}

export default meta

type Story = StoryObj<typeof meta>

const Placeholder = ({ label }: { label: string }) => (
  <div className="rounded-lg border border-dashed border-border bg-muted/40 p-6 text-sm text-muted-foreground">
    {label}
  </div>
)

export const Playground: Story = {
  render: (args: ContainerProps) => (
    <div className="space-y-6 bg-surface/60 py-10">
      <Container {...args}>
        <Placeholder label={`Container size: ${args.size ?? "xl"}`} />
      </Container>
    </div>
  ),
}

export const CustomElement: Story = {
  args: {
    as: "section",
    size: "lg",
  },
  render: (args: ContainerProps<"section">) => (
    <div className="space-y-6 bg-surface/60 py-10">
      <Container {...args}>
        <Placeholder label="Rendered as a semantic <section> element" />
      </Container>
    </div>
  ),
}
</file>

<file path="components/patterns/Container.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

type ContainerSize = "sm" | "md" | "lg" | "xl" | "2xl" | "full"

const sizeClass: Record<ContainerSize, string> = {
  sm: "max-w-screen-sm",
  md: "max-w-screen-md",
  lg: "max-w-screen-lg",
  xl: "max-w-7xl",
  "2xl": "max-w-screen-2xl",
  full: "w-full",
}

type PolymorphicProps<T extends keyof JSX.IntrinsicElements> = {
  as?: T
  size?: ContainerSize
  className?: string
  children?: React.ReactNode
} & Omit<JSX.IntrinsicElements[T], "className" | "children">

export type ContainerProps<T extends keyof JSX.IntrinsicElements = "div"> =
  PolymorphicProps<T>

export function Container<T extends keyof JSX.IntrinsicElements = "div">(
  props: ContainerProps<T>,
) {
  const { as, size = "xl", className, children, ...rest } = props
  const Comp = (as ?? "div") as React.ElementType
  const widthClass = sizeClass[size]

  return (
    <Comp
      className={cn("mx-auto px-4 sm:px-6 lg:px-8", widthClass, className)}
      {...rest}
    >
      {children}
    </Comp>
  )
}
</file>

<file path="components/patterns/index.ts">
export * from "./Container"
export * from "./section"
</file>

<file path="components/patterns/section.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import type { FC } from "react"

import { Button } from "@/components/ui/button"

import { Section, type SectionProps } from "./section"

const SectionStoryComponent: FC<SectionProps> = (props) => <Section {...props} />

const meta: Meta<typeof SectionStoryComponent> = {
  title: "Patterns/Section",
  component: SectionStoryComponent,
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "Reusable layout primitive that standardises vertical rhythm, background surfaces, and optional dividers.",
      },
    },
  },
  args: {
    size: "lg",
    surface: "default",
    divider: "none",
    contained: true,
  },
  argTypes: {
    size: {
      control: { type: "inline-radio" },
      options: ["sm", "md", "lg", "xl"],
    },
    surface: {
      control: { type: "select" },
      options: ["default", "subtle", "muted", "elevated", "brand"],
    },
    divider: {
      control: { type: "inline-radio" },
      options: ["none", "top", "bottom", "both"],
    },
    contained: {
      control: { type: "boolean" },
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Playground: Story = {
  render: (args) => (
    <Section {...args}>
      <div className="space-y-6">
        <div className="max-w-2xl space-y-3">
          <h2 className="text-3xl font-semibold tracking-tight">Consistent rhythm</h2>
          <p className="text-muted-foreground">
            Use semantic spacing, surfaces, and dividers to maintain predictable vertical rhythm across pages. Toggle the
            controls to preview each variant, including dark mode via the toolbar theme switcher.
          </p>
        </div>
        <div className="flex flex-wrap gap-4">
          <Button size="lg">Primary action</Button>
          <Button size="lg" variant="outline">
            Secondary
          </Button>
        </div>
      </div>
    </Section>
  ),
}

export const FullBleed: Story = {
  args: {
    contained: false,
    surface: "brand",
    size: "xl",
    divider: "both",
  },
  render: (args) => (
    <Section {...args} className="overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-br from-accent via-info to-info/90 opacity-90" />
      <div className="relative">
        <div className="py-section_lg">
          <div className="mx-auto max-w-4xl px-4 sm:px-6 lg:px-8 text-center text-accent-foreground">
            <h2 className="text-4xl font-bold tracking-tight">Full-bleed hero</h2>
            <p className="mt-4 text-lg text-foreground/90">
              Combine the Section primitive with your own layout primitives for wide experiences while preserving rhythm and
              divider tokens.
            </p>
          </div>
        </div>
      </div>
    </Section>
  ),
  parameters: {
    backgrounds: { default: "dark" },
  },
}
</file>

<file path="components/patterns/section.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

import { Container } from "./Container"

const outer = cva("relative w-full", {
  variants: {
    surface: {
      default: "bg-surface",
      subtle: "bg-surface-subtle",
      muted: "bg-surface-muted",
      elevated: "bg-surface-elevated shadow-sm",
      brand: "bg-surface-brand",
    },
    divider: {
      none: "",
      top: "border-t border-divider",
      bottom: "border-b border-divider",
      both: "border-y border-divider",
    },
  },
  defaultVariants: { surface: "default", divider: "none" },
})

const inner = cva("w-full", {
  variants: {
    size: {
      sm: "py-section_sm",
      md: "py-section_md",
      lg: "py-section_lg",
      xl: "py-section_xl",
    },
  },
  defaultVariants: { size: "lg" },
})

type SectionElement =
  | "section"
  | "div"
  | "header"
  | "footer"
  | "main"
  | "article"
  | "aside"

export type SectionProps<T extends SectionElement = "section"> = {
  as?: T
  contained?: boolean
  className?: string
  children?: React.ReactNode
} & VariantProps<typeof outer> &
  VariantProps<typeof inner> &
  Omit<React.ComponentPropsWithoutRef<T>, "as" | "className" | "children">

type SectionComponent = <T extends SectionElement = "section">(
  props: SectionProps<T> & { ref?: React.Ref<React.ElementRef<T>> },
) => React.ReactElement | null

const SectionBase = React.forwardRef(
  <T extends SectionElement = "section">(
    props: SectionProps<T>,
    ref: React.Ref<React.ElementRef<T>>,
  ) => {
    const {
      as,
      surface,
      divider,
      size,
      contained = true,
      className,
      children,
      ...rest
    } = props

    const Component = (as ?? "section") as React.ElementType

    return (
      <Component
        ref={ref}
        className={cn(outer({ surface, divider }), className)}
        {...rest}
      >
        <div className={cn(inner({ size }))}>
          {contained ? (
            <Container className="py-6 md:py-8">{children}</Container>
          ) : (
            <div className="py-6 md:py-8">{children}</div>
          )}
        </div>
      </Component>
    )
  },
)

SectionBase.displayName = "Section"

export const Section = SectionBase as SectionComponent
</file>

<file path="components/pricing/ComparisonTable.tsx">
"use client";

import React from "react";
import { Check, X } from "lucide-react";
import { cn } from "@/lib/utils";

interface Feature {
  name: string;
  basic: string | boolean;
  pro: string | boolean;
  allAccess: string | boolean;
}

interface FeatureCategory {
  category: string;
  features: Feature[];
}

interface ComparisonTableProps {
  categories: FeatureCategory[];
  onSelectPlan?: (planId: string) => void;
}

export function ComparisonTable({ categories, onSelectPlan }: ComparisonTableProps) {
  const renderFeatureValue = (value: string | boolean) => {
    if (typeof value === "boolean") {
      return value ? (
        <Check className="h-5 w-5 text-green-500 mx-auto" />
      ) : (
        <X className="h-5 w-5 text-gray-300 mx-auto" />
      );
    }
    return <span className="text-sm text-gray-900">{value}</span>;
  };

  return (
    <div className="overflow-hidden rounded-xl border border-gray-200 bg-white shadow-lg">
      {/* Desktop Table */}
      <div className="hidden lg:block">
        <table className="w-full">
          <thead>
            <tr className="border-b border-gray-200 bg-gray-50">
              <th className="px-6 py-4 text-left text-sm font-semibold text-gray-900">Features</th>
              <th className="px-6 py-4 text-center">
                <div className="space-y-1">
                  <div className="text-lg font-bold text-gray-900">Basic</div>
                  <div className="text-sm text-gray-600">$39/month</div>
                  {onSelectPlan && (
                    <button
                      onClick={() => onSelectPlan("basic")}
                      className="mt-2 rounded-md bg-gray-100 px-4 py-1.5 text-sm font-medium text-gray-700 hover:bg-gray-200 transition-colors"
                    >
                      Select Basic
                    </button>
                  )}
                </div>
              </th>
              <th className="px-6 py-4 text-center bg-blue-50">
                <div className="space-y-1">
                  <div className="flex items-center justify-center gap-2">
                    <div className="text-lg font-bold text-gray-900">Pro</div>
                    <span className="rounded-full bg-blue-500 px-2 py-0.5 text-xs font-semibold text-white">
                      POPULAR
                    </span>
                  </div>
                  <div className="text-sm text-gray-600">$59/month</div>
                  {onSelectPlan && (
                    <button
                      onClick={() => onSelectPlan("pro")}
                      className="mt-2 rounded-md bg-blue-600 px-4 py-1.5 text-sm font-medium text-white hover:bg-blue-700 transition-colors"
                    >
                      Select Pro
                    </button>
                  )}
                </div>
              </th>
              <th className="px-6 py-4 text-center">
                <div className="space-y-1">
                  <div className="text-lg font-bold text-gray-900">All-Access</div>
                  <div className="text-sm text-gray-600">$79/month</div>
                  {onSelectPlan && (
                    <button
                      onClick={() => onSelectPlan("all-access")}
                      className="mt-2 rounded-md bg-gray-900 px-4 py-1.5 text-sm font-medium text-white hover:bg-gray-800 transition-colors"
                    >
                      Select All-Access
                    </button>
                  )}
                </div>
              </th>
            </tr>
          </thead>
          <tbody>
            {categories.map((category) => (
              <React.Fragment key={category.category}>
                <tr className="border-t-2 border-gray-200">
                  <td
                    colSpan={4}
                    className="bg-gray-50 px-6 py-3 text-sm font-semibold text-gray-900"
                  >
                    {category.category}
                  </td>
                </tr>
                {category.features.map((feature, featureIndex) => (
                  <tr
                    key={feature.name}
                    className={cn(
                      "border-t border-gray-100",
                      featureIndex % 2 === 0 ? "bg-white" : "bg-gray-50/50"
                    )}
                  >
                    <td className="px-6 py-4 text-sm text-gray-700">{feature.name}</td>
                    <td className="px-6 py-4 text-center">{renderFeatureValue(feature.basic)}</td>
                    <td className="px-6 py-4 text-center bg-blue-50/30">
                      {renderFeatureValue(feature.pro)}
                    </td>
                    <td className="px-6 py-4 text-center">
                      {renderFeatureValue(feature.allAccess)}
                    </td>
                  </tr>
                ))}
              </React.Fragment>
            ))}
          </tbody>
        </table>
      </div>

      {/* Mobile Cards */}
      <div className="lg:hidden">
        <div className="border-b border-gray-200 bg-gray-50 p-4">
          <h3 className="text-lg font-semibold text-gray-900">Feature Comparison</h3>
        </div>
        <div className="divide-y divide-gray-200">
          {categories.map((category) => (
            <div key={category.category} className="p-4">
              <h4 className="mb-4 text-sm font-semibold text-gray-900">{category.category}</h4>
              {category.features.map((feature) => (
                <div key={feature.name} className="mb-4 last:mb-0">
                  <div className="mb-2 text-sm font-medium text-gray-700">{feature.name}</div>
                  <div className="grid grid-cols-3 gap-2 text-center">
                    <div className="rounded-lg bg-gray-50 p-2">
                      <div className="text-xs font-medium text-gray-600 mb-1">Basic</div>
                      {renderFeatureValue(feature.basic)}
                    </div>
                    <div className="rounded-lg bg-blue-50 p-2">
                      <div className="text-xs font-medium text-blue-600 mb-1">Pro</div>
                      {renderFeatureValue(feature.pro)}
                    </div>
                    <div className="rounded-lg bg-gray-50 p-2">
                      <div className="text-xs font-medium text-gray-600 mb-1">All-Access</div>
                      {renderFeatureValue(feature.allAccess)}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/pricing/PricingCard.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { PricingCard } from "./PricingCard"

const baseTier = {
  id: "starter",
  name: "Starter",
  description: "Essentials for individual learners preparing for Testero exams.",
  monthlyPrice: 29,
  annualPrice: 290,
  monthlyPriceId: "price_monthly",
  annualPriceId: "price_annual",
  aiCredits: 200,
  features: [
    "Adaptive practice exams",
    "Weekly study plan",
    "Email reminders",
  ],
  highlighted: ["Exam-day readiness checklist"],
  recommended: false,
  savingsPercentage: 20,
}

const recommendedTier = {
  ...baseTier,
  id: "pro",
  name: "Pro",
  monthlyPrice: 59,
  annualPrice: 590,
  aiCredits: 500,
  highlighted: ["1:1 readiness review", "Priority question support"],
  features: [...baseTier.features, "Live cohort workshops"],
  recommended: true,
  savingsPercentage: 25,
}

const meta: Meta<typeof PricingCard> = {
  title: "Pricing/PricingCard",
  component: PricingCard,
  args: {
    billingInterval: "monthly",
    loading: false,
    loadingId: null,
    onCheckout: (priceId: string, tierName: string) => {
      console.log(`Checkout â†’ ${tierName} (${priceId})`)
    },
  },
  argTypes: {
    billingInterval: {
      control: { type: "inline-radio" },
      options: ["monthly", "annual"],
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Monthly: Story = {
  args: {
    tier: baseTier,
  },
}

export const AnnualRecommended: Story = {
  args: {
    tier: recommendedTier,
    billingInterval: "annual",
  },
}
</file>

<file path="components/pricing/PricingCard.tsx">
"use client";

import React from "react";
import { CheckCircle, Sparkles, TrendingUp } from "lucide-react";

import { Badge } from "@/components/ui/badge";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface PricingCardProps {
  tier: {
    id: string;
    name: string;
    description: string;
    monthlyPrice: number;
    annualPrice: number;
    monthlyPriceId?: string;
    annualPriceId?: string;
    aiCredits: number;
    features: string[];
    highlighted?: string[];
    recommended?: boolean;
    savingsPercentage?: number;
  };
  billingInterval: "monthly" | "annual";
  onCheckout: (priceId: string, tierName: string) => void;
  loading?: boolean;
  loadingId?: string | null;
}

export function PricingCard({
  tier,
  billingInterval,
  onCheckout,
  loading = false,
  loadingId = null,
}: PricingCardProps) {
  const price = billingInterval === "monthly" ? tier.monthlyPrice : tier.annualPrice;
  const priceId = billingInterval === "monthly" ? tier.monthlyPriceId : tier.annualPriceId;
  const checkoutPriceId = priceId ?? `${tier.id}-${billingInterval}`;
  const isCheckoutConfigured = Boolean(priceId);
  const isLoading = loading && loadingId === priceId;
  const monthlyEquivalent = billingInterval === "annual" ? Math.round(tier.annualPrice / 12) : null;

  return (
    <Card
      data-recommended={tier.recommended ? "true" : undefined}
      variant={tier.recommended ? "elevated" : "default"}
      size="lg"
      className={cn(
        "relative w-full",
        tier.recommended
          ? "border-accent/50 ring-2 ring-accent/25"
          : "border-border/60",
        billingInterval === "annual" && tier.savingsPercentage ? "pt-6" : ""
      )}
    >
      {tier.recommended ? (
        <div className="absolute inset-x-0 -top-4 flex justify-center">
          <Badge
            tone="accent"
            variant="solid"
            icon={<Sparkles className="h-4 w-4" aria-hidden="true" />}
            className="shadow-lg"
          >
            Most popular
          </Badge>
        </div>
      ) : null}

      {billingInterval === "annual" && tier.savingsPercentage ? (
        <div className={cn(
          "absolute right-6",
          tier.recommended ? "top-12" : "top-6"
        )}>
          <Badge
            tone="success"
            variant="soft"
            size="sm"
            className="shadow-sm bg-emerald-700 text-white"
          >
            Save {tier.savingsPercentage}%
          </Badge>
        </div>
      ) : null}

      <CardHeader className="gap-2">
        <CardTitle className="text-3xl font-semibold text-foreground">
          {tier.name}
        </CardTitle>
        <CardDescription>{tier.description}</CardDescription>
      </CardHeader>

      <CardContent className="gap-6">
        <div className="space-y-3">
          <div className="flex items-baseline gap-2">
            <span className="text-5xl font-semibold tracking-tight text-foreground">
              ${price}
            </span>
            <span className="text-lg text-muted-foreground">
              /{billingInterval === "monthly" ? "month" : "year"}
            </span>
          </div>
          {monthlyEquivalent ? (
            <p className="text-sm text-muted-foreground">
              That&apos;s only ${monthlyEquivalent}/month
            </p>
          ) : null}
          <div className="flex items-center gap-2 text-sm font-medium text-accent-foreground">
            <TrendingUp className="h-4 w-4" aria-hidden="true" />
            {tier.aiCredits} AI credits included monthly
          </div>
        </div>

        {tier.highlighted && tier.highlighted.length > 0 ? (
          <div className="space-y-2 rounded-lg border border-accent/30 bg-accent/5 p-4 md:p-6">
            {tier.highlighted.map((feature) => (
              <div key={feature} className="flex items-center gap-2">
                <CheckCircle className="h-5 w-5 flex-shrink-0 text-accent" aria-hidden="true" />
                <span className="text-sm font-medium text-foreground">{feature}</span>
              </div>
            ))}
          </div>
        ) : null}

        <ul className="space-y-3">
          {tier.features.map((feature) => (
            <li key={feature} className="flex items-start gap-3 text-sm text-muted-foreground">
              <CheckCircle className="mt-0.5 h-5 w-5 flex-shrink-0 text-success" aria-hidden="true" />
              <span>{feature}</span>
            </li>
          ))}
        </ul>
      </CardContent>

      <CardFooter className="flex-col items-stretch gap-3 border-0 pt-0">
        <Button
          fullWidth
          tone={tier.recommended ? "accent" : "neutral"}
          variant="solid"
          size="lg"
          loading={isLoading}
          disabled={isLoading || !isCheckoutConfigured}
          data-checkout-configured={isCheckoutConfigured ? "true" : "false"}
          onClick={() => onCheckout(checkoutPriceId, tier.name)}
        >
          Get started
        </Button>

        {tier.recommended ? (
          <p className="text-center text-xs text-muted-foreground">
            Chosen by 73% of our users
          </p>
        ) : null}
      </CardFooter>
    </Card>
  );
}
</file>

<file path="components/providers/AuthProvider.tsx">
"use client";

import React, { createContext, useContext, useEffect, useState } from "react";
import { supabase } from "@/lib/supabase/client";
import type { Session, User } from "@supabase/supabase-js";
import { usePostHog } from "posthog-js/react";

type AuthContextType = {
  session: Session | null;
  user: User | null;
  isLoading: boolean;
  signOut: () => Promise<void>;
  refreshSession: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Route protection is now handled by middleware

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const posthog = usePostHog();

  useEffect(() => {
    const fetchSession = async () => {
      try {
        // Get the initial session
        const { data, error } = await supabase.auth.getSession();

        if (error) {
          console.error("Error fetching session:", error.message);
        }

        handleSessionChange(data.session);
      } catch (err) {
        console.error("Unexpected error during session fetch:", err);
      } finally {
        setIsLoading(false);
      }
    };

    // Initial session fetch
    fetchSession();

    // Subscribe to auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      handleSessionChange(session);
    });

    return () => {
      subscription.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);


  const handleSessionChange = (newSession: Session | null) => {
    setSession(newSession);
    setUser(newSession?.user || null);

    // Identify user in PostHog when session changes
    if (newSession?.user && posthog) {
      // Identify the user with their ID
      posthog.identify(newSession.user.id, {
        email: newSession.user.email,
        created_at: newSession.user.created_at,
        is_early_access: newSession.user.user_metadata?.is_early_access === true,
        email_confirmed: !!newSession.user.email_confirmed_at,
        // Add any other user metadata that might be useful
        provider: newSession.user.app_metadata?.provider || "email",
      });

      // Track successful login/session restoration
      posthog.capture("user_session_started", {
        session_type: "authenticated",
        user_id: newSession.user.id,
      });
    } else if (!newSession && posthog) {
      // Reset PostHog when user logs out
      posthog.reset();

      // Track logout
      posthog.capture("user_session_ended", {
        session_type: "logged_out",
      });
    }
  };

  const signOut = async () => {
    try {
      setIsLoading(true);
      const { error } = await supabase.auth.signOut();
      if (error) throw error;

      // Clear the session state
      setSession(null);
      setUser(null);

      // Redirect will be handled by middleware
      window.location.href = "/login";
    } catch (error) {
      console.error("Error signing out:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const refreshSession = async () => {
    try {
      setIsLoading(true);
      const { data, error } = await supabase.auth.refreshSession();

      if (error) throw error;

      handleSessionChange(data.session);
    } catch (error) {
      console.error("Error refreshing session:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AuthContext.Provider value={{ session, user, isLoading, signOut, refreshSession }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
</file>

<file path="components/ui/__stories__/docs/EmptyState.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as EmptyStateStories from "../EmptyState.stories"

<Meta of={EmptyStateStories} title="Design System/EmptyState/Docs" />

# EmptyState

EmptyState communicates absence, loading, or error scenarios using consistent iconography, copy, and actions.

## When to use

- A collection has no data yet (first-run experience).
- A filter removes every result and we need to explain next steps.
- A recoverable error occurs and the user can retry or learn more.

## Usage

```tsx
import { EmptyState } from "@/components/ui"
import { Inbox } from "lucide-react"

export function NoSessions() {
  return (
    <EmptyState
      tone="info"
      icon={<Inbox aria-hidden="true" className="size-6" />}
      statusLabel="No sessions"
      title="You're all caught up"
      description="Start a new diagnostic session or import historic runs to compare trends."
      primaryAction={{ label: "Start session", onClick: () => console.log("start") }}
      secondaryAction={{ label: "Import CSV", onClick: () => console.log("import") }}
    />
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={EmptyStateStories.Neutral} />

## Do

- Tailor the headline to be outcome oriented (e.g. "Start your first experiment").
- Pair status icons with `statusLabel` so color is never the only cue.
- Keep descriptions short (two sentences max) and actionable.

## Don't

- Use destructive tone for empty resultsâ€”reserve it for actual failures.
- Stack more than two call-to-action buttons; link secondary tasks elsewhere.
- Leave the icon as the only focusable elementâ€”actions must be keyboard reachable.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/docs/PageHeader.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as PageHeaderStories from "../PageHeader.stories"

<Meta of={PageHeaderStories} title="Design System/PageHeader/Docs" />

# PageHeader

The PageHeader provides a consistent hero block for authenticated layouts. It aligns breadcrumbs, titles, descriptions, and quick actions so that every view opens with a predictable rhythm.

## When to use

- Introduce a new product surface or dashboard route.
- Provide contextual breadcrumbs and supporting copy above a dense layout.
- Pair with tabs or filters that live directly beneath the header.

Avoid using PageHeader for inline sections inside a pageâ€”prefer stacked `Card` components instead.

## Usage

```tsx
import { PageHeader, Button } from "@/components/ui"

export function ExperimentsHeader() {
  return (
    <PageHeader
      tone="muted"
      align="between"
      breadcrumbs={[
        { label: "Dashboard", href: "/app" },
        { label: "Experiments" },
      ]}
      title="Experiment overview"
      description="Compare how each test is trending and notify collaborators when an action is needed."
      actions={
        <div className="flex gap-2">
          <Button variant="ghost" tone="neutral">
            Share report
          </Button>
          <Button tone="accent">New experiment</Button>
        </div>
      }
    />
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={PageHeaderStories.Default} />

## Do

- Keep titles conciseâ€”one line is ideal and two lines is the maximum.
- Use `tone="muted"` when the page background needs subtle separation from the canvas.
- Switch `density="compact"` when the header sits above tables or forms.

## Don't

- Nest PageHeaders inside cards or modals.
- Combine more than three breadcrumb levels; collapse intermediate destinations instead.
- Place destructive actions (like delete) in the primary action slotâ€”prefer menus.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/docs/Table.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as TableStories from "../Table.stories"

<Meta of={TableStories} title="Design System/Table/Docs" />

# Table

Table renders accessible tabular data with sortable headers, zebra striping, and empty/loading states.

## When to use

- Display structured datasets such as experiments, billing history, or feature flags.
- Allow operators to sort by key metrics like status or conversion rate.
- Embed contextual empty states when a dataset has no rows.

## Usage

```tsx
import { Table } from "@/components/ui"

const columns = [
  { id: "name", header: "Study", sortable: true },
  { id: "moderator", header: "Moderator" },
  { id: "status", header: "Status" },
  { id: "lastRun", header: "Last run", sortable: true },
]

const data = [
  { id: "study-1", name: "GenAI onboarding", moderator: "Priya", status: "Running", lastRun: "Mar 12" },
  { id: "study-2", name: "Pricing survey", moderator: "Noah", status: "Draft", lastRun: "Mar 4" },
]

export function StudiesTable() {
  return (
    <Table
      columns={columns}
      data={data}
      caption="Current usability studies and moderators"
      onSortChange={(columnId, direction) => {
        // Update data ordering upstream when the user sorts.
      }}
    />
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={TableStories.InteractiveSorting} />

## Do

- Provide a `caption` for screen readers even if you hide it visually.
- Keep numeric columns right-aligned so magnitudes are easy to compare.
- Use the `emptyState` prop to show recovery guidance when there are zero rows.

## Don't

- Hide critical context in tooltips; keep key values visible.
- Overload headers with long sentencesâ€”use concise nouns or verbs.
- Enable sorting on columns that render badges or custom JSX without a clear ordering.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/docs/Toast.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as ToastStories from "../Toast.stories"

<Meta of={ToastStories} title="Design System/Toast/Docs" />

# Toast

Toast surfaces transient notifications without interrupting the current workflow.

## When to use

- Confirm that a background task completed (save, export, sync).
- Warn users about degraded performance while recovery continues.
- Offer an undo affordance shortly after an action.

## Usage

```tsx
import { Toast, useToastQueue } from "@/components/ui"

export function ToastManager() {
  const { toasts, addToast, dismissToast } = useToastQueue()

  return (
    <div>
      <button
        className="rounded-md bg-primary px-3 py-2 text-primary-foreground"
        onClick={() =>
          addToast({
            tone: "success",
            title: "Report exported",
            description: "We emailed the download link to you.",
            dismissible: true,
          })
        }
      >
        Trigger toast
      </button>

      <div className="mt-4 flex flex-col gap-3">
        {toasts.map(({ id, ...toast }) => (
          <Toast key={id} {...toast} onClose={() => dismissToast(id)} />
        ))}
      </div>
    </div>
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={ToastStories.Info} />

## Do

- Set `tone` based on semantic meaning: `success` for confirmations, `warning` for recoverable risks, `danger` for critical issues.
- Provide meaningful button labels (e.g. "View report" instead of "OK").
- Respect reduced motion preferencesâ€”the component removes transitions automatically.

## Don't

- Queue more than three toasts at once; collapse or replace older messages instead.
- Use toast for blocking confirmationsâ€”use a modal or inline banner instead.
- Leave a toast dismissible without also wiring an `onClose` handler.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/Badge.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { Badge, type BadgeProps } from "../badge"

const meta: Meta<typeof Badge> = {
  title: "UI/Badge",
  component: Badge,
  args: {
    children: "Badge label",
    variant: "soft",
    tone: "accent",
    size: "md",
  },
  argTypes: {
    variant: {
      control: { type: "inline-radio" },
      options: ["solid", "soft", "outline", "ghost"],
    },
    tone: {
      control: { type: "select" },
      options: ["default", "accent", "success", "warning", "danger", "neutral", "info"],
    },
    size: {
      control: { type: "inline-radio" },
      options: ["sm", "md"],
    },
    icon: { control: false },
    asChild: { control: { type: "boolean" } },
  },
  parameters: {
    docs: {
      description: {
        component:
          "Semantic badge primitive that maps tone + variant props to design tokens. Supports icon slots and ghost/outline styles for marketing use cases.",
      },
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Playground: Story = {}

const tones: BadgeProps["tone"][] = [
  "default",
  "accent",
  "success",
  "warning",
  "danger",
  "neutral",
  "info",
]

export const ToneMatrix: Story = {
  render: (args) => (
    <div className="flex flex-wrap gap-3">
      {tones.map((tone) => (
        <Badge key={tone} {...args} tone={tone}>
          {tone}
        </Badge>
      ))}
    </div>
  ),
}
</file>

<file path="components/ui/__stories__/EmptyState.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { Inbox, ShieldAlert, Sparkles, Star, Upload } from "lucide-react"

import { Button } from "../button"
import { EmptyState } from "../empty-state"

const meta: Meta<typeof EmptyState> = {
  title: "Design System/EmptyState",
  component: EmptyState,
  parameters: {
    layout: "centered",
  },
  args: {
    title: "No conversations yet",
    description: "Kick off your next study by inviting candidates or importing interview notes.",
    icon: <Inbox aria-hidden="true" className="size-6" />,
    iconAriaLabel: "Empty inbox",
    tone: "neutral",
    size: "md",
    alignment: "center",
  },
  argTypes: {
    tone: {
      control: "inline-radio",
      options: ["neutral", "info", "success", "warning", "danger"],
    },
    size: {
      control: "inline-radio",
      options: ["sm", "md", "lg"],
    },
    alignment: {
      control: "inline-radio",
      options: ["center", "left"],
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Neutral: Story = {
  args: {
    primaryAction: {
      label: "Invite participants",
      onClick: () => console.log("invite"),
    },
    secondaryAction: {
      label: "Import CSV",
      onClick: () => console.log("import"),
    },
  },
}

export const Informational: Story = {
  args: {
    tone: "info",
    icon: <Sparkles aria-hidden="true" className="size-6" />,
    statusLabel: "Recommendations",
    title: "Fine-tune your prompts",
    description:
      "Review the generative AI checklist to improve reliability before sharing with the team.",
  },
}

export const Success: Story = {
  args: {
    tone: "success",
    icon: <Star aria-hidden="true" className="size-6" />,
    title: "All caught up",
    description: "Every diagnostic has been reviewed. We'll notify you if something changes.",
  },
}

export const Warning: Story = {
  args: {
    tone: "warning",
    icon: <ShieldAlert aria-hidden="true" className="size-6" />,
    title: "Quota nearly reached",
    description: "Usage is at 92% of your monthly limit. Upgrade to avoid throttling.",
    primaryAction: {
      label: "Upgrade plan",
      onClick: () => console.log("upgrade"),
    },
  },
}

export const DangerLeftAligned: Story = {
  args: {
    tone: "danger",
    alignment: "left",
    size: "lg",
    icon: <Upload aria-hidden="true" className="size-6" />,
    statusLabel: "Upload failed",
    title: "We couldn't process your file",
    description: (
      <span>
        Double-check the template and try again. <Button variant="link">Download sample</Button>
      </span>
    ),
  },
}
</file>

<file path="components/ui/__stories__/PageHeader.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { Button } from "../button"
import { PageHeader } from "../page-header"

const meta: Meta<typeof PageHeader> = {
  title: "Design System/PageHeader",
  component: PageHeader,
  parameters: {
    layout: "fullscreen",
  },
  args: {
    title: "Analytics overview",
    description: "Monitor how each experiment performs and spot bottlenecks before they grow.",
  },
  argTypes: {
    density: {
      control: "inline-radio",
      options: ["comfortable", "compact"],
    },
    align: {
      control: "inline-radio",
      options: ["left", "between"],
    },
    tone: {
      control: "inline-radio",
      options: ["default", "muted"],
    },
    headingLevel: {
      control: "inline-radio",
      options: ["h1", "h2", "h3", "h4", "h5", "h6"],
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Default: Story = {}

export const WithBreadcrumbs: Story = {
  args: {
    breadcrumbs: [
      { label: "Dashboard", href: "#" },
      { label: "Analytics", href: "#" },
      { label: "Overview" },
    ],
  },
}

export const WithActions: Story = {
  args: {
    align: "between",
    actions: (
      <div className="flex flex-wrap items-center gap-2">
        <Button variant="ghost" tone="neutral">
          Share
        </Button>
        <Button tone="accent">Create report</Button>
      </div>
    ),
  },
}

export const MutedSurface: Story = {
  args: {
    tone: "muted",
    breadcrumbs: [
      { label: "Billing", href: "#" },
      { label: "Plans" },
    ],
    actions: (
      <Button tone="accent">Upgrade plan</Button>
    ),
  },
}

export const CompactDensity: Story = {
  args: {
    density: "compact",
    description: "Use compact density for data-heavy views or layouts with limited vertical space.",
  },
}

export const NoDescription: Story = {
  args: {
    description: undefined,
    breadcrumbs: [{ label: "Settings" }],
  },
}
</file>

<file path="components/ui/__stories__/Table.stories.tsx">
import * as React from "react"
import type { Meta, StoryObj } from "@storybook/react"

import { Sparkles } from "lucide-react"

import { Badge } from "../badge"
import { Table, type SortDirection, type TableColumn, type TableProps } from "../table"
import { EmptyState } from "../empty-state"

type ExperimentRow = {
  id: string
  experiment: string
  owner: string
  status: "Running" | "Paused" | "Draft"
  conversions: number
  updated: string
}

const columns: TableColumn<ExperimentRow>[] = [
  {
    id: "experiment",
    header: "Experiment",
    accessor: (row) => row.experiment,
    sortable: true,
    width: "28%",
  },
  {
    id: "owner",
    header: "Owner",
    accessor: (row) => row.owner,
    sortable: true,
  },
  {
    id: "status",
    header: "Status",
    accessor: (row) => {
      const tone =
        row.status === "Running"
          ? "success"
          : row.status === "Paused"
          ? "warning"
          : "default"

      return (
        <Badge variant="soft" tone={tone} className="font-medium">
          {row.status}
        </Badge>
      )
    },
  },
  {
    id: "conversions",
    header: "Conversions",
    accessor: (row) => row.conversions.toLocaleString(),
    align: "right",
    sortable: true,
  },
  {
    id: "updated",
    header: "Last updated",
    accessor: (row) => row.updated,
    sortable: true,
  },
]

const data: ExperimentRow[] = [
  {
    id: "exp-01",
    experiment: "Pricing paywall copy",
    owner: "Leah Griffin",
    status: "Running",
    conversions: 1420,
    updated: "2025-02-14",
  },
  {
    id: "exp-02",
    experiment: "Onboarding checklist",
    owner: "Ibrahim Noor",
    status: "Paused",
    conversions: 980,
    updated: "2025-02-11",
  },
  {
    id: "exp-03",
    experiment: "New hero illustration",
    owner: "Joana Silva",
    status: "Draft",
    conversions: 312,
    updated: "2025-01-28",
  },
  {
    id: "exp-04",
    experiment: "Free trial CTA",
    owner: "Hector Lin",
    status: "Running",
    conversions: 1845,
    updated: "2025-02-03",
  },
]

const meta: Meta<typeof Table> = {
  title: "Design System/Table",
  component: Table,
  parameters: {
    layout: "fullscreen",
  },
  args: {
    columns: columns as unknown as TableColumn<unknown>[],
    data,
    caption: "List of experiments with owner, status, and conversions",
  },
  argTypes: {
    density: {
      control: "inline-radio",
      options: ["comfortable", "compact"],
    },
    zebra: {
      control: "boolean",
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

type SortState = { id: string; dir: SortDirection } | undefined

const useSortedData = (rows: ExperimentRow[], sort: SortState) => {
  return React.useMemo(() => {
    if (!sort) return rows
    const key = sort.id as keyof ExperimentRow
    return [...rows].sort((a, b) => {
      const aValue = a[key]
      const bValue = b[key]
      if (typeof aValue === "number" && typeof bValue === "number") {
        return sort.dir === "asc" ? aValue - bValue : bValue - aValue
      }
      return sort.dir === "asc"
        ? String(aValue).localeCompare(String(bValue))
        : String(bValue).localeCompare(String(aValue))
    })
  }, [rows, sort])
}

type ExperimentTableProps = TableProps<ExperimentRow>

const SortingExample: React.FC<ExperimentTableProps> = (props) => {
  const { data: rows, onSortChange, ...rest } = props
  const [sort, setSort] = React.useState<SortState>()
  const sortedRows = useSortedData((rows as ExperimentRow[]) ?? [], sort)

  const handleSortChange = React.useCallback(
    (columnId: string, direction: SortDirection | null) => {
      setSort(direction ? { id: columnId, dir: direction } : undefined)
      onSortChange?.(columnId, direction)
    },
    [onSortChange]
  )

  return (
    <Table<ExperimentRow>
      {...rest}
      data={sortedRows}
      sort={sort}
      onSortChange={handleSortChange}
    />
  )
}

export const InteractiveSorting: Story = {
  render: (args) => (
    <div className="mx-auto max-w-5xl p-6">
      <SortingExample {...(args as ExperimentTableProps)} />
    </div>
  ),
}

export const CompactDensity: Story = {
  render: (args) => (
    <div className="mx-auto max-w-4xl p-6">
      <SortingExample
        {...(args as ExperimentTableProps)}
        density="compact"
        zebra
      />
    </div>
  ),
}

export const Loading: Story = {
  args: {
    isLoading: true,
  },
}

export const Empty: Story = {
  args: {
    data: [],
  },
}

export const CustomEmptyState: Story = {
  args: {
    data: [],
    emptyState: (
      <EmptyState
        tone="info"
        icon={<Sparkles aria-hidden="true" className="size-6" />}
        statusLabel="No experiments yet"
        title="Start by launching your first test"
        description="A guided setup will walk you through defining hypotheses and rollout criteria."
        primaryAction={{ label: "Launch experiment", onClick: () => console.log("launch") }}
      />
    ),
  },
}
</file>

<file path="components/ui/__stories__/Toast.stories.tsx">
import * as React from "react"
import type { Meta, StoryObj } from "@storybook/react"

import { Button } from "../button"
import { Toast, type ToastProps, useToastQueue } from "../toast"

const meta: Meta<typeof Toast> = {
  title: "Design System/Toast",
  component: Toast,
  parameters: {
    layout: "centered",
  },
  args: {
    tone: "info",
    elevation: "sm",
    dismissible: true,
    title: "Changes published",
    description: "Your updates are now live for all reviewers.",
  },
  argTypes: {
    tone: {
      control: "inline-radio",
      options: ["info", "success", "warning", "danger"],
    },
    elevation: {
      control: "inline-radio",
      options: ["none", "sm", "md"],
    },
    dismissible: {
      control: "boolean",
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Info: Story = {
  args: {
    action: {
      label: "View", 
      onClick: () => console.log("view"),
    },
  },
}

export const Success: Story = {
  args: {
    tone: "success",
    title: "Diagnostics exported",
    description: "We emailed the report to your analytics inbox.",
    action: {
      label: "Undo",
      onClick: () => console.log("undo"),
    },
  },
}

export const Warning: Story = {
  args: {
    tone: "warning",
    title: "Connection unstable",
    description: "We'll keep trying in the background and alert you if it fails.",
  },
}

export const Danger: Story = {
  args: {
    tone: "danger",
    title: "Sync failed",
    description: "Retry syncing the library or download a backup.",
    action: {
      label: "Retry",
      onClick: () => console.log("retry"),
    },
  },
}

const QueueDemo = () => {
  const { toasts, addToast, dismissToast } = useToastQueue()

  const pushToast = (overrides: Partial<ToastProps>) => {
    addToast({
      tone: "info",
      dismissible: true,
      elevation: "md",
      title: "Workflow saved",
      description: "Changes will publish once approved.",
      ...overrides,
    })
  }

  return (
    <div className="flex w-full max-w-sm flex-col gap-4">
      <div className="flex flex-wrap gap-2">
        <Button onClick={() => pushToast({ tone: "success", title: "Segment created", description: "It will appear in targeting shortly." })}>
          Success toast
        </Button>
        <Button variant="outline" onClick={() => pushToast({ tone: "warning", title: "API latency", description: "Traffic is spiking, we are scaling workers." })}>
          Warning toast
        </Button>
        <Button variant="ghost" tone="danger" onClick={() => pushToast({ tone: "danger", title: "Deployment failed", description: "Rollback triggered. Investigate the build logs." })}>
          Danger toast
        </Button>
      </div>
      <div className="flex flex-col gap-3">
        {toasts.length === 0 ? (
          <div className="rounded-lg border border-dashed border-border/60 p-6 text-sm text-muted-foreground">
            Trigger a toast to preview the stack.
          </div>
        ) : (
          toasts.map(({ id, ...toast }) => (
            <Toast
              key={id}
              {...toast}
              onClose={() => dismissToast(id)}
            />
          ))
        )}
      </div>
    </div>
  )
}

export const Queue: Story = {
  render: () => <QueueDemo />,
}
</file>

<file path="components/ui/__tests__/button.a11y.test.tsx">
import * as React from "react"
import { render, screen } from "@testing-library/react"
import userEvent from "@testing-library/user-event"

import { Button } from "../button"

describe("Button accessibility", () => {
  it("renders supported variants and tones", () => {
    const { container } = render(
      <div className="flex flex-wrap gap-2">
        {(["solid", "soft", "outline", "ghost", "link"] as const).map((variant) => (
          <Button key={variant} variant={variant} tone="accent" size="sm">
            {variant}
          </Button>
        ))}
        {(["default", "accent", "success", "warn", "danger", "neutral"] as const).map((tone) => (
          <Button key={tone} variant="solid" tone={tone} size="md">
            {tone}
          </Button>
        ))}
      </div>
    )

    expect(container.querySelectorAll("button").length).toBeGreaterThan(0)
  })

  it("exposes focus-visible ring classes for keyboard users", async () => {
    const user = userEvent.setup()
    render(<Button>Focus me</Button>)

    await user.tab()
    const button = screen.getByRole("button", { name: "Focus me" })

    expect(document.activeElement).toBe(button)
    expect(button.className).toEqual(expect.stringContaining("focus-visible:ring-2"))
    expect(button.className).toEqual(expect.stringContaining("focus-visible:ring-offset-2"))
  })

  it("prevents interaction when disabled or loading", async () => {
    const user = userEvent.setup()
    const onClick = jest.fn()

    render(
      <div className="space-y-2">
        <Button onClick={onClick} disabled>
          Disabled
        </Button>
        <Button onClick={onClick} loading icon={<span aria-hidden="true" />}>
          Loading
        </Button>
      </div>
    )

    const disabledButton = screen.getByRole("button", { name: "Disabled" })
    const loadingButton = screen.getByRole("button", { name: "Loading" })

    await user.click(disabledButton)
    await user.click(loadingButton)

    expect(onClick).not.toHaveBeenCalled()
    expect(disabledButton).toHaveAttribute("aria-disabled", "true")
    expect(loadingButton).toHaveAttribute("aria-disabled", "true")
    expect(loadingButton).toHaveAttribute("aria-busy", "true")
    expect(loadingButton.querySelector("svg")).toBeTruthy()
  })
})
</file>

<file path="components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full font-medium leading-none transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-foreground/20 focus-visible:ring-offset-2 focus-visible:ring-offset-background whitespace-nowrap select-none",
  {
    variants: {
      variant: {
        solid: "shadow-sm",
        soft: "ring-1 ring-inset",
        outline: "bg-background ring-1 ring-inset",
        ghost: "bg-transparent",
      },
      tone: {
        default: "text-foreground",
        accent: "text-accent",
        success: "text-success",
        warning: "text-warning",
        danger: "text-error",
        neutral: "text-muted-foreground",
        info: "text-info",
      },
      size: {
        sm: "h-6 px-2 text-xs gap-1",
        md: "h-7 px-2.5 text-sm gap-1.5",
      },
    },
    compoundVariants: [
      {
        variant: "solid",
        tone: "default",
        class: "bg-foreground text-background",
      },
      {
        variant: "solid",
        tone: "accent",
        class: "bg-accent text-accent-foreground",
      },
      {
        variant: "solid",
        tone: "success",
        class: "bg-success text-background",
      },
      {
        variant: "solid",
        tone: "warning",
        class: "bg-warning text-background",
      },
      {
        variant: "solid",
        tone: "danger",
        class: "bg-error text-background",
      },
      {
        variant: "solid",
        tone: "neutral",
        class: "bg-muted text-foreground",
      },
      {
        variant: "solid",
        tone: "info",
        class: "bg-info text-background",
      },
      {
        variant: "soft",
        tone: "default",
        class: "bg-muted text-foreground ring-border/60",
      },
      {
        variant: "soft",
        tone: "accent",
        class: "bg-accent/10 text-[color:var(--tone-accent)] ring-[color:var(--tone-accent)]/20",
      },
      {
        variant: "soft",
        tone: "success",
        class: "bg-success/10 text-success ring-success/20",
      },
      {
        variant: "soft",
        tone: "warning",
        class: "bg-warning/15 text-warning-dark ring-warning/30",
      },
      {
        variant: "soft",
        tone: "danger",
        class: "bg-error/10 text-error ring-error/20",
      },
      {
        variant: "soft",
        tone: "neutral",
        class: "bg-muted/70 text-muted-foreground ring-border/40",
      },
      {
        variant: "soft",
        tone: "info",
        class: "bg-info/10 text-info ring-info/20",
      },
      {
        variant: "outline",
        tone: "default",
        class: "text-foreground ring-border/70",
      },
      {
        variant: "outline",
        tone: "accent",
        class: "text-[color:var(--tone-accent)] ring-[color:var(--tone-accent)]/40",
      },
      {
        variant: "outline",
        tone: "success",
        class: "text-success ring-success/35",
      },
      {
        variant: "outline",
        tone: "warning",
        class: "text-warning-dark ring-warning/40",
      },
      {
        variant: "outline",
        tone: "danger",
        class: "text-error ring-error/40",
      },
      {
        variant: "outline",
        tone: "neutral",
        class: "text-muted-foreground ring-border/50",
      },
      {
        variant: "outline",
        tone: "info",
        class: "text-info ring-info/35",
      },
      {
        variant: "ghost",
        tone: "default",
        class: "hover:bg-muted/70",
      },
      {
        variant: "ghost",
        tone: "accent",
        class: "text-[color:var(--tone-accent)] hover:bg-accent/10",
      },
      {
        variant: "ghost",
        tone: "success",
        class: "text-success hover:bg-success/10",
      },
      {
        variant: "ghost",
        tone: "warning",
        class: "text-warning-dark hover:bg-warning/10",
      },
      {
        variant: "ghost",
        tone: "danger",
        class: "text-error hover:bg-error/10",
      },
      {
        variant: "ghost",
        tone: "neutral",
        class: "text-muted-foreground hover:bg-muted/60",
      },
      {
        variant: "ghost",
        tone: "info",
        class: "text-info hover:bg-info/10",
      },
    ],
    defaultVariants: {
      variant: "soft",
      tone: "default",
      size: "md",
    },
  }
)

const badgeIconVariants = cva("flex items-center justify-center shrink-0", {
  variants: {
    size: {
      sm: "h-3.5 w-3.5",
      md: "h-4 w-4",
    },
  },
  defaultVariants: {
    size: "md",
  },
})

export type BadgeProps = React.HTMLAttributes<HTMLSpanElement> &
  VariantProps<typeof badgeVariants> & {
    icon?: React.ReactNode
    asChild?: boolean
  }

const Badge = React.forwardRef<HTMLSpanElement, BadgeProps>(
  ({ className, variant, tone, size, icon, asChild, children, ...props }, ref) => {
    const Comp = asChild ? Slot : "span"

    return (
      <Comp
        ref={ref}
        data-slot="badge"
        className={cn(badgeVariants({ variant, tone, size }), className)}
        {...props}
      >
        {icon ? (
          <span aria-hidden className={badgeIconVariants({ size })}>
            {icon}
          </span>
        ) : null}
        <span className="truncate">{children}</span>
      </Comp>
    )
  }
)
Badge.displayName = "Badge"

export { Badge, badgeVariants }
export default Badge
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import {
  buttonBase,
  buttonSizeStyles,
  buttonVariantStyles,
} from "@/lib/design-system/components"

const button = cva(buttonBase, {
  variants: {
    variant: {
      solid: buttonVariantStyles.solid,
      soft: buttonVariantStyles.soft,
      outline: buttonVariantStyles.outline,
      ghost: buttonVariantStyles.ghost,
      link: buttonVariantStyles.link,
    },
    tone: {
      default: buttonVariantStyles.tone.default,
      accent: buttonVariantStyles.tone.accent,
      success: buttonVariantStyles.tone.success,
      warn: buttonVariantStyles.tone.warn,
      danger: buttonVariantStyles.tone.danger,
      neutral: buttonVariantStyles.tone.neutral,
    },
    size: {
      sm: buttonSizeStyles.sm,
      md: buttonSizeStyles.md,
      lg: buttonSizeStyles.lg,
    },
    fullWidth: {
      true: "w-full",
    },
  },
  defaultVariants: {
    variant: "solid",
    tone: "accent",
    size: "md",
  },
})

function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]) {
  return (value: T) => {
    for (const ref of refs) {
      if (typeof ref === "function") {
        ref(value)
      } else if (ref) {
        ;(ref as React.MutableRefObject<T | null>).current = value
      }
    }
  }
}

/**
 * The canonical button component for the Testero design system.
 *
 * @remarks
 * - `variant` controls the structural treatment (`solid`, `soft`, `outline`, `ghost`, `link`).
 * - `tone` applies semantic color intent mapped to tokens (`default`, `accent`, `success`, `warn`, `danger`, `neutral`).
 * - `size` ensures token-backed spacing with md/lg meeting a â‰¥44px hit area.
 * - `loading` shows a spinner, disables pointer interaction, and marks the control as busy.
 * - `icon`/`iconRight` render leading and trailing affordances while preserving accessible labels.
 * - `fullWidth` stretches the button to the available width while retaining variant styling.
 */
export type ButtonProps = Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, "type"> &
  VariantProps<typeof button> & {
    /** Visually replaces the content with a spinner and prevents user interaction. */
    loading?: boolean
    /** Optional leading icon, rendered before the children. */
    icon?: React.ReactNode
    /** Optional trailing icon, rendered after the children. */
    iconRight?: React.ReactNode
    /** Render the button as a different element while preserving styling. */
    asChild?: boolean
    /** Override the intrinsic button type (defaults to `button`). */
    type?: "button" | "submit" | "reset"
  }

const Spinner = ({ className }: { className?: string }) => (
  <svg
    aria-hidden="true"
    className={cn("size-4 animate-spin text-current", className)}
    viewBox="0 0 24 24"
    fill="none"
  >
    <circle
      className="opacity-25"
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    />
    <path
      className="opacity-75"
      d="M4 12a8 8 0 018-8V2a10 10 0 100 20v-2a8 8 0 01-8-8z"
      fill="currentColor"
    />
  </svg>
)

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      asChild = false,
      className,
      variant,
      tone,
      size,
      fullWidth,
      loading = false,
      icon,
      iconRight,
      disabled,
      type = "button",
      children,
      ...props
    },
    ref
  ) => {
    const isDisabled = disabled || loading
    const buttonClassName = cn(
      button({ variant, tone, size, fullWidth }),
      loading && "cursor-progress",
      className
    )

    const childContent =
      asChild && React.isValidElement(children)
        ? (children.props as { children?: React.ReactNode }).children
        : children

    const content = (
      <>
        {loading ? (
          <Spinner className="mr-2" />
        ) : icon ? (
          <span className="-ml-0.5 mr-2 flex shrink-0 items-center">{icon}</span>
        ) : null}
        <span className="inline-flex min-w-0 items-center justify-center">{childContent}</span>
        {iconRight && !loading ? (
          <span className="ml-2 -mr-0.5 flex shrink-0 items-center">{iconRight}</span>
        ) : null}
      </>
    )

    const { onClick, ...restProps } = props

    if (asChild && React.isValidElement(children)) {
      const child = children as React.ReactElement
      const childOnClick = child.props?.onClick as React.MouseEventHandler<unknown> | undefined
      const childRef = (child as React.ReactElement & { ref?: React.Ref<unknown> }).ref

      return React.cloneElement(child, {
        ...restProps,
        className: cn(buttonClassName, child.props.className),
        "data-variant": variant ?? "solid",
        "data-tone": tone ?? "accent",
        "data-loading": loading ? "true" : undefined,
        "data-disabled": isDisabled ? "true" : undefined,
        "aria-disabled": isDisabled || undefined,
        "aria-busy": loading || undefined,
        ref: mergeRefs(childRef as React.Ref<unknown>, ref as React.Ref<unknown>),
        onClick: (event: React.MouseEvent<unknown>) => {
          if (isDisabled) {
            event.preventDefault()
            event.stopPropagation()
            return
          }
          childOnClick?.(event)
          ;(onClick as React.MouseEventHandler<unknown> | undefined)?.(event)
        },
        children: content,
      })
    }

    return (
      <button
        ref={ref}
        type={type}
        data-variant={variant ?? "solid"}
        data-tone={tone ?? "accent"}
        data-loading={loading ? "true" : undefined}
        data-disabled={isDisabled ? "true" : undefined}
        aria-disabled={isDisabled || undefined}
        aria-busy={loading || undefined}
        disabled={isDisabled}
        className={buttonClassName}
        onClick={(event) => {
          if (isDisabled) {
            event.preventDefault()
            event.stopPropagation()
            return
          }
          ;(onClick as React.MouseEventHandler<HTMLButtonElement> | undefined)?.(event)
        }}
        {...restProps}
      >
        {content}
      </button>
    )
  }
)

Button.displayName = "Button"

export { button as buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const cardVariants = cva(
  "relative flex flex-col rounded-xl border border-border/60 bg-card text-card-foreground shadow-sm transition-all duration-200",
  {
    variants: {
      variant: {
        default:
          "hover:-translate-y-0.5 hover:shadow-lg",
        elevated:
          "rounded-2xl border-border/40 shadow-lg hover:-translate-y-1 hover:shadow-xl",
        glass:
          "rounded-2xl border-white/30 bg-white/20 backdrop-blur-sm hover:-translate-y-0.5 hover:shadow-md",
      },
      size: {
        sm: "",
        md: "",
        lg: "",
      },
      compact: {
        false: "",
        true: "",
      },
      inset: {
        none: "",
        content: "",
        all: "",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      compact: false,
      inset: "none",
    },
  }
)

type CardSize = NonNullable<VariantProps<typeof cardVariants>["size"]>
type CardInset = NonNullable<VariantProps<typeof cardVariants>["inset"]>

type CardContextValue = {
  size: CardSize
  compact: boolean
  inset: CardInset
}

const defaultContext: CardContextValue = {
  size: "md",
  compact: false,
  inset: "none",
}

const CardContext = React.createContext<CardContextValue>(defaultContext)

function useCardContext() {
  return React.useContext(CardContext)
}

const horizontalPadding: Record<CardSize, string> = {
  sm: "px-3",           // 12px
  md: "px-4 md:px-6",   // 16px mobile, 24px desktop
  lg: "px-6",           // 24px
}

const verticalPadding: Record<CardSize, string> = {
  sm: "py-3",           // 12px
  md: "py-4 md:py-6",   // 16px mobile, 24px desktop
  lg: "py-6",           // 24px
}

const compactVerticalPadding: Record<CardSize, string> = {
  sm: "py-3",           // 12px
  md: "py-3",           // 12px
  lg: "py-4",           // 16px
}

const gapSpacing: Record<CardSize, string> = {
  sm: "gap-2",          // 8px
  md: "gap-3",          // 12px
  lg: "gap-4",          // 16px
}

const compactGapSpacing: Record<CardSize, string> = {
  sm: "gap-2",
  md: "gap-2",
  lg: "gap-3",
}

const sectionGapSpacing: Record<CardSize, string> = {
  sm: "gap-2",
  md: "gap-3",
  lg: "gap-4",
}

const footerPaddingTop: Record<CardSize, { regular: string; compact: string }> = {
  sm: { regular: "pt-3", compact: "pt-3" },
  md: { regular: "pt-4", compact: "pt-3" },
  lg: { regular: "pt-6", compact: "pt-4" },
}

const actionGapSpacing: Record<CardSize, string> = {
  sm: "gap-2",
  md: "gap-3",
  lg: "gap-4",
}

const horizontalInsetSpacing: Record<CardSize, { negative: string; padding: string }> = {
  sm: { negative: "-mx-3", padding: "px-3" },
  md: { negative: "-mx-4", padding: "px-4" },
  lg: { negative: "-mx-6", padding: "px-6" },
}

const disallowedSpacingPattern = /\b(p[trblxy]?|px|py|gap|space-[xy])(-|\[)/

export type CardProps = React.ComponentPropsWithoutRef<"div"> &
  VariantProps<typeof cardVariants> & {
    allowInternalSpacingOverride?: boolean
  }

const Card = React.forwardRef<HTMLDivElement, CardProps>(function Card(
  {
    className,
    variant,
    size: sizeProp = "md",
    compact: compactProp = false,
    inset: insetProp = "none",
    allowInternalSpacingOverride = false,
    ...props
  },
  ref
) {
  const size = sizeProp as CardSize
  const compact = Boolean(compactProp)
  const inset = insetProp as CardInset

  if (!allowInternalSpacingOverride && typeof className === "string" && disallowedSpacingPattern.test(className)) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(
        "[Card]: Avoid applying padding or gap utilities via className. Use size/compact props or explicitly set allowInternalSpacingOverride."
      )
    }
  }

  const spacingClasses = cn(
    horizontalPadding[size],
    compact ? compactVerticalPadding[size] : verticalPadding[size],
    compact ? compactGapSpacing[size] : gapSpacing[size]
  )

  const contextValue = React.useMemo<CardContextValue>(
    () => ({ size, compact, inset }),
    [size, compact, inset]
  )

  return (
    <CardContext.Provider value={contextValue}>
      <div
        ref={ref}
        data-slot="card"
        data-card-size={size}
        data-card-compact={compact ? "true" : undefined}
        data-card-inset={inset}
        className={cn(cardVariants({ variant, size, compact, inset }), spacingClasses, className)}
        {...props}
      />
    </CardContext.Provider>
  )
})

const CardHeader = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardHeader({ className, ...props }, ref) {
    const { size, compact, inset } = useCardContext()
    const insetClasses =
      inset === "all"
        ? [horizontalInsetSpacing[size].negative, horizontalInsetSpacing[size].padding]
        : []
    const headerGap = compact ? compactGapSpacing[size] : sectionGapSpacing[size]

    return (
      <div
        ref={ref}
        data-slot="card-header"
        className={cn(
          "flex flex-col",
          headerGap,
          insetClasses,
          className
        )}
        {...props}
      />
    )
  }
)

const CardTitle = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardTitle({ className, ...props }, ref) {
    return (
      <div
        ref={ref}
        data-slot="card-title"
        className={cn("text-lg font-semibold leading-tight text-foreground", className)}
        {...props}
      />
    )
  }
)

const CardDescription = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardDescription({ className, ...props }, ref) {
    return (
      <div
        ref={ref}
        data-slot="card-description"
        className={cn("text-sm text-muted-foreground", className)}
        {...props}
      />
    )
  }
)

const CardAction = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardAction({ className, ...props }, ref) {
    const { size, compact } = useCardContext()
    const gap = compact ? compactGapSpacing[size] : actionGapSpacing[size]
    return (
      <div
        ref={ref}
        data-slot="card-action"
        className={cn("flex items-center justify-end", gap, className)}
        {...props}
      />
    )
  }
)

const CardContent = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardContent({ className, ...props }, ref) {
    const { size, compact, inset } = useCardContext()
    const insetClasses =
      inset === "content" || inset === "all"
        ? [horizontalInsetSpacing[size].negative, horizontalInsetSpacing[size].padding]
        : []

    return (
      <div
        ref={ref}
        data-slot="card-content"
        className={cn(
          "flex flex-1 flex-col",
          compact ? compactGapSpacing[size] : gapSpacing[size],
          insetClasses,
          className
        )}
        {...props}
      />
    )
  }
)

const CardFooter = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardFooter({ className, ...props }, ref) {
    const { size, compact, inset } = useCardContext()
    const insetClasses =
      inset === "all"
        ? [horizontalInsetSpacing[size].negative, horizontalInsetSpacing[size].padding]
        : []

    const paddingTop = compact ? footerPaddingTop[size].compact : footerPaddingTop[size].regular
    const footerGap = compact ? compactGapSpacing[size] : actionGapSpacing[size]

    return (
      <div
        ref={ref}
        data-slot="card-footer"
        className={cn(
          "flex items-center justify-between border-t border-border/60",
          paddingTop,
          insetClasses,
          footerGap,
          className
        )}
        {...props}
      />
    )
  }
)

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
  cardVariants,
}
</file>

<file path="components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="components/ui/dialog.tsx">
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="components/ui/empty-state.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"

import {
  emptyStateActions,
  emptyStateDescription,
  emptyStateIcon,
  emptyStateRoot,
  emptyStateTitle,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"
import { Button } from "./button"

type EmptyStateRootVariants = VariantProps<typeof emptyStateRoot>

type EmptyStateTone = NonNullable<EmptyStateRootVariants["tone"]>
type EmptyStateSize = NonNullable<EmptyStateRootVariants["size"]>
type EmptyStateAlignment = NonNullable<EmptyStateRootVariants["alignment"]>

type ButtonTone = NonNullable<React.ComponentProps<typeof Button>["tone"]>

export interface EmptyStateAction {
  label: string
  onClick?: () => void
  href?: string
}

export interface EmptyStateProps
  extends React.HTMLAttributes<HTMLDivElement>,
    EmptyStateRootVariants {
  title: string
  icon?: React.ReactNode
  iconAriaLabel?: string
  statusLabel?: string
  description?: React.ReactNode
  primaryAction?: EmptyStateAction
  secondaryAction?: EmptyStateAction
}

const toneToButtonTone: Record<EmptyStateTone, ButtonTone> = {
  neutral: "accent",
  info: "accent",
  success: "success",
  warning: "warn",
  danger: "danger",
}

const toneLabelMap: Record<EmptyStateTone, string> = {
  neutral: "Heads up",
  info: "Informational",
  success: "Success",
  warning: "Warning",
  danger: "Critical",
}

const toneLabelClassMap: Record<EmptyStateTone, string> = {
  neutral: "text-muted-foreground",
  info: "text-info",
  success: "text-success",
  warning: "text-warning",
  danger: "text-destructive",
}

export const EmptyState = React.forwardRef<HTMLDivElement, EmptyStateProps>(
  (
    {
      icon,
      iconAriaLabel,
      statusLabel,
      title,
      description,
      primaryAction,
      secondaryAction,
      tone = "neutral",
      size = "md",
      alignment = "center",
      elevated,
      className,
      ...props
    },
    ref
  ) => {
    const resolvedTone: EmptyStateTone = tone ?? "neutral"
    const resolvedSize: EmptyStateSize = size ?? "md"
    const resolvedAlignment: EmptyStateAlignment = alignment ?? "center"

    const resolvedStatusLabel = statusLabel ?? toneLabelMap[resolvedTone]
    const role = resolvedTone === "danger" || resolvedTone === "warning" ? "alert" : "status"
    const ariaLive = role === "alert" ? "assertive" : "polite"

    const descriptionContent = React.useMemo(() => {
      if (!description) return null

      if (typeof description === "string") {
        return (
          <p
            className={cn(
              emptyStateDescription({ size: resolvedSize, alignment: resolvedAlignment })
            )}
          >
            {description}
          </p>
        )
      }

      if (React.isValidElement(description)) {
        const element = description as React.ReactElement<{ className?: string }>
        return React.cloneElement(element, {
          className: cn(
            emptyStateDescription({ size: resolvedSize, alignment: resolvedAlignment }),
            element.props.className
          ),
        })
      }

      return (
        <div
          className={cn(
            emptyStateDescription({ size: resolvedSize, alignment: resolvedAlignment })
          )}
        >
          {description}
        </div>
      )
    }, [description, resolvedAlignment, resolvedSize])

    const renderAction = (
      action: EmptyStateAction,
      variant: "primary" | "secondary"
    ) => {
      if (!action) return null
      const buttonTone = toneToButtonTone[resolvedTone]
      const variantConfig =
        variant === "primary"
          ? { variant: "solid" as const, tone: buttonTone }
          : { variant: "ghost" as const, tone: "neutral" as ButtonTone }

      if (action.href) {
        return (
          <Button asChild variant={variantConfig.variant} tone={variantConfig.tone}>
            <a href={action.href} onClick={action.onClick}>
              {action.label}
            </a>
          </Button>
        )
      }

      return (
        <Button
          variant={variantConfig.variant}
          tone={variantConfig.tone}
          onClick={action.onClick}
        >
          {action.label}
        </Button>
      )
    }

    return (
      <div
        ref={ref}
        role={role}
        aria-live={ariaLive}
        className={cn(
          emptyStateRoot({
            tone: resolvedTone,
            size: resolvedSize,
            alignment: resolvedAlignment,
            elevated: elevated ? true : undefined,
          }),
          className
        )}
        {...props}
      >
        {icon ? (
          <span
            className={cn(emptyStateIcon({ tone: resolvedTone, size: resolvedSize }))}
            role={iconAriaLabel ? "img" : undefined}
            aria-label={iconAriaLabel}
            aria-hidden={iconAriaLabel ? undefined : "true"}
          >
            {icon}
          </span>
        ) : null}

        <span
          className={cn(
            "text-xs font-semibold uppercase tracking-wide",
            toneLabelClassMap[resolvedTone]
          )}
        >
          {resolvedStatusLabel}
        </span>

        <h2 className={cn(emptyStateTitle({ size: resolvedSize }))}>{title}</h2>
        {descriptionContent}

        {(primaryAction || secondaryAction) && (
          <div className={cn(emptyStateActions({ alignment: resolvedAlignment }))}>
            {secondaryAction ? renderAction(secondaryAction, "secondary") : null}
            {primaryAction ? renderAction(primaryAction, "primary") : null}
          </div>
        )}
      </div>
    )
  }
)

EmptyState.displayName = "EmptyState"
</file>

<file path="components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex w-full min-w-0 rounded-md border bg-transparent px-3 py-2.5 text-base leading-6 shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:items-center file:justify-center file:border-0 file:bg-transparent file:px-3 file:py-2.5 file:text-base file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm md:leading-5 min-h-[44px]",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="components/ui/page-header.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"

import {
  pageHeaderActions,
  pageHeaderBreadcrumbs,
  pageHeaderDescription,
  pageHeaderInner,
  pageHeaderRoot,
  pageHeaderText,
  pageHeaderTitle,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"

export type PageHeaderBreadcrumb = {
  label: string
  href?: string
}

type PageHeaderRootVariants = VariantProps<typeof pageHeaderRoot>
type PageHeaderInnerVariants = VariantProps<typeof pageHeaderInner>

type HeadingTag = "h1" | "h2" | "h3" | "h4" | "h5" | "h6"

export interface PageHeaderProps
  extends Omit<React.HTMLAttributes<HTMLElement>, "title">,
    PageHeaderRootVariants,
    Pick<PageHeaderInnerVariants, "align"> {
  title: string | React.ReactNode
  description?: React.ReactNode
  breadcrumbs?: PageHeaderBreadcrumb[]
  actions?: React.ReactNode
  headingLevel?: HeadingTag
}

export const PageHeader = React.forwardRef<HTMLElement, PageHeaderProps>(
  (
    {
      title,
      description,
      breadcrumbs,
      actions,
      tone,
      density,
      align = "left",
      headingLevel = "h1",
      className,
      ...props
    },
    ref
  ) => {
    const headingId = React.useId()

    const Heading = headingLevel as React.ElementType

    const descriptionContent = React.useMemo(() => {
      if (!description) return null

      if (typeof description === "string") {
        return (
          <p className={cn(pageHeaderDescription({ density }))}>{description}</p>
        )
      }

      if (React.isValidElement(description)) {
        const element = description as React.ReactElement<{ className?: string }>;
        return React.cloneElement(element, {
          className: cn(pageHeaderDescription({ density }), element.props.className),
        })
      }

      return (
        <div className={cn(pageHeaderDescription({ density }))}>{description}</div>
      )
    }, [description, density])

    return (
      <header
        ref={ref}
        aria-labelledby={headingId}
        className={cn(pageHeaderRoot({ tone, density }), className)}
        data-align={align}
        {...props}
      >
        <div className={cn(pageHeaderInner({ density, align }))}>
          <div className={cn(pageHeaderText({ density, align }), "w-full")}>
            {breadcrumbs && breadcrumbs.length > 0 ? (
              <nav aria-label="Breadcrumb" className="w-full">
                <ol className={cn(pageHeaderBreadcrumbs({ density }))}>
                  {breadcrumbs.map((breadcrumb, index) => {
                    const isLast = index === breadcrumbs.length - 1

                    return (
                      <li
                        key={`${breadcrumb.label}-${index}`}
                        aria-current={isLast ? "page" : undefined}
                        className="flex items-center gap-2"
                      >
                        {breadcrumb.href && !isLast ? (
                          <a
                            href={breadcrumb.href}
                            className="rounded-md px-1 py-0.5 text-sm text-muted-foreground transition-colors hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                          >
                            {breadcrumb.label}
                          </a>
                        ) : (
                          <span
                            className={cn(
                              "rounded-md px-1 py-0.5",
                              isLast ? "text-foreground" : "text-muted-foreground"
                            )}
                          >
                            {breadcrumb.label}
                          </span>
                        )}
                        {!isLast ? (
                          <span aria-hidden="true" className="text-muted-foreground/70">
                            /
                          </span>
                        ) : null}
                      </li>
                    )
                  })}
                </ol>
              </nav>
            ) : null}

            <div className="flex flex-col gap-3">
              <Heading
                id={headingId}
                className={cn(pageHeaderTitle({ density }))}
              >
                {title}
              </Heading>
              {descriptionContent}
            </div>
          </div>

          {actions ? (
            <div
              className={cn(
                pageHeaderActions({ density }),
                align === "between" ? "md:justify-end" : "md:justify-start",
                "w-full md:w-auto"
              )}
            >
              {actions}
            </div>
          ) : null}
        </div>
      </header>
    )
  }
)

PageHeader.displayName = "PageHeader"
</file>

<file path="components/ui/progress.tsx">
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="components/ui/table.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"
import { ArrowUpDown, ChevronDown, ChevronUp } from "lucide-react"

import {
  tableCell,
  tableContainer,
  tableHeaderCell,
  tableHeaderRow,
  tableRoot,
  tableRow,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"
import { EmptyState } from "./empty-state"

type TableContainerVariants = VariantProps<typeof tableContainer>

type DensityVariant = NonNullable<TableContainerVariants["density"]>

export type SortDirection = "asc" | "desc"

export interface TableColumn<TData> {
  id: string
  header: React.ReactNode
  accessor?: (row: TData) => React.ReactNode
  align?: "left" | "center" | "right"
  width?: string
  sortable?: boolean
}

export interface TableProps<TData>
  extends React.HTMLAttributes<HTMLDivElement>,
    TableContainerVariants {
  columns: TableColumn<TData>[]
  data: TData[]
  caption?: string
  captionClassName?: string
  tableProps?: React.TableHTMLAttributes<HTMLTableElement>
  isLoading?: boolean
  emptyState?: React.ReactNode
  onSortChange?: (columnId: string, direction: SortDirection | null) => void
  sort?: { id: string; dir: SortDirection }
  stickyHeader?: boolean
  getRowId?: (row: TData, index: number) => string
}

const LoadingIndicator = ({ density }: { density: DensityVariant }) => (
  <div className="flex items-center justify-center gap-3 text-sm text-muted-foreground">
    <span
      aria-hidden="true"
      className={cn(
        "size-4 animate-spin rounded-full border-2 border-border/80 border-t-transparent",
        density === "compact" ? "size-3" : "size-4"
      )}
    />
    <span>Loading</span>
  </div>
)

export const Table = <TData,>(
  {
    columns,
    data,
    caption,
    captionClassName,
    tableProps,
    isLoading,
    emptyState,
    onSortChange,
    sort,
    density = "comfortable",
    zebra,
    stickyHeader,
    getRowId,
    className,
    ...rest
  }: TableProps<TData>
) => {
  const colSpan = Math.max(columns.length, 1)
  const resolvedDensity: DensityVariant = density ?? "comfortable"

  const renderCellContent = React.useCallback(
    (row: TData, column: TableColumn<TData>) => {
      if (column.accessor) {
        return column.accessor(row)
      }

      const value = (row as Record<string, unknown>)[column.id]
      if (React.isValidElement(value)) {
        return value
      }

      if (typeof value === "string" || typeof value === "number") {
        return value
      }

      if (value === null || value === undefined) {
        return "â€”"
      }

      return String(value)
    },
    []
  )

  const getSortState = (columnId: string): SortDirection | null => {
    if (!sort || sort.id !== columnId) return null
    return sort.dir
  }

  const handleSort = (column: TableColumn<TData>) => {
    if (!onSortChange || !column.sortable) return

    const current = getSortState(column.id)
    const next: SortDirection | null = current === "asc" ? "desc" : current === "desc" ? null : "asc"
    onSortChange(column.id, next)
  }

  const defaultEmpty = (
    <EmptyState
      tone="neutral"
      alignment="center"
      size={resolvedDensity === "compact" ? "sm" : "md"}
      title="No data yet"
      description="Once data is available it will appear here."
    />
  )

  return (
    <div
      className={cn(tableContainer({ density: resolvedDensity, zebra }), className)}
      {...rest}
    >
      <div className="relative w-full overflow-x-auto">
        <table
          className={cn(tableRoot({ density: resolvedDensity }))}
          aria-busy={isLoading || undefined}
          {...tableProps}
        >
          {caption ? (
            <caption className={cn("sr-only", captionClassName)}>{caption}</caption>
          ) : null}
          <thead>
            <tr className={cn(tableHeaderRow({ sticky: stickyHeader ? true : undefined }))}>
              {columns.map((column) => {
                const sortState = getSortState(column.id)
                const isSortable = Boolean(onSortChange && column.sortable)
                const ariaSort: React.AriaAttributes["aria-sort"] = sortState
                  ? sortState === "asc"
                    ? "ascending"
                    : "descending"
                  : "none"
                const textAlignment =
                  column.align === "right"
                    ? "text-right"
                    : column.align === "center"
                    ? "text-center"
                    : "text-left"
                const justifyAlignment =
                  column.align === "right"
                    ? "justify-end"
                    : column.align === "center"
                    ? "justify-center"
                    : "justify-between"

                return (
                  <th
                    key={column.id}
                    scope="col"
                    aria-sort={isSortable ? ariaSort : undefined}
                    className={cn(
                      tableHeaderCell({ density: resolvedDensity, align: column.align }),
                      "align-middle"
                    )}
                    style={column.width ? { width: column.width } : undefined}
                  >
                    {isSortable ? (
                      <button
                        type="button"
                        onClick={() => handleSort(column)}
                        className={cn(
                          "flex w-full items-center gap-2 rounded-md px-1 py-1 transition-colors hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-background",
                          textAlignment,
                          justifyAlignment
                        )}
                      >
                        <span className="truncate">{column.header}</span>
                        <span className="flex items-center text-muted-foreground" aria-hidden="true">
                          {sortState === "asc" ? (
                            <ChevronUp className="size-4" />
                          ) : sortState === "desc" ? (
                            <ChevronDown className="size-4" />
                          ) : (
                            <ArrowUpDown className="size-4" />
                          )}
                        </span>
                        <span className="sr-only">
                          {sortState === "asc"
                            ? "Sort descending"
                            : sortState === "desc"
                            ? "Clear sorting"
                            : "Sort ascending"}
                        </span>
                      </button>
                    ) : (
                      <span className={cn("block truncate", textAlignment)}>{column.header}</span>
                    )}
                  </th>
                )
              })}
            </tr>
          </thead>
          <tbody>
            {isLoading ? (
              <tr className={cn(tableRow({ density: resolvedDensity }))}>
                <td
                  colSpan={colSpan}
                  className={cn(
                    tableCell({ density: resolvedDensity, align: "center" }),
                    "py-10"
                  )}
                  aria-live="polite"
                >
                  <LoadingIndicator density={resolvedDensity} />
                </td>
              </tr>
            ) : data.length === 0 ? (
              <tr className={cn(tableRow({ density: resolvedDensity }))}>
                <td
                  colSpan={colSpan}
                  className={cn(
                    tableCell({ density: resolvedDensity, align: "center" }),
                    "py-12"
                  )}
                >
                  {emptyState ?? defaultEmpty}
                </td>
              </tr>
            ) : (
              data.map((row, rowIndex) => {
                const rowKey = getRowId ? getRowId(row, rowIndex) : `${rowIndex}`
                return (
                  <tr key={rowKey} className={cn(tableRow({ density: resolvedDensity }))}>
                    {columns.map((column) => (
                      <td
                        key={`${rowKey}-${column.id}`}
                        className={cn(
                          tableCell({ density: resolvedDensity, align: column.align })
                        )}
                        style={column.width ? { width: column.width } : undefined}
                      >
                        <div className="min-w-0 truncate">
                          {renderCellContent(row, column)}
                        </div>
                      </td>
                    ))}
                  </tr>
                )
              })
            )}
          </tbody>
        </table>
      </div>
    </div>
  )
}

Table.displayName = "Table"
</file>

<file path="components/ui/theme-toggle.tsx">
"use client";

import * as React from "react";
import { Monitor, MoonStar, SunMedium } from "lucide-react";
import { useTheme } from "next-themes";

const LABEL = "Toggle dark mode";

export function ThemeToggle() {
  const { theme, setTheme, resolvedTheme } = useTheme();
  const [isMounted, setIsMounted] = React.useState(false);

  React.useEffect(() => {
    setIsMounted(true);
  }, []);

  const currentTheme = theme === "system" ? resolvedTheme : theme;

  function getNextTheme() {
    if (!isMounted) {
      return "system";
    }

    if (theme === "system") {
      return resolvedTheme === "dark" ? "light" : "dark";
    }

    return currentTheme === "dark" ? "light" : "dark";
  }

  function handleToggle() {
    const next = getNextTheme();
    setTheme(next ?? "system");
  }

  const icon = !isMounted
    ? <Monitor className="h-5 w-5" aria-hidden="true" />
    : currentTheme === "dark"
      ? <MoonStar className="h-5 w-5" aria-hidden="true" />
      : <SunMedium className="h-5 w-5" aria-hidden="true" />;

  const isDark = isMounted ? currentTheme === "dark" : false;

  return (
    <button
      type="button"
      onClick={handleToggle}
      aria-pressed={isDark}
      title={`${LABEL} (current: ${currentTheme ?? "system"})`}
      className="inline-flex h-11 w-11 items-center justify-center rounded-full border border-border bg-transparent text-foreground transition-colors hover:bg-muted focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
    >
      <span className="sr-only">{LABEL}</span>
      {icon}
    </button>
  );
}
</file>

<file path="components/ui/toast.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import {
  toastActions,
  toastDescription,
  toastRoot,
  toastTitle,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"
import { Button } from "./button"

type ToastRootVariants = VariantProps<typeof toastRoot>

type ToastTone = NonNullable<ToastRootVariants["tone"]>
type ToastElevation = NonNullable<ToastRootVariants["elevation"]>

type ButtonTone = NonNullable<React.ComponentProps<typeof Button>["tone"]>

export interface ToastAction {
  label: string
  onClick: () => void
}

export interface ToastProps
  extends React.HTMLAttributes<HTMLDivElement>,
    ToastRootVariants {
  title?: string
  description?: React.ReactNode
  action?: ToastAction
  dismissible?: boolean
  onClose?: () => void
}

const toneToButtonTone: Record<ToastTone, ButtonTone> = {
  info: "accent",
  success: "success",
  warning: "warn",
  danger: "danger",
}

export const Toast = React.forwardRef<HTMLDivElement, ToastProps>(
  (
    {
      title,
      description,
      action,
      dismissible = true,
      onClose,
      tone = "info",
      elevation = "sm",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const resolvedTone: ToastTone = tone ?? "info"
    const resolvedElevation: ToastElevation = elevation ?? "sm"
    const isDismissible = dismissible ?? true
    const role =
      resolvedTone === "danger" || resolvedTone === "warning" ? "alert" : "status"
    const ariaLive = role === "alert" ? "assertive" : "polite"
    const buttonTone = toneToButtonTone[resolvedTone]

    const descriptionContent = React.useMemo(() => {
      if (!description) return null

      if (typeof description === "string") {
        return <p className={cn(toastDescription({ tone: resolvedTone }))}>{description}</p>
      }

      if (React.isValidElement(description)) {
        const element = description as React.ReactElement<{ className?: string }>
        return React.cloneElement(element, {
          className: cn(
            toastDescription({ tone: resolvedTone }),
            element.props.className
          ),
        })
      }

      return (
        <div className={cn(toastDescription({ tone: resolvedTone }))}>{description}</div>
      )
    }, [description, resolvedTone])

    return (
      <div
        ref={ref}
        role={role}
        aria-live={ariaLive}
        className={cn(
          toastRoot({
            tone: resolvedTone,
            elevation: resolvedElevation,
            dismissible: isDismissible && onClose ? true : undefined,
          }),
          className
        )}
        {...props}
      >
        {title ? <p className={cn(toastTitle({ tone: resolvedTone }))}>{title}</p> : null}
        {descriptionContent}
        {children}
        {(action || (isDismissible && onClose)) && (
          <div
            className={cn(
              toastActions({ dismissible: isDismissible && onClose ? true : undefined })
            )}
          >
            {action ? (
              <Button variant="link" tone={buttonTone} onClick={action.onClick} className="px-0">
                {action.label}
              </Button>
            ) : null}
            {isDismissible && onClose ? (
              <button
                type="button"
                onClick={onClose}
                className="inline-flex size-8 items-center justify-center rounded-full text-muted-foreground transition-colors hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-background"
              >
                <span className="sr-only">Dismiss notification</span>
                <X aria-hidden="true" className="size-4" />
              </button>
            ) : null}
          </div>
        )}
      </div>
    )
  }
)

Toast.displayName = "Toast"

let toastId = 0

export type ToastQueueItem = ToastProps & { id?: string }
export type ToastQueueEntry = ToastProps & { id: string }

export const useToastQueue = (initialToasts: ToastQueueItem[] = []) => {
  const toEntry = React.useCallback((toast: ToastQueueItem): ToastQueueEntry => ({
    ...toast,
    id: toast.id ?? `toast-${++toastId}`,
  }), [])

  const [toasts, setToasts] = React.useState<ToastQueueEntry[]>(() =>
    initialToasts.map((toast) => toEntry(toast))
  )

  const addToast = React.useCallback((toast: ToastQueueItem) => {
    setToasts((previous) => [...previous, toEntry(toast)])
  }, [toEntry])

  const dismissToast = React.useCallback((id: string) => {
    setToasts((previous) => previous.filter((toast) => toast.id !== id))
  }, [])

  return { toasts, addToast, dismissToast }
}
</file>

<file path="lib/analytics/hooks/useSessionTracking.ts">
"use client";

import { useEffect, useRef, useCallback } from "react";
import { usePathname } from "next/navigation";
import { usePostHog } from "posthog-js/react";
import { trackEvent, trackEngagement, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";

interface SessionMetrics {
  sessionStartTime: number;
  pageStartTime: number;
  totalPageViews: number;
  totalScrollDepth: number;
  maxScrollDepth: number;
  idleTime: number;
  lastActivityTime: number;
}

const SESSION_STORAGE_KEY = "testero_session_metrics";
const IDLE_THRESHOLD = 30000; // 30 seconds of inactivity = idle
const SCROLL_DEBOUNCE = 500; // Debounce scroll tracking

export function useSessionTracking(userId?: string) {
  const posthog = usePostHog();
  const pathname = usePathname();
  const metricsRef = useRef<SessionMetrics | null>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const idleTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastPathRef = useRef<string>("");

  // Initialize or retrieve session metrics
  const initializeMetrics = useCallback(() => {
    const stored = sessionStorage.getItem(SESSION_STORAGE_KEY);
    const now = Date.now();

    if (stored) {
      const parsed = JSON.parse(stored) as SessionMetrics;
      // Check if session is still valid (less than 30 min old)
      if (now - parsed.sessionStartTime < 30 * 60 * 1000) {
        metricsRef.current = {
          ...parsed,
          pageStartTime: now,
          totalPageViews: parsed.totalPageViews + 1,
          maxScrollDepth: 0,
        };
      } else {
        // Start new session
        metricsRef.current = {
          sessionStartTime: now,
          pageStartTime: now,
          totalPageViews: 1,
          totalScrollDepth: 0,
          maxScrollDepth: 0,
          idleTime: 0,
          lastActivityTime: now,
        };
      }
    } else {
      // First visit - start new session
      metricsRef.current = {
        sessionStartTime: now,
        pageStartTime: now,
        totalPageViews: 1,
        totalScrollDepth: 0,
        maxScrollDepth: 0,
        idleTime: 0,
        lastActivityTime: now,
      };
    }

    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(metricsRef.current));
  }, []);

  // Track scroll depth
  const trackScrollDepth = useCallback(() => {
    if (!metricsRef.current) return;

    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    const scrollTop = window.scrollY;
    const scrollPercentage = Math.round((scrollTop / (documentHeight - windowHeight)) * 100);

    if (scrollPercentage > metricsRef.current.maxScrollDepth) {
      metricsRef.current.maxScrollDepth = scrollPercentage;
      metricsRef.current.totalScrollDepth += scrollPercentage - metricsRef.current.maxScrollDepth;

      // Track milestone scroll depths
      if (scrollPercentage >= 25 && metricsRef.current.maxScrollDepth < 25) {
        trackEngagement(posthog, "page_depth", 25, { page: pathname }, userId);
      } else if (scrollPercentage >= 50 && metricsRef.current.maxScrollDepth < 50) {
        trackEngagement(posthog, "page_depth", 50, { page: pathname }, userId);
      } else if (scrollPercentage >= 75 && metricsRef.current.maxScrollDepth < 75) {
        trackEngagement(posthog, "page_depth", 75, { page: pathname }, userId);
      } else if (scrollPercentage >= 90 && metricsRef.current.maxScrollDepth < 90) {
        trackEngagement(posthog, "page_depth", 90, { page: pathname }, userId);
      }
    }

    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(metricsRef.current));
  }, [pathname, posthog, userId]);

  // Handle scroll with debouncing
  const handleScroll = useCallback(() => {
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }

    scrollTimeoutRef.current = setTimeout(() => {
      trackScrollDepth();
    }, SCROLL_DEBOUNCE);
  }, [trackScrollDepth]);

  // Track user activity for idle detection
  const trackActivity = useCallback(() => {
    if (!metricsRef.current) return;

    const now = Date.now();
    const timeSinceLastActivity = now - metricsRef.current.lastActivityTime;

    if (timeSinceLastActivity > IDLE_THRESHOLD) {
      metricsRef.current.idleTime += timeSinceLastActivity;
    }

    metricsRef.current.lastActivityTime = now;
    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(metricsRef.current));

    // Reset idle timer
    if (idleTimeoutRef.current) {
      clearTimeout(idleTimeoutRef.current);
    }

    idleTimeoutRef.current = setTimeout(() => {
      // User has been idle
      if (metricsRef.current) {
        metricsRef.current.idleTime += IDLE_THRESHOLD;
        trackEngagement(
          posthog,
          "session_duration",
          metricsRef.current.idleTime,
          {
            type: "idle_detected",
            page: pathname,
          },
          userId
        );
      }
    }, IDLE_THRESHOLD);
  }, [pathname, posthog, userId]);

  // Track page exit and session duration
  const trackPageExit = useCallback(() => {
    if (!metricsRef.current || !lastPathRef.current) return;

    const now = Date.now();
    const pageTime = now - metricsRef.current.pageStartTime;
    const sessionTime = now - metricsRef.current.sessionStartTime;

    // Track page-specific metrics
    trackEngagement(
      posthog,
      "session_duration",
      pageTime,
      {
        type: "page_time",
        page: lastPathRef.current,
        scroll_depth: metricsRef.current.maxScrollDepth,
      },
      userId
    );

    // Track session metrics every page change
    trackEngagement(
      posthog,
      "session_duration",
      sessionTime - metricsRef.current.idleTime,
      {
        type: "active_session_time",
        total_pages: metricsRef.current.totalPageViews,
        avg_scroll_depth: Math.round(
          metricsRef.current.totalScrollDepth / metricsRef.current.totalPageViews
        ),
      },
      userId
    );

    // Check for bounce (single page session with quick exit)
    if (metricsRef.current.totalPageViews === 1 && pageTime < 10000) {
      trackEvent(
        posthog,
        ANALYTICS_EVENTS.FEATURE_DISCOVERED,
        {
          feature_name: "bounce_detected",
          discovery_type: "quick_exit",
          page: lastPathRef.current,
          time_on_page: pageTime,
        },
        userId
      );
    }
  }, [posthog, userId]);

  // Set up event listeners
  useEffect(() => {
    initializeMetrics();

    // Track scroll depth
    window.addEventListener("scroll", handleScroll);

    // Track user activity
    window.addEventListener("mousemove", trackActivity);
    window.addEventListener("keydown", trackActivity);
    window.addEventListener("click", trackActivity);
    window.addEventListener("touchstart", trackActivity);

    // Track page visibility changes
    const handleVisibilityChange = () => {
      if (document.hidden) {
        trackPageExit();
      } else {
        if (metricsRef.current) {
          metricsRef.current.pageStartTime = Date.now();
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Track before unload
    const handleBeforeUnload = () => {
      trackPageExit();
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("mousemove", trackActivity);
      window.removeEventListener("keydown", trackActivity);
      window.removeEventListener("click", trackActivity);
      window.removeEventListener("touchstart", trackActivity);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("beforeunload", handleBeforeUnload);

      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      if (idleTimeoutRef.current) {
        clearTimeout(idleTimeoutRef.current);
      }
    };
  }, [initializeMetrics, handleScroll, trackActivity, trackPageExit]);

  // Track page changes
  useEffect(() => {
    if (pathname !== lastPathRef.current && lastPathRef.current) {
      trackPageExit();
      initializeMetrics();
    }
    lastPathRef.current = pathname;
  }, [pathname, trackPageExit, initializeMetrics]);

  return {
    sessionMetrics: metricsRef.current,
  };
}
</file>

<file path="lib/analytics/campaign-analytics-integration.ts">
import {
  parseCampaignParams,
  storeCampaignAttribution,
  addCampaignAttributionToEvent,
  CampaignParams,
} from "./campaign-attribution";
import { trackEvent, ANALYTICS_EVENTS, PostHogClient, AnalyticsEvent } from "./analytics";

/**
 * Tracks email campaign landing with attribution
 *
 * @param posthog - PostHog client (server or client-side)
 * @param campaignParams - Campaign attribution parameters
 * @param userId - User ID for server-side tracking
 */
export function trackCampaignLanding(
  posthog: PostHogClient,
  campaignParams: CampaignParams,
  userId?: string
): void {
  if (!posthog) return;

  const eventProperties = {
    ...campaignParams,
    landing_page: typeof window !== "undefined" ? window.location.pathname : "/beta/welcome",
    timestamp: Date.now(),
  };

  trackEvent(posthog, ANALYTICS_EVENTS.EMAIL_CAMPAIGN_LANDING, eventProperties, userId);
}

/**
 * Tracks diagnostic start event enhanced with campaign attribution
 *
 * @param posthog - PostHog client
 * @param diagnosticData - Base diagnostic event data
 * @param userId - User ID for server-side tracking
 */
export function trackDiagnosticStartWithCampaign(
  posthog: PostHogClient,
  diagnosticData: Record<string, unknown>,
  userId?: string
): void {
  if (!posthog) return;

  const enhancedEvent = addCampaignAttributionToEvent(diagnosticData);
  trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_STARTED, enhancedEvent, userId);
}

/**
 * Tracks diagnostic completion event enhanced with campaign attribution
 *
 * @param posthog - PostHog client
 * @param completionData - Base diagnostic completion data
 * @param userId - User ID for server-side tracking
 */
export function trackDiagnosticCompleteWithCampaign(
  posthog: PostHogClient,
  completionData: Record<string, unknown>,
  userId?: string
): void {
  if (!posthog) return;

  const enhancedEvent = addCampaignAttributionToEvent(completionData);
  trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_COMPLETED, enhancedEvent, userId);
}

/**
 * Extracts campaign attribution from current URL and stores it
 *
 * @param posthog - Optional PostHog client to track attribution event
 * @param userId - User ID for server-side tracking
 * @returns Campaign parameters or null if none found
 */
export function setCampaignAttributionFromURL(
  posthog?: PostHogClient,
  userId?: string
): CampaignParams | null {
  if (typeof window === "undefined") return null;

  const currentUrl = window.location.href;
  const campaignParams = parseCampaignParams(currentUrl);

  // Check if any campaign parameters exist
  const hasParams = Object.values(campaignParams).some((value) => value !== undefined);

  if (!hasParams) return null;

  // Store attribution
  storeCampaignAttribution(campaignParams);

  // Track attribution event if PostHog is provided
  if (posthog) {
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.CAMPAIGN_ATTRIBUTION_SET,
      {
        ...campaignParams,
        source_url: currentUrl,
      },
      userId
    );
  }

  return campaignParams;
}

/**
 * Creates an enhanced track event function that automatically adds campaign attribution
 *
 * @param posthog - PostHog client to use
 * @returns Enhanced tracking function
 */
export function createEnhancedTrackEvent(posthog: PostHogClient) {
  return function enhancedTrackEvent(
    event: AnalyticsEvent,
    properties?: Record<string, unknown>,
    userId?: string
  ): void {
    if (!posthog) return;

    const enhancedProperties = addCampaignAttributionToEvent(properties || {});
    trackEvent(posthog, event, enhancedProperties, userId);
  };
}
</file>

<file path="lib/analytics/campaign-attribution.ts">
/**
 * Campaign attribution parameters extracted from UTM and custom parameters
 * Used for tracking beta campaign performance and A/B testing
 */
export interface CampaignParams {
  /** UTM source parameter (e.g., 'loops', 'email') */
  utm_source?: string;
  /** UTM campaign parameter (e.g., 'beta_launch_2025') */
  utm_campaign?: string;
  /** Custom campaign identifier for tracking specific campaigns */
  campaign_id?: string;
  /** A/B test variant - strictly 'A' or 'B' */
  variant?: "A" | "B";
  /** Email address for attribution (URL encoded) */
  email?: string;
}

/**
 * Supported A/B test variants for beta campaign
 */
export type CampaignVariant = "A" | "B";

/**
 * Valid UTM source values for campaign attribution
 */
export const VALID_UTM_SOURCES = ["loops", "email", "direct", "social"] as const;
export type ValidUtmSource = (typeof VALID_UTM_SOURCES)[number];

/**
 * Validates if a string is a valid campaign variant
 */
function isValidVariant(value: string | null): value is CampaignVariant {
  return value === "A" || value === "B";
}

/**
 * Safely decodes a URL parameter that might be URL encoded
 */
function safeDecodeParam(param: string | null): string | undefined {
  if (!param) return undefined;
  try {
    return decodeURIComponent(param);
  } catch {
    return param; // Return original if decode fails
  }
}

/**
 * Extracts campaign attribution parameters from a URL
 *
 * @param url - The URL to parse (can be relative or absolute)
 * @returns Campaign parameters object with undefined values for missing params
 *
 * @example
 * ```typescript
 * const params = parseCampaignParams('https://site.com/page?utm_source=loops&variant=A');
 * // Returns: { utm_source: 'loops', variant: 'A', ... }
 * ```
 */
export function parseCampaignParams(url: string): CampaignParams {
  try {
    // Handle relative URLs by providing a base URL
    const urlObj = url.startsWith("http") ? new URL(url) : new URL(url, "https://example.com");
    const params = urlObj.searchParams;

    // Extract and validate variant
    const variantParam = params.get("variant");
    const variant = isValidVariant(variantParam) ? variantParam : undefined;

    return {
      utm_source: safeDecodeParam(params.get("utm_source")),
      utm_campaign: safeDecodeParam(params.get("utm_campaign")),
      campaign_id: safeDecodeParam(params.get("campaign_id")),
      variant,
      email: safeDecodeParam(params.get("email")),
    };
  } catch (error) {
    // Invalid URL - return empty object with undefined values
    console.warn(`Failed to parse campaign parameters from URL: ${url}`, error);
    return {
      utm_source: undefined,
      utm_campaign: undefined,
      campaign_id: undefined,
      variant: undefined,
      email: undefined,
    };
  }
}

/**
 * Storage key for campaign attribution in sessionStorage
 */
const CAMPAIGN_ATTRIBUTION_KEY = "testero_campaign_attribution";

/**
 * Stores campaign attribution parameters in sessionStorage
 *
 * @param attribution - Campaign parameters to store
 * @param merge - If true, merge with existing attribution instead of replacing
 */
export function storeCampaignAttribution(attribution: CampaignParams, merge = false): void {
  if (typeof window === "undefined") return; // SSR safety

  try {
    let dataToStore = attribution;

    if (merge) {
      const existing = getCampaignAttribution();
      if (existing) {
        dataToStore = { ...existing, ...attribution };
      }
    }

    window.sessionStorage.setItem(CAMPAIGN_ATTRIBUTION_KEY, JSON.stringify(dataToStore));
  } catch (error) {
    console.warn("Failed to store campaign attribution:", error);
  }
}

/**
 * Retrieves campaign attribution parameters from sessionStorage
 *
 * @returns Campaign parameters or null if none stored/error
 */
export function getCampaignAttribution(): CampaignParams | null {
  if (typeof window === "undefined") return null; // SSR safety

  try {
    const stored = window.sessionStorage.getItem(CAMPAIGN_ATTRIBUTION_KEY);
    if (!stored) return null;

    return JSON.parse(stored) as CampaignParams;
  } catch (error) {
    console.warn("Failed to retrieve campaign attribution:", error);
    return null;
  }
}

/**
 * Clears campaign attribution from sessionStorage
 */
export function clearCampaignAttribution(): void {
  if (typeof window === "undefined") return; // SSR safety

  try {
    window.sessionStorage.removeItem(CAMPAIGN_ATTRIBUTION_KEY);
  } catch (error) {
    console.warn("Failed to clear campaign attribution:", error);
  }
}

/**
 * Adds campaign attribution to an analytics event object
 * Only adds values that don't already exist in the event
 *
 * @param event - The analytics event object
 * @returns Enhanced event with campaign attribution
 */
export function addCampaignAttributionToEvent<T extends Record<string, unknown>>(event: T): T {
  const attribution = getCampaignAttribution();
  if (!attribution) return event;

  const enhanced = { ...event } as T;

  // Only add attribution values that aren't already in the event and aren't undefined
  Object.entries(attribution).forEach(([key, value]) => {
    if (value !== undefined && !(key in enhanced)) {
      (enhanced as Record<string, unknown>)[key] = value;
    }
  });

  return enhanced;
}
</file>

<file path="lib/analytics/campaign-dashboard-integration.ts">
/**
 * PostHog Dashboard Integration for Campaign Analytics
 *
 * This module provides functions to create and manage PostHog dashboards
 * specifically for email campaign tracking and performance analysis.
 */

/**
 * Configuration for creating a campaign dashboard
 */
export interface CampaignDashboardConfig {
  name: string;
  description?: string;
  campaignId: string;
  insightConfigs: CampaignInsightConfig[];
}

/**
 * Configuration for individual campaign insights
 */
export interface CampaignInsightConfig {
  name: string;
  description?: string;
  query: string;
  dateRange?: {
    date_from: string;
    date_to: string;
  };
}

/**
 * Result of dashboard creation
 */
export interface CampaignDashboardResult {
  dashboardId: string;
  dashboardUrl: string;
  insights: Array<{
    id: string;
    name: string;
    url: string;
  }>;
}

/**
 * Result of insight creation
 */
export interface CampaignInsightResult {
  id: string;
  name: string;
  short_id?: string;
}

/**
 * Result of campaign insights query
 */
export interface CampaignInsightsResult {
  query: string;
  results: Array<Record<string, unknown>>;
}

/**
 * Result of dashboard update
 */
export interface CampaignDashboardUpdateResult {
  dashboardId: string;
  newInsightId: string;
  totalInsights: number;
}

/**
 * PostHog MCP interface for type safety
 */
export interface PostHogMCP {
  "insight-create-from-query": (params: unknown) => Promise<unknown>;
  "dashboard-create": (params: unknown) => Promise<unknown>;
  "dashboard-get": (params: unknown) => Promise<unknown>;
  "add-insight-to-dashboard": (params: unknown) => Promise<unknown>;
  "get-sql-insight": (params: unknown) => Promise<unknown>;
}

/**
 * Creates a complete campaign dashboard with all insights
 */
export async function createCampaignDashboard(
  posthogMCP: PostHogMCP,
  config: CampaignDashboardConfig
): Promise<CampaignDashboardResult> {
  // Create the dashboard first
  const dashboardResponse = await posthogMCP["dashboard-create"]({
    data: {
      name: config.name,
      description: config.description,
      pinned: true,
      tags: ["campaign", "beta", "email"],
    },
  });

  const dashboardId = (dashboardResponse as { id: string }).id;
  const dashboardUrl =
    (dashboardResponse as { url?: string }).url ||
    `https://app.posthog.com/dashboard/${dashboardId}`;

  // Create all insights and add them to the dashboard
  const insights: Array<{ id: string; name: string; url: string }> = [];

  for (const insightConfig of config.insightConfigs) {
    const insightResult = await createCampaignInsights(posthogMCP, insightConfig);

    // Add insight to dashboard
    await posthogMCP["add-insight-to-dashboard"]({
      data: {
        dashboardId: dashboardId,
        insightId: insightResult.id,
      },
    });

    insights.push({
      id: insightResult.id,
      name: insightResult.name,
      url: `https://app.posthog.com/insights/${insightResult.id}`,
    });
  }

  return {
    dashboardId,
    dashboardUrl,
    insights,
  };
}

/**
 * Creates individual insights with proper HogQL queries
 */
export async function createCampaignInsights(
  posthogMCP: PostHogMCP,
  config: CampaignInsightConfig
): Promise<CampaignInsightResult> {
  const dateRange = config.dateRange || {
    date_from: "-30d",
    date_to: "now",
  };

  const response = await posthogMCP["insight-create-from-query"]({
    data: {
      name: config.name,
      description: config.description,
      query: {
        kind: "DataVisualizationNode",
        source: {
          kind: "HogQLQuery",
          query: config.query,
          filters: {
            dateRange,
          },
        },
      },
      saved: true,
      favorited: false,
      tags: ["campaign"],
    },
  });

  return {
    id: (response as { id: string }).id,
    name: (response as { name: string }).name,
    short_id: (response as { short_id?: string }).short_id,
  };
}

/**
 * Retrieves campaign data using natural language queries
 */
export async function getCampaignInsights(
  posthogMCP: PostHogMCP,
  naturalLanguageQuery: string
): Promise<CampaignInsightsResult> {
  const response = await posthogMCP["get-sql-insight"]({
    query: naturalLanguageQuery,
  });

  return {
    query: (response as { query?: string }).query || "No query generated",
    results: (response as { results?: Array<Record<string, unknown>> }).results || [],
  };
}

/**
 * Updates existing dashboard with new insights
 */
export async function updateCampaignDashboard(
  posthogMCP: PostHogMCP,
  dashboardId: string,
  newInsightConfig: CampaignInsightConfig
): Promise<CampaignDashboardUpdateResult> {
  // Get current dashboard to count existing insights
  const dashboardData = await posthogMCP["dashboard-get"]({
    dashboardId: parseInt(dashboardId.replace("dashboard_", "")),
  });

  // Create the new insight
  const newInsight = await createCampaignInsights(posthogMCP, newInsightConfig);

  // Add insight to dashboard
  await posthogMCP["add-insight-to-dashboard"]({
    data: {
      dashboardId: dashboardId,
      insightId: newInsight.id,
    },
  });

  return {
    dashboardId,
    newInsightId: newInsight.id,
    totalInsights: ((dashboardData as { insights?: unknown[] }).insights?.length || 0) + 1,
  };
}
</file>

<file path="lib/analytics/campaign-metrics.ts">
/**
 * Core data structure for campaign metrics
 */
export interface CampaignMetricsData {
  emails_sent: number;
  emails_opened?: number;
  emails_clicked?: number;
  landing_page_views?: number;
  diagnostic_sessions_started?: number;
  diagnostic_sessions_completed?: number;
  bounce_rate?: number;
  unsubscribe_rate?: number;
}

/**
 * Funnel conversion metrics
 */
export interface FunnelMetrics {
  open_rate: number;
  click_through_rate: number;
  click_to_landing_rate: number;
  landing_to_diagnostic_rate: number;
  diagnostic_completion_rate: number;
  overall_conversion_rate: number;
  total_dropoff: number;
  largest_dropoff_stage: string;
  largest_dropoff_amount: number;
}

/**
 * A/B test variant comparison results
 */
export interface VariantComparison {
  variant_a_conversion_rate: number;
  variant_b_conversion_rate: number;
  conversion_rate_lift: number;
  relative_lift_percentage: number;
  winner: "A" | "B" | "tie";
  statistical_significance: boolean;
  confidence_level?: number;
}

/**
 * Time-based conversion rate analysis
 */
export interface ConversionRates {
  hourly_rates: Array<{ timestamp: number; rate: number }>;
  current_rate: number;
  average_rate: number;
  trend: "improving" | "declining" | "stable";
}

/**
 * Time series data point
 */
export interface TimeSeriesDataPoint {
  timestamp: number;
  emails_sent: number;
  completed: number;
}

/**
 * Event data structure for aggregation
 */
export interface EventData {
  event: string;
  properties: {
    campaign_id?: string;
    [key: string]: unknown;
  };
}

/**
 * Loops email platform data structure
 */
export interface LoopsData {
  emails_sent: number;
  emails_opened?: number;
  emails_clicked?: number;
  bounce_rate?: number;
  unsubscribe_rate?: number;
}

/**
 * Safely calculates percentage, handling division by zero
 */
function safePercentage(numerator: number, denominator: number): number {
  if (denominator === 0) return 0;
  return Math.round((numerator / denominator) * 10000) / 100; // Round to 2 decimal places
}

/**
 * Calculates comprehensive funnel metrics for a campaign
 */
export function calculateCampaignFunnelMetrics(data: CampaignMetricsData): FunnelMetrics {
  const {
    emails_sent,
    emails_opened = 0,
    emails_clicked = 0,
    landing_page_views = 0,
    diagnostic_sessions_started = 0,
    diagnostic_sessions_completed = 0,
  } = data;

  // Calculate basic conversion rates
  const open_rate = safePercentage(emails_opened, emails_sent);
  const click_through_rate = safePercentage(emails_clicked, emails_sent);
  const click_to_landing_rate = safePercentage(landing_page_views, emails_clicked);
  const landing_to_diagnostic_rate = safePercentage(
    diagnostic_sessions_started,
    landing_page_views
  );
  const diagnostic_completion_rate = safePercentage(
    diagnostic_sessions_completed,
    diagnostic_sessions_started
  );
  const overall_conversion_rate = safePercentage(diagnostic_sessions_completed, emails_sent);

  // Calculate dropoff analysis
  const total_dropoff = safePercentage(emails_sent - diagnostic_sessions_completed, emails_sent);

  // Find largest dropoff stage
  const dropoffs = [
    { stage: "email_open", amount: emails_sent - emails_opened },
    { stage: "email_click", amount: emails_opened - emails_clicked },
    { stage: "click_to_landing", amount: emails_clicked - landing_page_views },
    { stage: "landing_to_diagnostic", amount: landing_page_views - diagnostic_sessions_started },
    {
      stage: "diagnostic_completion",
      amount: diagnostic_sessions_started - diagnostic_sessions_completed,
    },
  ];

  const largestDropoff = dropoffs.reduce((max, current) =>
    current.amount > max.amount ? current : max
  );

  return {
    open_rate,
    click_through_rate,
    click_to_landing_rate,
    landing_to_diagnostic_rate,
    diagnostic_completion_rate,
    overall_conversion_rate,
    total_dropoff,
    largest_dropoff_stage: largestDropoff.stage,
    largest_dropoff_amount: largestDropoff.amount,
  };
}

/**
 * Compares two campaign variants for A/B testing
 */
export function calculateVariantComparison(
  variantA: Partial<CampaignMetricsData>,
  variantB: Partial<CampaignMetricsData>
): VariantComparison {
  const aConversionRate = safePercentage(
    variantA.diagnostic_sessions_completed || 0,
    variantA.emails_sent || 0
  );

  const bConversionRate = safePercentage(
    variantB.diagnostic_sessions_completed || 0,
    variantB.emails_sent || 0
  );

  const conversion_rate_lift = Math.round((aConversionRate - bConversionRate) * 100) / 100;
  const relative_lift_percentage = safePercentage(
    Math.abs(conversion_rate_lift),
    Math.min(aConversionRate, bConversionRate)
  );

  let winner: "A" | "B" | "tie" = "tie";
  if (aConversionRate > bConversionRate) winner = "A";
  else if (bConversionRate > aConversionRate) winner = "B";

  // Simple statistical significance calculation (z-test for proportions)
  const totalA = variantA.emails_sent || 0;
  const totalB = variantB.emails_sent || 0;
  const successA = variantA.diagnostic_sessions_completed || 0;
  const successB = variantB.diagnostic_sessions_completed || 0;

  let statistical_significance = false;
  let confidence_level: number | undefined;

  if (totalA > 30 && totalB > 30) {
    // Basic sample size requirement
    const p1 = successA / totalA;
    const p2 = successB / totalB;
    const pooled = (successA + successB) / (totalA + totalB);
    const se = Math.sqrt(pooled * (1 - pooled) * (1 / totalA + 1 / totalB));
    const z = Math.abs(p1 - p2) / se;

    // z > 1.96 indicates 95% confidence
    if (z > 1.96) {
      statistical_significance = true;
      confidence_level = 95 + (z - 1.96) * 2.5; // Rough confidence level
      confidence_level = Math.min(confidence_level, 99.9);
    }
  }

  return {
    variant_a_conversion_rate: aConversionRate,
    variant_b_conversion_rate: bConversionRate,
    conversion_rate_lift,
    relative_lift_percentage,
    winner,
    statistical_significance,
    confidence_level,
  };
}

/**
 * Calculates time-based conversion rates and trends
 */
export function calculateConversionRates(timeSeriesData: TimeSeriesDataPoint[]): ConversionRates {
  // Sort by timestamp (most recent first)
  const sortedData = [...timeSeriesData].sort((a, b) => b.timestamp - a.timestamp);

  const hourly_rates = sortedData.map((point) => ({
    timestamp: point.timestamp,
    rate: safePercentage(point.completed, point.emails_sent),
  }));

  const current_rate = hourly_rates[0]?.rate || 0;

  // Calculate average rate across all time periods
  const totalCompleted = sortedData.reduce((sum, point) => sum + point.completed, 0);
  const totalSent = sortedData.reduce((sum, point) => sum + point.emails_sent, 0);
  const average_rate = safePercentage(totalCompleted, totalSent);

  // Determine trend
  let trend: "improving" | "declining" | "stable" = "stable";
  const tolerance = 0.5; // 0.5% tolerance for "stable"

  if (current_rate > average_rate + tolerance) {
    trend = "improving";
  } else if (current_rate < average_rate - tolerance) {
    trend = "declining";
  }

  return {
    hourly_rates,
    current_rate,
    average_rate,
    trend,
  };
}

/**
 * Aggregates campaign data from multiple sources (Loops + PostHog)
 */
export function aggregateCampaignData(
  loopsData: Partial<LoopsData>,
  posthogEvents: EventData[],
  campaignId?: string
): CampaignMetricsData {
  // Filter PostHog events by campaign ID if provided
  const relevantEvents = campaignId
    ? posthogEvents.filter((event) => event.properties.campaign_id === campaignId)
    : posthogEvents;

  // Count specific event types
  const landing_page_views = relevantEvents.filter(
    (event) => event.event === "email_campaign_landing"
  ).length;

  const diagnostic_sessions_started = relevantEvents.filter(
    (event) => event.event === "diagnostic_started"
  ).length;

  const diagnostic_sessions_completed = relevantEvents.filter(
    (event) => event.event === "diagnostic_completed"
  ).length;

  return {
    emails_sent: loopsData.emails_sent || 0,
    emails_opened: loopsData.emails_opened || 0,
    emails_clicked: loopsData.emails_clicked || 0,
    landing_page_views,
    diagnostic_sessions_started,
    diagnostic_sessions_completed,
    bounce_rate: loopsData.bounce_rate,
    unsubscribe_rate: loopsData.unsubscribe_rate,
  };
}
</file>

<file path="lib/analytics/funnels.ts">
import { trackEvent, ANALYTICS_EVENTS, PostHogClient } from "./analytics";

// Funnel step definitions
export const FUNNEL_STEPS = {
  // Activation Funnel
  ACTIVATION: {
    LANDING: "activation_landing",
    SIGNUP_START: "activation_signup_start",
    EMAIL_VERIFY: "activation_email_verify",
    FIRST_DIAGNOSTIC: "activation_first_diagnostic",
    DIAGNOSTIC_COMPLETE: "activation_diagnostic_complete",
    ACTIVATED: "activation_complete",
  },

  // Purchase Funnel
  PURCHASE: {
    PRICING_VIEW: "purchase_pricing_view",
    PLAN_SELECT: "purchase_plan_select",
    CHECKOUT_START: "purchase_checkout_start",
    PAYMENT_INFO: "purchase_payment_info",
    PAYMENT_COMPLETE: "purchase_payment_complete",
  },

  // Retention Funnel
  RETENTION: {
    LOGIN: "retention_login",
    DASHBOARD: "retention_dashboard",
    PRACTICE_START: "retention_practice_start",
    PRACTICE_COMPLETE: "retention_practice_complete",
    RETURN_NEXT_DAY: "retention_return_next_day",
    RETURN_WEEK: "retention_return_week",
  },

  // Feature Adoption Funnel
  FEATURE_ADOPTION: {
    DISCOVER: "feature_adoption_discover",
    TRY: "feature_adoption_try",
    USE: "feature_adoption_use",
    HABIT: "feature_adoption_habit",
  },
} as const;

// Type definitions
export type FunnelName = keyof typeof FUNNEL_STEPS;
export type FunnelStep<T extends FunnelName> =
  (typeof FUNNEL_STEPS)[T][keyof (typeof FUNNEL_STEPS)[T]];

// Funnel state management
const FUNNEL_STORAGE_KEY = "testero_funnel_state";

interface FunnelState {
  [key: string]: {
    currentStep: string;
    startTime: number;
    stepTimes: Record<string, number>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    metadata?: Record<string, any>;
  };
}

// Get current funnel state from sessionStorage
function getFunnelState(): FunnelState {
  if (typeof window === "undefined") return {};

  const stored = sessionStorage.getItem(FUNNEL_STORAGE_KEY);
  return stored ? JSON.parse(stored) : {};
}

// Save funnel state to sessionStorage
function saveFunnelState(state: FunnelState) {
  if (typeof window === "undefined") return;

  sessionStorage.setItem(FUNNEL_STORAGE_KEY, JSON.stringify(state));
}

// Track funnel step progression
export function trackFunnelStep<T extends FunnelName>(
  posthog: PostHogClient,
  funnelName: T,
  step: FunnelStep<T>,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  if (!posthog) return;

  const state = getFunnelState();
  const now = Date.now();
  const stepStr = step as string; // Type assertion for string indexing

  // Initialize funnel if first step
  if (!state[funnelName]) {
    state[funnelName] = {
      currentStep: stepStr,
      startTime: now,
      stepTimes: { [stepStr]: now },
      metadata: properties,
    };
  } else {
    // Calculate time since last step
    const lastStepTime = Math.max(...Object.values(state[funnelName].stepTimes));
    const timeSinceLastStep = now - lastStepTime;
    const totalFunnelTime = now - state[funnelName].startTime;
    const previousStep = state[funnelName].currentStep;

    // Update state
    state[funnelName].currentStep = stepStr;
    state[funnelName].stepTimes[stepStr] = now;

    // Track step transition
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.FEATURE_USED,
      {
        funnel_name: funnelName,
        funnel_step: stepStr,
        previous_step: previousStep,
        time_since_last_step: timeSinceLastStep,
        total_funnel_time: totalFunnelTime,
        step_number: Object.keys(state[funnelName].stepTimes).length,
        ...properties,
      },
      userId
    );
  }

  saveFunnelState(state);

  // Track funnel entry
  if (Object.keys(state[funnelName].stepTimes).length === 1) {
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.FEATURE_DISCOVERED,
      {
        funnel_name: funnelName,
        entry_step: stepStr,
        discovery_type: "funnel_start",
        ...properties,
      },
      userId
    );
  }
}

// Track funnel completion
export function trackFunnelComplete<T extends FunnelName>(
  posthog: PostHogClient,
  funnelName: T,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  if (!posthog) return;

  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) {
    console.warn(`Funnel ${funnelName} not found in state`);
    return;
  }

  const now = Date.now();
  const totalTime = now - funnelData.startTime;
  const stepCount = Object.keys(funnelData.stepTimes).length;

  // Calculate step durations
  const stepDurations: Record<string, number> = {};
  const sortedSteps = Object.entries(funnelData.stepTimes).sort(([, a], [, b]) => a - b);

  for (let i = 0; i < sortedSteps.length - 1; i++) {
    const [currentStep, currentTime] = sortedSteps[i];
    const [, nextTime] = sortedSteps[i + 1];
    stepDurations[currentStep] = nextTime - currentTime;
  }

  // Track completion event
  trackEvent(
    posthog,
    ANALYTICS_EVENTS.TRIAL_TO_PAID_CONVERSION,
    {
      funnel_name: funnelName,
      total_time: totalTime,
      step_count: stepCount,
      step_durations: stepDurations,
      completion_rate: 100,
      ...funnelData.metadata,
      ...properties,
    },
    userId
  );

  // Clear funnel from state
  delete state[funnelName];
  saveFunnelState(state);
}

// Track funnel abandonment
export function trackFunnelAbandonment<T extends FunnelName>(
  posthog: PostHogClient,
  funnelName: T,
  reason?: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  if (!posthog) return;

  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) return;

  const now = Date.now();
  const totalTime = now - funnelData.startTime;
  const lastStep = funnelData.currentStep;
  const stepCount = Object.keys(funnelData.stepTimes).length;

  // Track abandonment event
  trackEvent(
    posthog,
    ANALYTICS_EVENTS.DIAGNOSTIC_ABANDONED,
    {
      funnel_name: funnelName,
      abandonment_step: lastStep,
      abandonment_reason: reason,
      total_time: totalTime,
      step_count: stepCount,
      completion_rate: (stepCount / Object.keys(FUNNEL_STEPS[funnelName]).length) * 100,
      ...funnelData.metadata,
      ...properties,
    },
    userId
  );

  // Clear funnel from state
  delete state[funnelName];
  saveFunnelState(state);
}

// Helper to track exit intent
export function trackExitIntent(
  posthog: PostHogClient,
  currentPage: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  const state = getFunnelState();
  const activeFunnels = Object.keys(state);

  if (activeFunnels.length > 0) {
    // User is leaving with active funnels
    activeFunnels.forEach((funnelName) => {
      trackFunnelAbandonment(
        posthog,
        funnelName as FunnelName,
        "exit_intent",
        {
          exit_page: currentPage,
          ...properties,
        },
        userId
      );
    });
  }
}

// Specialized funnel tracking functions
export function trackActivationFunnel(
  posthog: PostHogClient,
  step: keyof typeof FUNNEL_STEPS.ACTIVATION,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  trackFunnelStep(posthog, "ACTIVATION", FUNNEL_STEPS.ACTIVATION[step], properties, userId);
}

export function trackPurchaseFunnel(
  posthog: PostHogClient,
  step: keyof typeof FUNNEL_STEPS.PURCHASE,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  trackFunnelStep(posthog, "PURCHASE", FUNNEL_STEPS.PURCHASE[step], properties, userId);
}

export function trackRetentionFunnel(
  posthog: PostHogClient,
  step: keyof typeof FUNNEL_STEPS.RETENTION,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  trackFunnelStep(posthog, "RETENTION", FUNNEL_STEPS.RETENTION[step], properties, userId);
}

// Funnel optimization helpers
export function calculateFunnelDropoff(posthog: PostHogClient, funnelName: FunnelName): number {
  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) return 0;

  const totalSteps = Object.keys(FUNNEL_STEPS[funnelName]).length;
  const completedSteps = Object.keys(funnelData.stepTimes).length;

  return ((totalSteps - completedSteps) / totalSteps) * 100;
}

export function getFunnelMetrics(funnelName: FunnelName) {
  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) return null;

  const now = Date.now();
  const totalTime = now - funnelData.startTime;
  const stepCount = Object.keys(funnelData.stepTimes).length;
  const totalSteps = Object.keys(FUNNEL_STEPS[funnelName]).length;

  return {
    currentStep: funnelData.currentStep,
    stepCount,
    totalSteps,
    completionRate: (stepCount / totalSteps) * 100,
    totalTime,
    averageStepTime: totalTime / stepCount,
    metadata: funnelData.metadata,
  };
}
</file>

<file path="lib/analytics/server-analytics.ts">
import { PostHog } from "posthog-node";

// Server-side PostHog instance for API routes
let serverPostHog: PostHog | null | undefined;

export function getServerPostHog(): PostHog | null {
  if (typeof serverPostHog === "undefined") {
    const apiKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;

    serverPostHog = apiKey
      ? new PostHog(apiKey, {
          host: process.env.NEXT_PUBLIC_POSTHOG_HOST || "https://app.posthog.com",
        })
      : null;
  }

  return serverPostHog ?? null;
}

// Reset function for testing
export function resetServerPostHog() {
  serverPostHog = undefined;
}
</file>

<file path="lib/pricing/__mocks__/constants.ts">
// Manual mock for pricing constants in tests
export const SUBSCRIPTION_TIERS = [
  {
    id: "basic",
    name: "Basic",
    monthlyPriceId: "price_basic_monthly",
    annualPriceId: "price_basic_yearly",
  },
  {
    id: "pro",
    name: "Pro",
    monthlyPriceId: "price_monthly",
    annualPriceId: "price_yearly",
  },
  {
    id: "all-access",
    name: "All-Access",
    monthlyPriceId: "price_all_monthly",
    annualPriceId: "price_all_yearly",
  },
];

export const EXAM_PACKAGES = [
  { id: "3-month", priceId: "price_exam_3month" },
  { id: "6-month", priceId: "price_exam_6month" },
  { id: "12-month", priceId: "price_exam_12month" },
];
</file>

<file path="lib/pricing/constants.ts">
// Comprehensive pricing configuration based on revenue model

// Runtime validation for required environment variables
const validatePriceIds = () => {
  const requiredPriceIds = [
    {
      key: "NEXT_PUBLIC_STRIPE_BASIC_MONTHLY",
      value: process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY,
    },
    { key: "NEXT_PUBLIC_STRIPE_BASIC_ANNUAL", value: process.env.NEXT_PUBLIC_STRIPE_BASIC_ANNUAL },
    { key: "NEXT_PUBLIC_STRIPE_PRO_MONTHLY", value: process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY },
    { key: "NEXT_PUBLIC_STRIPE_PRO_ANNUAL", value: process.env.NEXT_PUBLIC_STRIPE_PRO_ANNUAL },
    {
      key: "NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY",
      value: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY,
    },
    {
      key: "NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL",
      value: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL,
    },
    // Exam package price IDs
    { key: "NEXT_PUBLIC_STRIPE_EXAM_3MONTH", value: process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH },
    { key: "NEXT_PUBLIC_STRIPE_EXAM_6MONTH", value: process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH },
    { key: "NEXT_PUBLIC_STRIPE_EXAM_12MONTH", value: process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH },
  ];

  const missingIds = requiredPriceIds.filter(({ value }) => !value);

  if (missingIds.length > 0) {
    // Only log warning, never throw during module initialization
    console.warn(
      `Missing Stripe price IDs:`,
      missingIds.map(({ key }) => key)
    );
  }
};

// Only validate in browser context, not during build or SSR
if (typeof window !== "undefined") {
  validatePriceIds();
}

export interface PricingTier {
  id: string;
  name: string;
  description: string;
  monthlyPrice: number;
  annualPrice: number;
  monthlyPriceId?: string;
  annualPriceId?: string;
  aiCredits: number;
  features: string[];
  highlighted?: string[];
  recommended?: boolean;
  savingsPercentage?: number;
}

export interface ExamPackage {
  id: string;
  duration: string;
  months: number;
  price: number;
  priceId?: string;
  aiCredits: number;
  features: string[];
}

// Annual subscription tiers from revenue model
export const SUBSCRIPTION_TIERS: PricingTier[] = [
  {
    id: "basic",
    name: "Basic",
    description: "Perfect for focused certification prep",
    monthlyPrice: 39,
    annualPrice: 349,
    monthlyPriceId: process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY,
    annualPriceId: process.env.NEXT_PUBLIC_STRIPE_BASIC_ANNUAL,
    aiCredits: 5,
    features: [
      "1 certification track",
      "Core practice questions",
      "Basic analytics dashboard",
      "Progress tracking",
      "Mobile access",
      "Email support",
    ],
    highlighted: ["1 certification track", "5 AI credits/month"],
    savingsPercentage: 25,
  },
  {
    id: "pro",
    name: "Pro",
    description: "Most popular for serious learners",
    monthlyPrice: 59,
    annualPrice: 549,
    monthlyPriceId: process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY,
    annualPriceId: process.env.NEXT_PUBLIC_STRIPE_PRO_ANNUAL,
    aiCredits: 20,
    features: [
      "3 certification tracks",
      "All practice modes",
      "Advanced analytics",
      "Adaptive learning paths",
      "Spaced repetition",
      "Priority support",
      "Early access to new features",
      "Detailed explanations",
      "Performance insights",
    ],
    highlighted: ["3 certification tracks", "20 AI credits/month", "Advanced analytics"],
    recommended: true,
    savingsPercentage: 23,
  },
  {
    id: "all-access",
    name: "All-Access",
    description: "Ultimate learning experience",
    monthlyPrice: 79,
    annualPrice: 749,
    monthlyPriceId: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY,
    annualPriceId: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL,
    aiCredits: 50,
    features: [
      "All certifications",
      "Unlimited tracks",
      "Team features",
      "API access",
      "Custom study plans",
      "1-on-1 coaching session",
      "Exclusive content",
      "White-glove support",
      "Bulk question generation",
      "Export capabilities",
    ],
    highlighted: ["All certifications", "50 AI credits/month", "Team features"],
    savingsPercentage: 21,
  },
];

// One-time exam packages
export const EXAM_PACKAGES: ExamPackage[] = [
  {
    id: "3-month",
    duration: "3-Month Access",
    months: 3,
    price: 99,
    priceId: process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH,
    aiCredits: 10,
    features: ["Full exam content", "10 AI practice exams", "Progress tracking", "Basic analytics"],
  },
  {
    id: "6-month",
    duration: "6-Month Access",
    months: 6,
    price: 149,
    priceId: process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH,
    aiCredits: 25,
    features: [
      "Full exam content",
      "25 AI practice exams",
      "Progress tracking",
      "Advanced analytics",
      "Priority support",
    ],
  },
  {
    id: "12-month",
    duration: "12-Month Access",
    months: 12,
    price: 199,
    priceId: process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH,
    aiCredits: 50,
    features: [
      "Full exam content",
      "50 AI practice exams",
      "Progress tracking",
      "Advanced analytics",
      "Priority support",
      "Exam retake coverage",
    ],
  },
];

// AI Credit pricing and usage
export const AI_CREDIT_USAGE = {
  fullExam: 1,
  domainQuiz: 0.5,
  explanation: 0.2,
  additionalCreditPrice: 2,
  bulkDiscounts: [
    { credits: 10, price: 18, discount: 10 },
    { credits: 25, price: 40, discount: 20 },
    { credits: 50, price: 75, discount: 25 },
  ],
};

// Value propositions for pricing page
export const VALUE_PROPS = {
  mainHeadline: "Pass Your Certification 15% Fasterâ€”Guaranteed",
  subHeadline:
    "Join 5,000+ professionals who passed on their first attempt with AI-powered adaptive learning",
  guarantees: [
    "7-day money-back guarantee",
    "Pass guarantee or get 3 months free",
    "Content updated within 14 days of exam changes",
  ],
  trustBadges: [
    "5,000+ Professionals Certified",
    "92% First-Attempt Pass Rate",
    "4.8/5 Average Rating",
    "Updated Weekly",
  ],
  valueAnchors: {
    examCost: "Invest $149 to protect your $300 exam fee",
    salary: "PMLE-certified professionals earn $150k+ on average",
    time: "Save 40% study time with AI-personalized paths",
    success: "Join 5,000+ professionals who passed on first attempt",
  },
};

// Comparison table data
export const FEATURE_COMPARISON = [
  {
    category: "Core Features",
    features: [
      { name: "Practice Questions", basic: "500+", pro: "2,000+", allAccess: "Unlimited" },
      { name: "Certification Tracks", basic: "1", pro: "3", allAccess: "All" },
      { name: "AI Credits/Month", basic: "5", pro: "20", allAccess: "50" },
      { name: "Diagnostic Tests", basic: true, pro: true, allAccess: true },
      { name: "Progress Tracking", basic: true, pro: true, allAccess: true },
    ],
  },
  {
    category: "Advanced Features",
    features: [
      { name: "Adaptive Learning", basic: false, pro: true, allAccess: true },
      { name: "Spaced Repetition", basic: false, pro: true, allAccess: true },
      { name: "Performance Analytics", basic: "Basic", pro: "Advanced", allAccess: "Premium" },
      { name: "Custom Study Plans", basic: false, pro: false, allAccess: true },
      { name: "Team Features", basic: false, pro: false, allAccess: true },
    ],
  },
  {
    category: "Support & Resources",
    features: [
      { name: "Support", basic: "Email", pro: "Priority", allAccess: "White-glove" },
      { name: "Response Time", basic: "48h", pro: "24h", allAccess: "2h" },
      { name: "1-on-1 Coaching", basic: false, pro: false, allAccess: "1 session" },
      { name: "Exclusive Content", basic: false, pro: "Early access", allAccess: true },
      { name: "API Access", basic: false, pro: false, allAccess: true },
    ],
  },
];

// FAQ data for pricing page
export const PRICING_FAQ = [
  {
    question: "Can I switch between plans?",
    answer:
      "Yes! You can upgrade or downgrade your plan at any time. Changes are prorated, so you only pay for what you use.",
  },
  {
    question: "What happens when I run out of AI credits?",
    answer:
      "You can purchase additional credits at $2 per credit, or upgrade to a higher tier for better value. Basic practice questions don't require credits.",
  },
  {
    question: "Do you offer refunds?",
    answer:
      "Absolutely. We offer a 7-day money-back guarantee. If you're not satisfied, contact us within 7 days for a full refund, no questions asked.",
  },
  {
    question: "What's included in the pass guarantee?",
    answer:
      "If you complete 80% of your personalized study plan and don't pass your exam, we'll give you 3 additional months free to prepare for your retake.",
  },
  {
    question: "Can I pause my subscription?",
    answer:
      "Yes, you can pause your subscription for up to 3 months if you need to take a break. Your progress and credits will be saved.",
  },
  {
    question: "Is there a free trial?",
    answer:
      "We offer a free diagnostic test and limited practice questions. This lets you experience our platform before committing to a paid plan.",
  },
  {
    question: "How often is the content updated?",
    answer:
      "We update our content within 14 days of any exam blueprint changes. Our AI continuously generates new questions to keep your practice fresh.",
  },
  {
    question: "Can my company purchase team licenses?",
    answer:
      "Yes! Contact us for enterprise pricing. We offer volume discounts, admin dashboards, and custom integration options for teams of 5+.",
  },
];

// Testimonials for pricing page
export const PRICING_TESTIMONIALS = [
  {
    quote:
      "The Pro plan paid for itself when I passed PMLE on my first try. The adaptive learning saved me at least 40 hours of study time.",
    author: "Sarah Chen",
    role: "ML Engineer at Google",
    certification: "Google PMLE",
    tier: "Pro",
  },
  {
    quote:
      "Started with Basic for my PCA cert, upgraded to All-Access and passed 3 certs in 6 months. Best career investment I've made.",
    author: "Michael Rodriguez",
    role: "Cloud Architect",
    certification: "Multiple GCP Certs",
    tier: "All-Access",
  },
  {
    quote:
      "The 6-month exam package was perfect. Enough time to study at my pace, and the 25 AI credits were exactly what I needed.",
    author: "Jennifer Park",
    role: "DevOps Engineer",
    certification: "Google ACE",
    tier: "6-Month Package",
  },
];
</file>

<file path="lib/pricing/price-utils.ts">
// Pricing analytics helper functions
// Centralizes logic for extracting tier names, payment modes, and plan types from Stripe price IDs

/**
 * Determines if a price ID corresponds to an exam package (one-time payment)
 * vs a subscription tier (recurring payment)
 */
export function isExamPackagePrice(priceId: string): boolean {
  return [
    process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH,
    process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH,
    process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH,
  ].includes(priceId);
}

/**
 * Returns the payment mode for a given price ID
 * - "payment" for one-time exam packages
 * - "subscription" for recurring subscription tiers
 */
export function getPaymentMode(priceId: string): "subscription" | "payment" {
  return isExamPackagePrice(priceId) ? "payment" : "subscription";
}

/**
 * Returns the plan type for a given price ID
 * - "exam_package" for one-time exam packages
 * - "subscription" for recurring subscription tiers
 */
export function getPlanType(priceId: string): "subscription" | "exam_package" {
  return isExamPackagePrice(priceId) ? "exam_package" : "subscription";
}

/**
 * Extracts the tier name from a Stripe price ID
 * Maps price IDs to human-readable tier names for analytics tracking
 *
 * @param priceId - The Stripe price ID to look up
 * @returns Tier name string (Basic, Pro, All-Access, or exam package name, or "Unknown")
 */
export function getTierNameFromPriceId(priceId: string): string {
  // Basic tier
  if (
    priceId === process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY ||
    priceId === process.env.NEXT_PUBLIC_STRIPE_BASIC_ANNUAL
  ) {
    return "Basic";
  }

  // Pro tier
  if (
    priceId === process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY ||
    priceId === process.env.NEXT_PUBLIC_STRIPE_PRO_ANNUAL
  ) {
    return "Pro";
  }

  // All-Access tier
  if (
    priceId === process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY ||
    priceId === process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL
  ) {
    return "All-Access";
  }

  // Exam packages
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH) {
    return "3-Month Package";
  }
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH) {
    return "6-Month Package";
  }
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH) {
    return "12-Month Package";
  }

  return "Unknown";
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

// Utility function to merge Tailwind CSS classes
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="components/ui/index.ts">
export * from "./button"
export * from "./badge"
export * from "./card"
export * from "./page-header"
export * from "./empty-state"
export * from "./table"
export * from "./toast"
export * from "./dropdown-menu"
</file>

<file path="components/ui/radio-group.tsx">
"use client";

import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
</file>

<file path="components/ui/select.tsx">
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-11 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2.5 text-base shadow-xs transition-colors outline-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm md:leading-5",
      "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
      "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />;
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="components/ui/navigator-tile.tsx">
"use client";

import * as React from "react";
import { Flag } from "lucide-react";
import { cn } from "@/lib/utils";

export interface NavigatorTileProps {
  questionNumber: number;
  onClick: () => void;
  isAnswered?: boolean;
  isCurrent?: boolean;
  isFlagged?: boolean;
}

export const NavigatorTile = React.forwardRef<
  HTMLButtonElement,
  NavigatorTileProps
>(({ questionNumber, onClick, isAnswered = false, isCurrent = false, isFlagged = false }, ref) => {
  return (
    <button
      ref={ref}
      type="button"
      onClick={onClick}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center rounded-md border text-sm font-medium transition-colors",
        "hover:border-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1",
        // Default state (unanswered)
        !isCurrent && !isAnswered && "border-slate-200 bg-white text-slate-700",
        // Answered state
        !isCurrent && isAnswered && "border-blue-200 bg-blue-50 text-blue-700",
        // Current state
        isCurrent && "border-blue-600 bg-blue-600 text-white"
      )}
      aria-label={`Question ${questionNumber}${isFlagged ? ", flagged" : ""}${isAnswered ? ", answered" : ""}`}
    >
      {questionNumber}
      {isFlagged && (
        <Flag
          data-testid="flag-icon"
          className="absolute -right-1 -top-1 h-3 w-3 text-amber-400"
          fill="currentColor"
          aria-hidden="true"
        />
      )}
    </button>
  );
});

NavigatorTile.displayName = "NavigatorTile";
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-transparent px-3 py-2.5 text-base shadow-xs transition-[color,box-shadow] outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 md:text-sm md:leading-5",
          "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
          "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
          "resize-y",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="lib/analytics/analytics.ts">
// Type for PostHog client (both client-side and server-side)
export type PostHogClient =
  | {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      capture: (event: string, properties?: Record<string, any>) => void;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      identify: (userId: string, properties?: Record<string, any>) => void;
    }
  | {
      capture: (params: {
        distinctId: string;
        event: string;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        properties?: Record<string, any>;
      }) => void;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      identify: (params: { distinctId: string; properties?: Record<string, any> }) => void;
      shutdown?: () => void;
    }
  | null;

// For typing purposes in client-side code
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type PostHog = any;

// Event names as constants to prevent typos and ensure consistency
export const ANALYTICS_EVENTS = {
  // Authentication & Session
  USER_SESSION_STARTED: "user_session_started",
  USER_SESSION_ENDED: "user_session_ended",
  USER_IDENTIFIED: "user_identified",
  SIGNUP_ATTEMPT: "signup_attempt",
  SIGNUP_SUCCESS: "signup_success",
  SIGNUP_ERROR: "signup_error",
  LOGIN_ATTEMPT: "login_attempt",
  LOGIN_ERROR: "login_error",

  // Dashboard
  DASHBOARD_VIEWED: "dashboard_viewed",
  DASHBOARD_LOADED: "dashboard_loaded",
  DASHBOARD_ERROR: "dashboard_error",

  // Diagnostic
  DIAGNOSTIC_STARTED: "diagnostic_started",
  DIAGNOSTIC_RESUME_SHOWN: "diagnostic_resume_shown",
  DIAGNOSTIC_RESUMED: "diagnostic_resumed",
  DIAGNOSTIC_QUESTION_ANSWERED: "diagnostic_question_answered",
  DIAGNOSTIC_COMPLETED: "diagnostic_completed",
  DIAGNOSTIC_ABANDONED: "diagnostic_abandoned",
  DIAGNOSTIC_SUMMARY_VIEWED: "diagnostic_summary_viewed",
  DIAGNOSTIC_SUMMARY_GATED_VIEWED: "diagnostic_summary_gated_viewed",
  DIAGNOSTIC_SUMMARY_SIGNUP_CTA_CLICKED: "diagnostic_summary_signup_cta_clicked",
  DIAGNOSTIC_DOMAIN_CLICKED: "diagnostic_domain_clicked",
  STUDY_PLAN_START_PRACTICE_CLICKED: "study_plan_start_practice_clicked",

  // Study Path
  STUDY_PATH_VIEWED: "study_path_viewed",
  STUDY_PATH_GENERATED: "study_path_generated",
  STUDY_PATH_ERROR: "study_path_error",

  // Practice Questions
  PRACTICE_PAGE_VIEWED: "practice_page_viewed",
  PRACTICE_QUESTION_LOADED: "practice_question_loaded",
  PRACTICE_QUESTION_ANSWERED: "practice_question_answered",
  PRACTICE_QUESTION_ERROR: "practice_question_error",
  PRACTICE_SESSION_CREATED_FROM_DIAGNOSTIC: "practice_session_created_from_diagnostic",
  PRACTICE_SESSION_CREATION_FAILED_FROM_DIAGNOSTIC: "practice_session_creation_failed_from_diagnostic",
  PRACTICE_SESSION_STARTED: "practice_session_started",
  PRACTICE_SESSION_COMPLETED: "practice_session_completed",
  PRACTICE_SESSION_SUMMARY_VIEWED: "practice_session_summary_viewed",
  PRACTICE_QUOTA_EXCEEDED: "practice_quota_exceeded",
  QUESTION_EXPLANATION_VIEWED: "question_explanation_viewed",

  // Subscription & Billing
  SUBSCRIPTION_CREATED: "subscription_created",
  SUBSCRIPTION_UPDATED: "subscription_updated",
  SUBSCRIPTION_CANCELLED: "subscription_cancelled",
  PAYMENT_FAILED: "payment_failed",
  CHECKOUT_INITIATED: "checkout_initiated",
  CHECKOUT_SESSION_CREATED: "checkout_session_created",
  CHECKOUT_ERROR: "checkout_error",
  UPGRADE_CTA_CLICKED: "upgrade_cta_clicked",
  UPGRADE_SIGNUP_REDIRECT: "upgrade_signup_redirect",
  BILLING_PORTAL_ACCESSED: "billing_portal_accessed",
  GATE_VIEWED: "gate_viewed",
  GATE_CTA_CLICKED: "gate_cta_clicked",
  GATE_DISMISSED: "gate_dismissed",
  ENTITLEMENT_CHECK_FAILED: "entitlement_check_failed",

  // Pricing
  PRICING_PAGE_VIEWED: "pricing_page_viewed",
  PRICING_PLAN_SELECTED: "pricing_plan_selected",

  // Errors
  UNHANDLED_ERROR: "unhandled_error",
  ERROR_RECOVERY_ATTEMPTED: "error_recovery_attempted",

  // Email Verification
  EMAIL_VERIFICATION_PAGE_VIEWED: "email_verification_page_viewed",
  EMAIL_CONFIRMED: "email_confirmed",
  EMAIL_VERIFICATION_ERROR: "email_verification_error",

  // Conversion Events
  TRIAL_STARTED: "trial_started",
  TRIAL_TO_PAID_CONVERSION: "trial_to_paid_conversion",

  // Feature Discovery
  FEATURE_DISCOVERED: "feature_discovered",
  FEATURE_USED: "feature_used",

  // Beta Onboarding Flow
  BETA_STARTED: "beta_started",
  START_DIAGNOSTIC_CLICKED: "start_diagnostic_clicked",
  DIAGNOSTIC_SESSION_CREATED: "diagnostic_session_created",
  SKIP_DIAGNOSTIC_CLICKED: "skip_diagnostic_clicked",
  BETA_BANNER_VIEWED: "beta_banner_viewed",
  BETA_BANNER_DISMISSED: "beta_banner_dismissed",

  // Email Campaign Events
  EMAIL_CAMPAIGN_LANDING: "email_campaign_landing",
  CAMPAIGN_ATTRIBUTION_SET: "campaign_attribution_set",
  EMAIL_CAMPAIGN_TRACKING_PIXEL_LOADED: "email_campaign_tracking_pixel_loaded",
} as const;

// User property keys for consistency
export const USER_PROPERTIES = {
  EMAIL: "email",
  USER_ID: "user_id",
  SUBSCRIPTION_TIER: "subscription_tier",
  SUBSCRIPTION_STATUS: "subscription_status",
  IS_PAYING_CUSTOMER: "is_paying_customer",
  IS_TRIAL: "is_trial",
  CUSTOMER_SINCE: "customer_since",
  CHURNED_AT: "churned_at",
  EXAM_TYPE: "exam_type",
  READINESS_SCORE: "readiness_score",
  TOTAL_PRACTICE_QUESTIONS: "total_practice_questions",
  ACCURACY_PERCENTAGE: "accuracy_percentage",
  PLAN_TIER: "plan_tier",
  IS_EARLY_ACCESS: "is_early_access",
  EMAIL_VERIFIED: "email_verified",
} as const;

// Helper types
export type AnalyticsEvent = (typeof ANALYTICS_EVENTS)[keyof typeof ANALYTICS_EVENTS];
export type UserProperty = (typeof USER_PROPERTIES)[keyof typeof USER_PROPERTIES];

// Helper function to track events with proper typing
export function trackEvent(
  posthog: PostHogClient | PostHog,
  event: AnalyticsEvent,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  distinctId?: string
) {
  if (!posthog) return;

  // Check if it's server-side PostHog (has distinctId parameter in capture)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if (distinctId && posthog && typeof (posthog as any).capture === "function") {
    // Server-side PostHog
    (posthog as PostHog).capture({
      distinctId,
      event,
      properties: properties || {},
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } else if (posthog && typeof (posthog as any).capture === "function") {
    // Client-side PostHog
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (posthog as any).capture(event, properties);
  }
}

// Helper function to identify users with proper typing
export function identifyUser(
  posthog: PostHogClient | PostHog,
  userId: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Partial<Record<UserProperty, any>>
) {
  if (!posthog) return;

  // Check if it's server-side PostHog (has shutdown method)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((posthog as any)?.shutdown) {
    // Server-side PostHog
    (posthog as PostHog).identify({
      distinctId: userId,
      properties: properties || {},
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } else if (posthog && typeof (posthog as any).identify === "function") {
    // Client-side PostHog
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (posthog as any).identify(userId, properties);
  }
}

// Helper function to track conversion events
export function trackConversion(
  posthog: PostHogClient | PostHog,
  conversionType: string,
  value: number,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  const conversionData = {
    conversion_type: conversionType,
    conversion_value: value,
    ...properties,
  };

  trackEvent(posthog, ANALYTICS_EVENTS.TRIAL_TO_PAID_CONVERSION, conversionData, userId);
}

// Helper function to track errors consistently
export function trackError(
  posthog: PostHogClient | PostHog,
  error: Error | string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  context?: Record<string, any>,
  userId?: string
) {
  const errorData = {
    error_message: typeof error === "string" ? error : error.message,
    error_stack: typeof error === "object" ? error.stack : undefined,
    error_name: typeof error === "object" ? error.name : "Error",
    ...context,
  };

  trackEvent(posthog, ANALYTICS_EVENTS.UNHANDLED_ERROR, errorData, userId);
}

// Helper function to calculate and track engagement metrics
export function trackEngagement(
  posthog: PostHogClient | PostHog,
  engagementType: "session_duration" | "page_depth" | "feature_interaction",
  value: number,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  const eventData = {
    engagement_type: engagementType,
    engagement_value: value,
    ...properties,
  };

  trackEvent(posthog, ANALYTICS_EVENTS.FEATURE_USED, eventData, userId);
}
</file>

</files>
