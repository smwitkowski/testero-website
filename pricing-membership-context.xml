This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/pricing/**/*, app/dashboard/**/*, app/page.tsx, app/waitlist/**/*, app/diagnostic/**/summary/**/*, app/practice/layout.tsx, app/diagnostic/layout.tsx, components/pricing/**/*, components/billing/**/*, components/patterns/**/*, components/ui/**/*, app/api/billing/**/*, lib/pricing/**/*, lib/billing/**/*, lib/access/**/*, lib/auth/require-subscriber.ts, lib/auth/entitlements.ts, lib/stripe/**/*, lib/config/billing.ts, hooks/useStartBasicCheckout.ts, hooks/useUpsell.ts, hooks/useSubscriptionStatus.ts, lib/utils.ts, lib/analytics/**/*, components/providers/AuthProvider.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  api/
    billing/
      checkout/
        success/
          route.ts
        route.ts
      portal/
        route.ts
      status/
        route.ts
      trial/
        route.ts
      webhook/
        route.ts
  dashboard/
    billing/
      page.tsx
    layout.tsx
    page.tsx
  diagnostic/
    [sessionId]/
      summary/
        page.tsx
    layout.tsx
  practice/
    layout.tsx
  pricing/
    page.tsx
  waitlist/
    page.metadata.tsx
    page.tsx
  page.tsx
components/
  billing/
    TrialConversionModal.tsx
    UpgradePrompt.tsx
  patterns/
    __tests__/
      section.test.tsx
    container.stories.tsx
    Container.tsx
    index.ts
    section.stories.tsx
    section.tsx
  pricing/
    ComparisonTable.tsx
    PricingCard.stories.tsx
    PricingCard.tsx
  providers/
    AuthProvider.tsx
  ui/
    __stories__/
      docs/
        EmptyState.mdx
        PageHeader.mdx
        Table.mdx
        Toast.mdx
      Badge.stories.tsx
      EmptyState.stories.tsx
      PageHeader.stories.tsx
      Table.stories.tsx
      Toast.stories.tsx
    __tests__/
      button.a11y.test.tsx
    badge.tsx
    button.tsx
    card.tsx
    checkbox.tsx
    dialog.tsx
    dropdown-menu.tsx
    empty-state.tsx
    form.tsx
    index.ts
    input.tsx
    label.tsx
    navigator-tile.tsx
    page-header.tsx
    progress.tsx
    radio-group.tsx
    select.tsx
    table.tsx
    textarea.tsx
    theme-toggle.tsx
    toast.tsx
hooks/
  useStartBasicCheckout.ts
  useSubscriptionStatus.ts
  useUpsell.ts
lib/
  access/
    pmleEntitlements.server.ts
    pmleEntitlements.ts
  analytics/
    hooks/
      useSessionTracking.ts
    analytics.ts
    campaign-analytics-integration.ts
    campaign-attribution.ts
    campaign-dashboard-integration.ts
    campaign-metrics.ts
    funnels.ts
    server-analytics.ts
  auth/
    entitlements.ts
    require-subscriber.ts
  billing/
    access.ts
    enforcement.ts
    gated-layout.ts
    grace-cookie.ts
    is-subscriber.ts
    subscription-status.ts
  config/
    billing.ts
  pricing/
    __mocks__/
      constants.ts
    constants.ts
    price-utils.ts
  stripe/
    stripe-service.ts
  utils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/billing/checkout/success/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { cookies } from "next/headers";
import { signGraceCookie } from "@/lib/billing/grace-cookie";
import { StripeService } from "@/lib/stripe/stripe-service";
import { createServerSupabaseClient } from "@/lib/supabase/server";

/**
 * Handle Stripe checkout success redirect
 * Verifies Stripe session and sets a signed grace cookie for authenticated users
 */
export async function GET(request: NextRequest): Promise<NextResponse> {
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || "http://localhost:3000";
  const failureUrl = `${siteUrl}/dashboard/billing?success=0`;
  
  try {
    // Extract session_id from query parameters
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get("session_id");
    
    if (!sessionId) {
      console.error("[Checkout Success] Missing session_id parameter");
      return NextResponse.redirect(failureUrl, { status: 303 });
    }

    // Get authenticated user
    const supabase = createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      console.error("[Checkout Success] Unauthenticated request", { 
        error: authError ? "Auth error" : "No user"
      });
      return NextResponse.redirect(failureUrl, { status: 303 });
    }

    // Retrieve and verify the Stripe checkout session
    const stripeService = new StripeService();
    let session;
    
    try {
      session = await stripeService.retrieveCheckoutSession(sessionId);
    } catch (stripeError) {
      console.error("[Checkout Success] Failed to retrieve Stripe session", {
        error: stripeError instanceof Error ? stripeError.message : "Unknown error"
      });
      return NextResponse.redirect(failureUrl, { status: 303 });
    }

    // Verify payment status
    if (session.payment_status !== "paid") {
      console.error("[Checkout Success] Session payment not completed", {
        session_id: sessionId,
        payment_status: session.payment_status
      });
      return NextResponse.redirect(failureUrl, { status: 303 });
    }

    // Verify the session belongs to the authenticated user
    const sessionUserId = session.metadata?.user_id;
    if (!sessionUserId || sessionUserId !== user.id) {
      console.error("[Checkout Success] User ID mismatch", {
        authenticated_user: user.id,
        session_metadata_user: sessionUserId || "missing"
      });
      return NextResponse.redirect(failureUrl, { status: 303 });
    }

    // All checks passed - issue grace cookie
    const { name, value, options } = signGraceCookie();
    const cookieStore = await cookies();
    cookieStore.set(name, value, options);
    
    console.log("[Checkout Success] Grace cookie issued", {
      user_id: user.id,
      session_id: sessionId
    });
    
    return NextResponse.redirect(`${siteUrl}/dashboard/billing?success=1`, { status: 303 });
    
  } catch (error) {
    console.error("[Checkout Success] Unexpected error", {
      error: error instanceof Error ? error.message : "Unknown error"
    });
    return NextResponse.redirect(failureUrl, { status: 303 });
  }
}
</file>

<file path="app/api/billing/checkout/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { StripeService } from "@/lib/stripe/stripe-service";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { checkRateLimit } from "@/lib/auth/rate-limiter";
import { SUBSCRIPTION_TIERS, EXAM_PACKAGES } from "@/lib/pricing/constants";
import { z } from "zod";

interface CheckoutSessionResponse {
  url: string;
}

interface ErrorResponse {
  error: string;
}

const checkoutSchema = z.object({
  priceId: z.string().min(1),
});

export async function POST(
  request: NextRequest
): Promise<NextResponse<CheckoutSessionResponse | ErrorResponse>> {
  try {
    // Rate limiting
    const ip =
      request.headers.get("x-forwarded-for") || request.headers.get("x-real-ip") || "unknown";
    if (!(await checkRateLimit(ip))) {
      return NextResponse.json({ error: "Too many requests" }, { status: 429 });
    }

    // Check authentication
    const supabase = createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "You must be authenticated to checkout" }, { status: 401 });
    }

    // Parse and validate request body
    let body;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid request body" }, { status: 400 });
    }

    const parse = checkoutSchema.safeParse(body);
    if (!parse.success) {
      return NextResponse.json({ error: "Invalid price ID" }, { status: 400 });
    }

    const { priceId } = parse.data;

    // Build list of all valid price IDs from pricing constants
    const validPrices: string[] = [];

    // Add subscription tier price IDs
    for (const tier of SUBSCRIPTION_TIERS) {
      if (tier.monthlyPriceId) validPrices.push(tier.monthlyPriceId);
      if (tier.annualPriceId) validPrices.push(tier.annualPriceId);
    }

    // Add exam package price IDs
    for (const pkg of EXAM_PACKAGES) {
      if (pkg.priceId) validPrices.push(pkg.priceId);
    }

    // Validate price ID against our configured prices
    if (!validPrices.includes(priceId)) {
      return NextResponse.json({ error: "Invalid price ID" }, { status: 400 });
    }

    // Create Stripe service instance
    const stripeService = new StripeService();

    // Check if user already has an active subscription (only for subscription prices)
    // Allow one-time payments even if user has active subscription
    const priceType = await stripeService.getPriceType(priceId);

    if (priceType === "subscription") {
      const { data: existingSubscription } = await supabase
        .from("user_subscriptions")
        .select("*")
        .eq("user_id", user.id)
        .eq("status", "active")
        .single();

      if (existingSubscription) {
        return NextResponse.json(
          { error: "You already have an active subscription" },
          { status: 400 }
        );
      }
    }

    // Create or retrieve Stripe customer
    const customer = await stripeService.createOrRetrieveCustomer(user.id, user.email!);

    // Create checkout session
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || "http://localhost:3000";
    const session = await stripeService.createCheckoutSession({
      customerId: customer.id,
      priceId,
      successUrl: `${siteUrl}/api/billing/checkout/success?session_id={CHECKOUT_SESSION_ID}`,
      cancelUrl: `${siteUrl}/pricing`,
      userId: user.id,
    });

    return NextResponse.json({ url: session.url || "" }, { status: 200 });
  } catch (error) {
    console.error("Checkout session creation error:", error);
    return NextResponse.json({ error: "Failed to create checkout session" }, { status: 500 });
  }
}
</file>

<file path="app/api/billing/portal/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { StripeService } from "@/lib/stripe/stripe-service";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { checkRateLimit } from "@/lib/auth/rate-limiter";
import { ANALYTICS_EVENTS, trackEvent } from "@/lib/analytics/analytics";
import { getServerPostHog } from "@/lib/analytics/server-analytics";

interface PortalSessionResponse {
  url: string;
}

interface ErrorResponse {
  error: string;
}

export async function POST(
  request: NextRequest
): Promise<NextResponse<PortalSessionResponse | ErrorResponse>> {
  try {
    // Rate limiting
    const ip =
      request.headers.get("x-forwarded-for") || request.headers.get("x-real-ip") || "unknown";
    if (!(await checkRateLimit(ip))) {
      return NextResponse.json({ error: "Too many requests" }, { status: 429 });
    }

    // Check authentication
    const supabase = createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "You must be authenticated" }, { status: 401 });
    }

    // Get user's subscription
    const { data: subscription, error: subError } = await supabase
      .from("user_subscriptions")
      .select("stripe_customer_id")
      .eq("user_id", user.id)
      .single();

    if (subError || !subscription?.stripe_customer_id) {
      return NextResponse.json({ error: "No subscription found" }, { status: 404 });
    }

    // Create portal session
    const stripeService = new StripeService();
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || "http://localhost:3000";
    const session = await stripeService.createPortalSession(
      subscription.stripe_customer_id,
      `${siteUrl}/dashboard/billing`
    );

    // Track billing portal access
    const posthog = getServerPostHog();
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.BILLING_PORTAL_ACCESSED,
      {
        stripe_customer_id: subscription.stripe_customer_id,
        return_url: `${siteUrl}/dashboard/billing`,
      },
      user.id
    );

    return NextResponse.json({ url: session.url }, { status: 200 });
  } catch (error) {
    console.error("Portal session creation error:", error);
    return NextResponse.json({ error: "Failed to create portal session" }, { status: 500 });
  }
}
</file>

<file path="app/api/billing/status/route.ts">
import { NextResponse } from "next/server";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { computeIsSubscriber, type SubscriptionStatus } from "@/lib/billing/subscription-status";

export type BillingStatusResponse = {
  isSubscriber: boolean;
  status: SubscriptionStatus;
};

/**
 * GET /api/billing/status
 * Returns lightweight subscription status for UI decisions only.
 * Server remains authoritative for authorization.
 * No sensitive plan details (plan_id, Stripe IDs, amounts) are returned.
 */
export async function GET(): Promise<NextResponse<BillingStatusResponse>> {
  try {
    const supabase = createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    // Unauthenticated users get default response
    if (authError || !user) {
      return NextResponse.json(
        {
          isSubscriber: false,
          status: "none",
        },
        { status: 200 }
      );
    }

    // Query subscription with minimal fields - get most recent subscription
    // First check for active/trialing subscriptions
    const { data: activeData, error: activeError } = await supabase
      .from("user_subscriptions")
      .select("status, trial_ends_at")
      .eq("user_id", user.id)
      .in("status", ["active", "trialing"])
      .limit(1)
      .maybeSingle();

    // If found active/trialing, use it
    if (!activeError && activeData) {
      const isSubscriber = computeIsSubscriber(activeData);

      return NextResponse.json(
        {
          isSubscriber,
          status: activeData.status as BillingStatusResponse["status"],
        },
        { status: 200 }
      );
    }

    // If no active/trialing, check for any other subscription status
    const { data: anyData, error: anyError } = await supabase
      .from("user_subscriptions")
      .select("status, trial_ends_at")
      .eq("user_id", user.id)
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    // No subscription found at all
    if (anyError || !anyData) {
      return NextResponse.json(
        {
          isSubscriber: false,
          status: "none",
        },
        { status: 200 }
      );
    }

    // Return the status even if not active/trialing (for past_due, canceled, etc.)
    return NextResponse.json(
      {
        isSubscriber: false, // Non-active/trialing subscriptions are not subscribers
        status: anyData.status as BillingStatusResponse["status"],
      },
      { status: 200 }
    );
  } catch (error) {
    console.error("Error fetching billing status:", error);
    // Fail gracefully - return non-subscriber status
    return NextResponse.json(
      {
        isSubscriber: false,
        status: "none",
      },
      { status: 200 }
    );
  }
}
</file>

<file path="app/api/billing/trial/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { StripeService } from "@/lib/stripe/stripe-service";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { checkRateLimit } from "@/lib/auth/rate-limiter";
import { PostHog } from "posthog-node";
import { z } from "zod";
import { getTierNameFromPriceId } from "@/lib/pricing/price-utils";

interface TrialStartResponse {
  status: "ok";
  trialEndsAt: string;
  subscriptionId: string;
}

interface ErrorResponse {
  error: string;
}

// Optional body schema for anonymous session upgrade
const trialBodySchema = z.object({
  anonymousSessionId: z.string().optional(),
  priceId: z.string().optional(),
});

export async function POST(
  request: NextRequest
): Promise<NextResponse<TrialStartResponse | ErrorResponse>> {
  try {
    // Rate limiting
    const ip =
      request.headers.get("x-forwarded-for") || request.headers.get("x-real-ip") || "unknown";
    if (!(await checkRateLimit(ip))) {
      return NextResponse.json({ error: "Too many requests" }, { status: 429 });
    }

    // Check authentication
    const supabase = createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: "You must be authenticated to start a trial" },
        { status: 401 }
      );
    }

    // Parse optional body
    let body = {};
    try {
      const text = await request.text();
      if (text) {
        body = JSON.parse(text);
      }
    } catch {
      // Body is optional, ignore parse errors
    }

    const parsedBody = trialBodySchema.safeParse(body);
    const anonymousSessionId = parsedBody.success ? parsedBody.data.anonymousSessionId : undefined;

    // Step 1: Check for existing active subscription (authoritative check)
    const { data: existingActiveSubscription, error: activeSubError } = await supabase
      .from("user_subscriptions")
      .select("*")
      .eq("user_id", user.id)
      .in("status", ["active", "trialing"])
      .maybeSingle();

    if (activeSubError) {
      console.error(`[Trial] Error checking active subscription for user ${user.id}:`, activeSubError);
      // Continue - don't block on query errors, but log for investigation
    }

    if (existingActiveSubscription) {
      console.log(
        `[Trial] User ${user.id} already has active subscription: ${existingActiveSubscription.status}, subscription_id: ${existingActiveSubscription.stripe_subscription_id}`
      );
      return NextResponse.json(
        { error: "You already have an active subscription" },
        { status: 400 }
      );
    }

    // Step 2: Check subscription history to determine if trial was actually used
    const { data: subscriptionHistory, error: historyError } = await supabase
      .from("user_subscriptions")
      .select("id, status, trial_ends_at, created_at, stripe_subscription_id")
      .eq("user_id", user.id)
      .order("created_at", { ascending: false })
      .limit(3);

    if (historyError) {
      console.error(`[Trial] Error checking subscription history for user ${user.id}:`, historyError);
      // Don't proceed if we can't verify subscription history - fail closed
      return NextResponse.json(
        { error: "Unable to verify subscription eligibility. Please try again." },
        { status: 500 }
      );
    }

    // Determine if user has actually used a trial based on subscription history
    const hasUsedTrialFromHistory =
      subscriptionHistory &&
      subscriptionHistory.length > 0 &&
      subscriptionHistory.some((sub) => {
        // User has used trial if:
        // 1. They have a subscription with trial_ends_at set (trial was created)
        // 2. Status is not currently trialing (trial ended or converted)
        return (
          sub.trial_ends_at !== null &&
          sub.status !== "trialing" &&
          (sub.status === "active" ||
            sub.status === "canceled" ||
            sub.status === "past_due" ||
            sub.status === "unpaid" ||
            sub.status === "incomplete" ||
            sub.status === "incomplete_expired")
        );
      });

    if (hasUsedTrialFromHistory) {
      const trialSub = subscriptionHistory!.find((sub) => sub.trial_ends_at !== null);
      console.log(
        `[Trial] User ${user.id} has used trial (found in history): status=${trialSub?.status}, trial_ends_at=${trialSub?.trial_ends_at}, subscription_id=${trialSub?.stripe_subscription_id}`
      );
      return NextResponse.json(
        { error: "You have already used your free trial" },
        { status: 400 }
      );
    }

    // Step 3: Check metadata as advisory (less reliable, but useful for edge cases)
    // Only perform metadata operations if we successfully queried subscription history
    const hasUsedTrialMetadata = user.user_metadata?.has_used_trial === true;

    if (hasUsedTrialMetadata) {
      // At this point, we know subscriptionHistory query succeeded (no historyError)
      if (!subscriptionHistory || subscriptionHistory.length === 0) {
        // Metadata says trial was used but no subscription record exists
        // This suggests a previous failed attempt - log warning and clear metadata
        console.warn(
          `[Trial] User ${user.id} has has_used_trial=true metadata but no subscription history. Clearing incorrect metadata to allow retry.`
        );
        // Clear the incorrect metadata flag
        const { error: clearError } = await supabase.auth.updateUser({
          data: { has_used_trial: false },
        });
        if (clearError) {
          console.error(
            `[Trial] Failed to clear incorrect metadata for user ${user.id}:`,
            clearError
          );
        } else {
          console.log(`[Trial] Cleared incorrect has_used_trial metadata for user ${user.id}`);
        }
        // Continue - allow user to proceed
      } else {
        // Metadata and database both indicate trial was used
        console.log(
          `[Trial] User ${user.id} has has_used_trial=true metadata and subscription history. Rejecting trial request.`
        );
        return NextResponse.json(
          { error: "You have already used your free trial" },
          { status: 400 }
        );
      }
    }

    // Log eligibility check result
    console.log(
      `[Trial] User ${user.id} is eligible for trial: hasActiveSub=${!!existingActiveSubscription}, hasHistory=${!!(subscriptionHistory && subscriptionHistory.length > 0)}, hasMetadata=${hasUsedTrialMetadata}`
    );

    // Create or retrieve Stripe customer
    const stripeService = new StripeService();
    console.log(`[Trial] Creating/retrieving Stripe customer for user ${user.id}`);
    const customer = await stripeService.createOrRetrieveCustomer(user.id, user.email!);

    // Get default price ID for Pro tier (most popular)
    const priceId =
      parsedBody.success && parsedBody.data.priceId
        ? parsedBody.data.priceId
        : process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY || "price_pro_monthly";

    console.log(
      `[Trial] Creating trial subscription for user ${user.id}, customer ${customer.id}, price ${priceId}`
    );

    // Create trial subscription in Stripe
    const subscription = await stripeService.createTrialSubscription({
      customerId: customer.id,
      priceId,
      trialDays: 14,
      userId: user.id,
    });

    // Calculate trial end date
    const trialEndsAt = new Date(subscription.trial_end! * 1000).toISOString();

    console.log(
      `[Trial] Trial subscription created in Stripe: ${subscription.id}, status: ${subscription.status}, trial_ends_at: ${trialEndsAt}`
    );

    // Save subscription to database FIRST (before updating metadata)
    // This ensures we have a record even if metadata update fails
    const { error: insertError } = await supabase.from("user_subscriptions").insert({
      user_id: user.id,
      stripe_customer_id: customer.id,
      stripe_subscription_id: subscription.id,
      plan_id: null, // Will be set when trial converts
      status: "trialing",
      current_period_start: new Date().toISOString(),
      current_period_end: trialEndsAt,
      trial_ends_at: trialEndsAt,
    });

    if (insertError) {
      console.error(
        `[Trial] Failed to insert subscription to database for user ${user.id}:`,
        insertError
      );
      // Don't fail the request - subscription exists in Stripe
      // But log the error for investigation
    } else {
      console.log(
        `[Trial] Successfully saved subscription to database for user ${user.id}, subscription_id: ${subscription.id}`
      );
    }

    // Update user metadata to mark trial as used (after successful DB insert)
    const { error: metadataError } = await supabase.auth.updateUser({
      data: { has_used_trial: true },
    });

    if (metadataError) {
      console.error(
        `[Trial] Failed to update user metadata for user ${user.id}:`,
        metadataError
      );
      // Don't fail the request - subscription is created and saved to DB
      // Metadata is less critical than the actual subscription record
    } else {
      console.log(`[Trial] Successfully updated has_used_trial metadata for user ${user.id}`);
    }

    // Track analytics event
    const posthogKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;
    if (posthogKey) {
      const posthog = new PostHog(posthogKey, {
        host: process.env.NEXT_PUBLIC_POSTHOG_HOST || "https://app.posthog.com",
      });

      await posthog.capture({
        distinctId: user.id,
        event: "trial_started",
        properties: {
          email: user.email,
          trial_days: 14,
          price_id: priceId,
          tier_name: getTierNameFromPriceId(priceId),
          from_anonymous: !!anonymousSessionId,
          anonymous_session_id: anonymousSessionId,
        },
      });

      await posthog.shutdown();
    }

    return NextResponse.json(
      {
        status: "ok",
        trialEndsAt,
        subscriptionId: subscription.id,
      },
      { status: 200 }
    );
  } catch (error) {
    console.error(`[Trial] Trial creation error:`, error);

    // More specific error messages for debugging
    if (error instanceof Error) {
      console.error(`[Trial] Error details: message="${error.message}", stack="${error.stack}"`);

      if (error.message.includes("STRIPE_SECRET_KEY")) {
        console.error(`[Trial] Stripe secret key not configured`);
        return NextResponse.json(
          { error: "Payment system not configured. Please contact support." },
          { status: 503 }
        );
      }
      if (error.message.includes("Price")) {
        console.error(`[Trial] Invalid price ID in request`);
        return NextResponse.json(
          { error: "Invalid subscription plan. Please try again." },
          { status: 400 }
        );
      }
    }

    // Log full error context for debugging
    console.error(`[Trial] Unhandled error during trial creation:`, {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });

    return NextResponse.json(
      { error: "Failed to start trial. Please try again." },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/billing/webhook/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { StripeService } from "@/lib/stripe/stripe-service";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { EmailService } from "@/lib/email/email-service";
import Stripe from "stripe";
import { PostHog } from "posthog-node";

// Extended Stripe types for properties that exist but aren't in the official types
interface ExtendedSubscription extends Stripe.Subscription {
  current_period_start: number;
  current_period_end: number;
}

interface ExtendedInvoice extends Stripe.Invoice {
  subscription: string;
  payment_intent: string;
}

// Initialize PostHog
const posthog = (() => {
  const apiKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;
  if (!apiKey) {
    return null;
  }

  return new PostHog(apiKey, {
    host: process.env.NEXT_PUBLIC_POSTHOG_HOST || "https://app.posthog.com",
  });
})();

export async function POST(request: NextRequest) {
  try {
    // Get the raw body and signature
    const signature = request.headers.get("stripe-signature");
    if (!signature) {
      return NextResponse.json({ error: "Missing stripe signature" }, { status: 400 });
    }

    const rawBody = await request.text();
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    if (!webhookSecret) {
      return NextResponse.json({ error: "Webhook secret not configured" }, { status: 500 });
    }

    // Verify webhook signature
    const stripeService = new StripeService();
    let event: Stripe.Event;

    try {
      event = stripeService.constructWebhookEvent(rawBody, signature, webhookSecret);
    } catch (error) {
      console.error("Webhook signature verification failed:", error);
      return NextResponse.json({ error: "Invalid webhook signature" }, { status: 400 });
    }

    const supabase = createServerSupabaseClient();

    // Check for duplicate event processing (idempotency)
    const { data: existingEvent } = await supabase
      .from("webhook_events")
      .select("*")
      .eq("stripe_event_id", event.id)
      .single();

    if (existingEvent?.processed) {
      return NextResponse.json({ message: "Event already processed" }, { status: 200 });
    }

    // Insert or update the event record
    if (!existingEvent) {
      await supabase.from("webhook_events").insert({
        stripe_event_id: event.id,
        type: event.type,
        processed: false,
      });
    }

    // Process the event
    try {
      const emailService = new EmailService();

      // Log event received
      console.log(`[Webhook] Processing event: ${event.type} (id: ${event.id})`);

      switch (event.type) {
        case "checkout.session.completed": {
          const session = event.data.object as Stripe.Checkout.Session;

          // Get user_id from metadata
          const userId = session.metadata?.user_id;
          if (!userId) {
            console.error(`[Webhook] Missing user_id in session metadata for event ${event.id}`);
            throw new Error("Missing user_id in session metadata");
          }

          // Retrieve full session details
          const fullSession = await stripeService.retrieveCheckoutSession(session.id);

          if (fullSession.payment_status === "paid") {
            // Check session mode to determine payment type
            if (fullSession.mode === "subscription" && fullSession.subscription) {
              // Subscription payment
              console.log(
                `[Webhook] Processing subscription checkout for user ${userId}, subscription ${fullSession.subscription}`
              );

              // Get subscription details
              const subscription = await stripeService.retrieveSubscription(
                fullSession.subscription as string
              );

              // Get the plan from our database
              const priceId = subscription.items.data[0]?.price.id;
              const { data: plan } = await supabase
                .from("subscription_plans")
                .select("*")
                .or(`stripe_price_id_monthly.eq.${priceId},stripe_price_id_yearly.eq.${priceId}`)
                .single();

              // Create or update user subscription
              const { error: subError } = await supabase.from("user_subscriptions").upsert({
                user_id: userId,
                stripe_customer_id: fullSession.customer as string,
                stripe_subscription_id: subscription.id,
                plan_id: plan?.id,
                status: subscription.status,
                current_period_start: new Date(
                  (subscription as ExtendedSubscription).current_period_start * 1000
                ).toISOString(),
                current_period_end: new Date(
                  (subscription as ExtendedSubscription).current_period_end * 1000
                ).toISOString(),
                cancel_at_period_end: subscription.cancel_at_period_end || false,
              });

              if (subError) {
                console.error(
                  `[Webhook] Error upserting subscription for user ${userId}:`,
                  subError
                );
                throw subError;
              }

              // Record payment with idempotency
              if (fullSession.payment_intent) {
                const { error: paymentError } = await supabase
                  .from("payment_history")
                  .upsert(
                    {
                      user_id: userId,
                      stripe_payment_intent_id: fullSession.payment_intent as string,
                      amount: fullSession.amount_total || 0,
                      currency: fullSession.currency || "usd",
                      status: "succeeded",
                      receipt_url: null, // Will be populated by payment_intent.succeeded if available
                    },
                    { onConflict: "stripe_payment_intent_id" }
                  );

                if (paymentError) {
                  console.error(
                    `[Webhook] Error upserting payment history for payment intent ${fullSession.payment_intent}:`,
                    paymentError
                  );
                } else {
                  console.log(
                    `[Webhook] Successfully recorded subscription payment for user ${userId}, payment intent ${fullSession.payment_intent}`
                  );
                }
              }

              // Send confirmation email
              const { data: user } = await supabase.auth.admin.getUserById(userId);
              if (user?.user?.email) {
                await emailService.sendPaymentConfirmation(
                  user.user.email,
                  fullSession.amount_total || 0,
                  fullSession.currency || "usd"
                );
              }

              // Track subscription created in PostHog
              posthog?.capture({
                distinctId: userId,
                event: "subscription_created",
                properties: {
                  plan_name: plan?.name,
                  plan_tier: plan?.tier,
                  price_id: priceId,
                  amount: fullSession.amount_total || 0,
                  currency: fullSession.currency || "usd",
                  billing_interval: priceId === plan?.stripe_price_id_monthly ? "monthly" : "yearly",
                  stripe_customer_id: fullSession.customer as string,
                  stripe_subscription_id: subscription.id,
                  subscription_status: subscription.status,
                },
              });

              // Update user properties in PostHog
              posthog?.identify({
                distinctId: userId,
                properties: {
                  subscription_tier: plan?.tier,
                  subscription_status: subscription.status,
                  is_paying_customer: true,
                  customer_since: new Date().toISOString(),
                },
              });
            } else if (fullSession.mode === "payment" && fullSession.payment_intent) {
              // One-time payment
              console.log(
                `[Webhook] Processing one-time payment checkout for user ${userId}, payment intent ${fullSession.payment_intent}`
              );

              // Record payment in payment_history with idempotency
              const { error: paymentError } = await supabase
                .from("payment_history")
                .upsert(
                  {
                    user_id: userId,
                    stripe_payment_intent_id: fullSession.payment_intent as string,
                    amount: fullSession.amount_total || 0,
                    currency: fullSession.currency || "usd",
                    status: "succeeded",
                    receipt_url: null, // Will be populated by payment_intent.succeeded if available
                  },
                  { onConflict: "stripe_payment_intent_id" }
                );

              if (paymentError) {
                console.error(
                  `[Webhook] Error upserting payment history for payment intent ${fullSession.payment_intent}:`,
                  paymentError
                );
              } else {
                console.log(
                  `[Webhook] Successfully recorded one-time payment for user ${userId}, payment intent ${fullSession.payment_intent}`
                );
              }

              // Send confirmation email
              const { data: user } = await supabase.auth.admin.getUserById(userId);
              if (user?.user?.email) {
                await emailService.sendPaymentConfirmation(
                  user.user.email,
                  fullSession.amount_total || 0,
                  fullSession.currency || "usd"
                );
              }

              // Track one-time payment in PostHog
              posthog?.capture({
                distinctId: userId,
                event: "payment_one_time_succeeded",
                properties: {
                  amount: fullSession.amount_total || 0,
                  currency: fullSession.currency || "usd",
                  stripe_payment_intent_id: fullSession.payment_intent as string,
                  stripe_checkout_session_id: fullSession.id,
                },
              });
            } else {
              console.warn(
                `[Webhook] Unhandled checkout session mode: ${fullSession.mode} for event ${event.id}`
              );
            }
          }
          break;
        }

        case "payment_intent.succeeded": {
          const paymentIntent = event.data.object as Stripe.PaymentIntent;

          // Get user_id from metadata
          const userId = paymentIntent.metadata?.user_id;
          if (!userId) {
            console.log(
              `[Webhook] Skipping payment_intent.succeeded - no user_id in metadata for payment intent ${paymentIntent.id}`
            );
            break;
          }

          console.log(
            `[Webhook] Processing payment_intent.succeeded for user ${userId}, payment intent ${paymentIntent.id}`
          );

          // Retrieve payment intent with expanded charges to get receipt URL
          let receiptUrl: string | null = null;
          try {
            const expandedPaymentIntent = await stripeService.retrievePaymentIntent(
              paymentIntent.id,
              ["charges"]
            );
            // Type assertion for expanded charges - Stripe expands charges as an array
            interface ExpandedPaymentIntent extends Stripe.PaymentIntent {
              charges?: Stripe.ApiList<Stripe.Charge>;
            }
            const expanded = expandedPaymentIntent as ExpandedPaymentIntent;
            if (expanded.charges?.data && expanded.charges.data.length > 0) {
              receiptUrl = expanded.charges.data[0]?.receipt_url || null;
            }
          } catch (error) {
            console.warn(
              `[Webhook] Could not retrieve expanded payment intent for receipt URL: ${error}`
            );
            // Continue without receipt URL
          }

          // Upsert payment history with idempotency
          const { error: paymentError } = await supabase
            .from("payment_history")
            .upsert(
              {
                user_id: userId,
                stripe_payment_intent_id: paymentIntent.id,
                amount: paymentIntent.amount,
                currency: paymentIntent.currency,
                status: "succeeded",
                receipt_url: receiptUrl,
              },
              { onConflict: "stripe_payment_intent_id" }
            );

          if (paymentError) {
            console.error(
              `[Webhook] Error upserting payment history for payment intent ${paymentIntent.id}:`,
              paymentError
            );
          } else {
            console.log(
              `[Webhook] Successfully recorded payment intent ${paymentIntent.id} for user ${userId}`
            );
          }

          // Track payment intent succeeded in PostHog
          posthog?.capture({
            distinctId: userId,
            event: "payment_intent_succeeded",
            properties: {
              amount: paymentIntent.amount,
              currency: paymentIntent.currency,
              stripe_payment_intent_id: paymentIntent.id,
              receipt_url: receiptUrl,
            },
          });

          break;
        }

        case "customer.subscription.created": {
          const subscription = event.data.object as Stripe.Subscription;

          // Get user_id from metadata
          const userId = subscription.metadata?.user_id;
          if (!userId) {
            console.log("Skipping subscription.created - no user_id in metadata:", subscription.id);
            break;
          }

          // Check if subscription already exists (idempotency)
          const { data: existingSub } = await supabase
            .from("user_subscriptions")
            .select("id")
            .eq("stripe_subscription_id", subscription.id)
            .single();

          if (existingSub) {
            console.log("Subscription already exists:", subscription.id);
            break;
          }

          // Get the plan from price ID
          const priceId = subscription.items.data[0]?.price.id;
          const { data: plan } = await supabase
            .from("subscription_plans")
            .select("*")
            .or(`stripe_price_id_monthly.eq.${priceId},stripe_price_id_yearly.eq.${priceId}`)
            .single();

          // Create subscription record (but don't mark as active until payment completes)
          await supabase.from("user_subscriptions").insert({
            user_id: userId,
            stripe_customer_id: subscription.customer as string,
            stripe_subscription_id: subscription.id,
            plan_id: plan?.id,
            status: subscription.status,
            current_period_start: new Date(
              (subscription as ExtendedSubscription).current_period_start * 1000
            ).toISOString(),
            current_period_end: new Date(
              (subscription as ExtendedSubscription).current_period_end * 1000
            ).toISOString(),
            cancel_at_period_end: subscription.cancel_at_period_end || false,
          });

          // Track subscription creation in PostHog
          posthog?.capture({
            distinctId: userId,
            event: "subscription_created_webhook",
            properties: {
              stripe_subscription_id: subscription.id,
              subscription_status: subscription.status,
              plan_name: plan?.name,
              plan_tier: plan?.tier,
            },
          });

          break;
        }

        case "customer.subscription.updated": {
          const subscription = event.data.object as Stripe.Subscription;

          // Get user info for tracking
          const { data: userSub } = await supabase
            .from("user_subscriptions")
            .select("user_id, plan_id")
            .eq("stripe_subscription_id", subscription.id)
            .single();

          // Update subscription status
          await supabase
            .from("user_subscriptions")
            .update({
              status: subscription.status,
              current_period_start: new Date(
                (subscription as ExtendedSubscription).current_period_start * 1000
              ).toISOString(),
              current_period_end: new Date(
                (subscription as ExtendedSubscription).current_period_end * 1000
              ).toISOString(),
              cancel_at_period_end: subscription.cancel_at_period_end || false,
              updated_at: new Date().toISOString(),
            })
            .eq("stripe_subscription_id", subscription.id);

          // Track subscription update in PostHog
          if (userSub?.user_id) {
            posthog?.capture({
              distinctId: userSub.user_id,
              event: "subscription_updated",
              properties: {
                subscription_status: subscription.status,
                cancel_at_period_end: subscription.cancel_at_period_end || false,
                stripe_subscription_id: subscription.id,
                update_type: subscription.cancel_at_period_end
                  ? "scheduled_cancellation"
                  : "reactivation",
              },
            });

            // Update user properties
            posthog?.identify({
              distinctId: userSub.user_id,
              properties: {
                subscription_status: subscription.status,
                subscription_will_cancel: subscription.cancel_at_period_end || false,
              },
            });
          }
          break;
        }

        case "customer.subscription.deleted": {
          const subscription = event.data.object as Stripe.Subscription;

          // Mark subscription as cancelled
          const { data: subData } = await supabase
            .from("user_subscriptions")
            .update({
              status: "canceled",
              updated_at: new Date().toISOString(),
            })
            .eq("stripe_subscription_id", subscription.id)
            .select("user_id")
            .single();

          // Send cancellation email
          if (subData?.user_id) {
            const { data: user } = await supabase.auth.admin.getUserById(subData.user_id);
            if (user?.user?.email) {
              await emailService.sendSubscriptionCancelled(user.user.email);
            }

            // Track subscription cancellation in PostHog
            posthog?.capture({
              distinctId: subData.user_id,
              event: "subscription_cancelled",
              properties: {
                stripe_subscription_id: subscription.id,
                cancellation_reason: subscription.cancellation_details?.reason || "unknown",
              },
            });

            // Update user properties
            posthog?.identify({
              distinctId: subData.user_id,
              properties: {
                subscription_status: "cancelled",
                is_paying_customer: false,
                churned_at: new Date().toISOString(),
              },
            });
          }
          break;
        }

        case "invoice.paid":
        case "invoice.payment_succeeded": {
          const invoice = event.data.object as ExtendedInvoice;

          // Only process if this is a subscription invoice (has subscription field)
          if (!invoice.subscription) {
            console.log(`[Webhook] Skipping non-subscription invoice: ${invoice.id}`);
            break;
          }

          console.log(
            `[Webhook] Processing invoice payment succeeded for subscription ${invoice.subscription}, invoice ${invoice.id}`
          );

          // Get user from subscription
          const { data: subscription } = await supabase
            .from("user_subscriptions")
            .select("user_id")
            .eq("stripe_subscription_id", invoice.subscription)
            .single();

          if (subscription?.user_id && invoice.payment_intent) {
            // Record recurring payment in payment_history with idempotency
            const { error: paymentError } = await supabase
              .from("payment_history")
              .upsert(
                {
                  user_id: subscription.user_id,
                  stripe_payment_intent_id: invoice.payment_intent,
                  amount: invoice.amount_paid ?? invoice.amount_due,
                  currency: invoice.currency,
                  status: "succeeded",
                  receipt_url: null, // Receipt URL not available from invoice
                },
                { onConflict: "stripe_payment_intent_id" }
              );

            if (paymentError) {
              console.error(
                `[Webhook] Error upserting recurring payment for payment intent ${invoice.payment_intent}:`,
                paymentError
              );
            } else {
              console.log(
                `[Webhook] Successfully recorded recurring payment for user ${subscription.user_id}, payment intent ${invoice.payment_intent}`
              );
            }

            // Send confirmation email
            const { data: user } = await supabase.auth.admin.getUserById(subscription.user_id);
            if (user?.user?.email) {
              await emailService.sendPaymentConfirmation(
                user.user.email,
                invoice.amount_paid ?? invoice.amount_due,
                invoice.currency
              );
            }

            // Track recurring payment in PostHog
            posthog?.capture({
              distinctId: subscription.user_id,
              event: "payment_recurring_succeeded",
              properties: {
                amount: invoice.amount_paid ?? invoice.amount_due,
                currency: invoice.currency,
                stripe_payment_intent_id: invoice.payment_intent,
                stripe_invoice_id: invoice.id,
                stripe_subscription_id: invoice.subscription,
              },
            });
          }
          break;
        }

        case "invoice.payment_failed": {
          const invoice = event.data.object as ExtendedInvoice;

          if (!invoice.subscription) {
            console.log(`[Webhook] Skipping non-subscription invoice: ${invoice.id}`);
            break;
          }

          console.log(
            `[Webhook] Processing invoice payment failed for subscription ${invoice.subscription}, invoice ${invoice.id}`
          );

          // Get user from subscription
          const { data: subscription } = await supabase
            .from("user_subscriptions")
            .select("user_id")
            .eq("stripe_subscription_id", invoice.subscription)
            .single();

          if (subscription?.user_id && invoice.payment_intent) {
            // Record failed payment with idempotency
            const { error: paymentError } = await supabase
              .from("payment_history")
              .upsert(
                {
                  user_id: subscription.user_id,
                  stripe_payment_intent_id: invoice.payment_intent,
                  amount: invoice.amount_due,
                  currency: invoice.currency,
                  status: "failed",
                  receipt_url: null,
                },
                { onConflict: "stripe_payment_intent_id" }
              );

            if (paymentError) {
              console.error(
                `[Webhook] Error upserting failed payment for payment intent ${invoice.payment_intent}:`,
                paymentError
              );
            } else {
              console.log(
                `[Webhook] Successfully recorded failed payment for user ${subscription.user_id}, payment intent ${invoice.payment_intent}`
              );
            }

            // Send failure notification
            const { data: user } = await supabase.auth.admin.getUserById(subscription.user_id);
            if (user?.user?.email) {
              await emailService.sendPaymentFailed(user.user.email);
            }

            // Track payment failure in PostHog
            posthog?.capture({
              distinctId: subscription.user_id,
              event: "payment_failed",
              properties: {
                amount: invoice.amount_due,
                currency: invoice.currency,
                stripe_payment_intent_id: invoice.payment_intent,
                failure_reason: invoice.status_transitions?.finalized_at
                  ? "card_declined"
                  : "unknown",
              },
            });
          }
          break;
        }

        default:
          console.log(`[Webhook] Unhandled event type: ${event.type} (id: ${event.id})`);
      }

      // Mark event as processed
      await supabase
        .from("webhook_events")
        .update({
          processed: true,
          processed_at: new Date().toISOString(),
        })
        .eq("stripe_event_id", event.id);

      return NextResponse.json({ received: true }, { status: 200 });
    } catch (error) {
      console.error("Error processing webhook:", error);

      // Record error in webhook_events
      await supabase
        .from("webhook_events")
        .update({
          error: error instanceof Error ? error.message : "Unknown error",
          processed_at: new Date().toISOString(),
        })
        .eq("stripe_event_id", event.id);

      if (error instanceof Error && error.message.includes("user_id")) {
        return NextResponse.json({ error: error.message }, { status: 400 });
      }

      return NextResponse.json({ error: "Error processing webhook" }, { status: 500 });
    }
  } catch (error) {
    console.error("Webhook handler error:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
</file>

<file path="app/diagnostic/layout.tsx">
import { createGatedLayout } from "@/lib/billing/gated-layout";

export default createGatedLayout("diagnostic");
</file>

<file path="app/practice/layout.tsx">
import { createGatedLayout } from "@/lib/billing/gated-layout";

export default createGatedLayout("practice");
</file>

<file path="app/pricing/page.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/providers/AuthProvider";
import {
  CheckCircle,
  Shield,
  TrendingUp,
  Award,
  ChevronDown,
  ChevronUp,
  Star,
  Zap,
  RefreshCw,
} from "lucide-react";
import { usePostHog } from "posthog-js/react";
import { trackEvent, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";
import {
  getTierNameFromPriceId,
  getPaymentMode,
  getPlanType,
} from "@/lib/pricing/price-utils";
import { PricingCard } from "@/components/pricing/PricingCard";
import { ComparisonTable } from "@/components/pricing/ComparisonTable";
import { Container, Section } from "@/components/patterns";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import {
  SUBSCRIPTION_TIERS,
  EXAM_PACKAGES,
  VALUE_PROPS,
  FEATURE_COMPARISON,
  PRICING_FAQ,
  PRICING_TESTIMONIALS,
  AI_CREDIT_USAGE,
} from "@/lib/pricing/constants";
import { cn } from "@/lib/utils";

export default function PricingPage() {
  const [billingInterval, setBillingInterval] = useState<"monthly" | "annual">("annual");
  const [showComparison, setShowComparison] = useState(false);
  const [openFaqIndex, setOpenFaqIndex] = useState<number | null>(null);
  const [showExamPackages, setShowExamPackages] = useState(false);
  const [loading, setLoading] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const { user } = useAuth();
  const router = useRouter();
  const posthog = usePostHog();

  // Track page view
  useEffect(() => {
    trackEvent(posthog, ANALYTICS_EVENTS.PRICING_PAGE_VIEWED, {
      user_id: user?.id,
      billing_interval: billingInterval,
    });
  }, [posthog, user, billingInterval]);

  const handleCheckout = async (priceId: string, planName: string) => {
    try {
      // Calculate analytics properties
      const tierName = getTierNameFromPriceId(priceId);
      const paymentMode = getPaymentMode(priceId);
      const planType = getPlanType(priceId);

      // Track checkout intent
      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_INITIATED, {
        plan_name: planName,
        tier_name: tierName,
        billing_interval: billingInterval,
        price_id: priceId,
        payment_mode: paymentMode,
        plan_type: planType,
        user_id: user?.id,
      });

      // Require authentication
      if (!user) {
        trackEvent(posthog, ANALYTICS_EVENTS.SIGNUP_ATTEMPT, {
          plan_name: planName,
          source: "pricing_checkout_redirect",
        });
        router.push("/signup?redirect=/pricing");
        return;
      }

      setLoading(priceId);

      const response = await fetch("/api/billing/checkout", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          priceId,
        }),
      });

      const data = (await response.json()) as { error?: string; url?: string };

      if (!response.ok) {
        throw new Error(data.error || "Failed to create checkout session");
      }

      // Track successful checkout session creation
      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_SESSION_CREATED, {
        plan_name: planName,
        tier_name: tierName,
        billing_interval: billingInterval,
        price_id: priceId,
        payment_mode: paymentMode,
        plan_type: planType,
        user_id: user?.id,
      });

      // Redirect to Stripe Checkout
      if (data.url) {
        window.location.href = data.url;
      }
    } catch (error) {
      console.error("Checkout error:", error);
      // Calculate analytics properties for error tracking
      const tierName = getTierNameFromPriceId(priceId);
      const paymentMode = getPaymentMode(priceId);
      const planType = getPlanType(priceId);

      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_ERROR, {
        error: error instanceof Error ? error.message : "Unknown error",
        plan_name: planName,
        tier_name: tierName,
        billing_interval: billingInterval,
        price_id: priceId,
        payment_mode: paymentMode,
        plan_type: planType,
        user_id: user?.id,
      });
      setError("Failed to start checkout. Please try again.");
      setTimeout(() => setError(null), 5000);
    } finally {
      setLoading(null);
    }
  };

  const toggleBillingInterval = () => {
    const newInterval = billingInterval === "monthly" ? "annual" : "monthly";
    setBillingInterval(newInterval);
    trackEvent(posthog, ANALYTICS_EVENTS.PRICING_PLAN_SELECTED, {
      from_interval: billingInterval,
      to_interval: newInterval,
      action: "toggle_billing",
    });
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-50 to-white">
      {/* Hero Section with Value Proposition */}
      <Section
        contained={false}
        size="xl"
        surface="brand"
        className="relative overflow-hidden bg-gradient-to-br from-blue-600 via-blue-700 to-cyan-600 text-white"
      >
        <div className="absolute inset-0 bg-grid-white/10 [mask-image:linear-gradient(0deg,transparent,rgba(255,255,255,0.1))]" />
        <Container className="relative">
          <div className="text-center">
            <h1 className="text-4xl sm:text-5xl lg:text-6xl font-bold mb-6">
              {VALUE_PROPS.mainHeadline}
            </h1>
            <p className="text-xl sm:text-2xl mb-8 text-blue-100 max-w-3xl mx-auto">
              {VALUE_PROPS.subHeadline}
            </p>

            {/* Trust Badges */}
            <div className="flex flex-wrap justify-center gap-4 sm:gap-8 mb-8">
              {VALUE_PROPS.trustBadges.map((badge) => (
                <div
                  key={badge}
                  className="flex items-center gap-2 bg-white/10 backdrop-blur-sm rounded-lg px-4 py-2"
                >
                  <CheckCircle className="h-5 w-5 text-green-400" />
                  <span className="text-sm sm:text-base font-medium">{badge}</span>
                </div>
              ))}
            </div>

            {/* Guarantees */}
            <div className="flex flex-wrap justify-center gap-6 text-sm sm:text-base mb-8">
              {VALUE_PROPS.guarantees.map((guarantee) => (
                <div key={guarantee} className="flex items-center gap-2">
                  <Shield className="h-5 w-5 text-yellow-400" />
                  <span>{guarantee}</span>
                </div>
              ))}
            </div>
          </div>
        </Container>
      </Section>

      {/* Error Alert */}
      {error && (
        <Container className="mt-6">
          <div className="rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="ml-3">
                <p className="text-sm font-medium text-red-800">{error}</p>
              </div>
            </div>
          </div>
        </Container>
      )}

      {/* Billing Toggle */}
      <Container className="mt-8 mb-10 relative z-10">
        <div className="flex justify-center">
          <div className="inline-flex items-center bg-white rounded-full shadow-lg p-1">
            <button
              onClick={() => billingInterval === "annual" && toggleBillingInterval()}
              className={cn(
                "px-6 py-3 rounded-full text-sm font-semibold transition-all duration-200",
                billingInterval === "monthly"
                  ? "bg-blue-600 text-white"
                  : "text-gray-600 hover:text-gray-900"
              )}
            >
              Monthly
            </button>
            <button
              onClick={() => billingInterval === "monthly" && toggleBillingInterval()}
              className={cn(
                "px-6 py-3 rounded-full text-sm font-semibold transition-all duration-200 flex items-center gap-2",
                billingInterval === "annual"
                  ? "bg-blue-600 text-white"
                  : "text-gray-600 hover:text-gray-900"
              )}
            >
              Annual
              {billingInterval === "annual" && (
                <Badge tone="success" variant="soft" size="sm" className="bg-emerald-700 text-white">
                  SAVE 25%
                </Badge>
              )}
            </button>
          </div>
        </div>
      </Container>

      {/* Main Pricing Cards */}
      <Section
        id="pricing-cards"
        size="lg"
        surface="subtle"
        divider="both"
      >
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 lg:gap-10">
          {SUBSCRIPTION_TIERS.map((tier) => (
            <PricingCard
              key={tier.id}
              tier={tier}
              billingInterval={billingInterval}
              onCheckout={handleCheckout}
              loading={!!loading}
              loadingId={loading}
            />
          ))}
        </div>

        {/* One-Time Exam Packages Toggle */}
        <div className="mt-16 text-center">
          <button
            onClick={() => setShowExamPackages(!showExamPackages)}
            className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-semibold"
          >
            <span>Prefer a one-time purchase? View exam packages</span>
            {showExamPackages ? (
              <ChevronUp className="h-5 w-5" />
            ) : (
              <ChevronDown className="h-5 w-5" />
            )}
          </button>
        </div>

        {/* Exam Packages Section */}
        {showExamPackages && (
          <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
            {EXAM_PACKAGES.map((pkg) => (
              <div
                key={pkg.id}
                className="border border-gray-200 rounded-lg p-6 bg-white hover:shadow-lg transition-shadow"
              >
                <h3 className="text-lg font-bold text-gray-900 mb-2">{pkg.duration}</h3>
                <div className="text-3xl font-bold text-gray-900 mb-4">${pkg.price}</div>
                <ul className="space-y-2 mb-6">
                  {pkg.features.map((feature) => (
                    <li key={feature} className="flex items-start gap-2">
                      <CheckCircle className="h-5 w-5 text-green-500 flex-shrink-0 mt-0.5" />
                      <span className="text-sm text-gray-600">{feature}</span>
                    </li>
                  ))}
                </ul>
                <button
                  onClick={() => pkg.priceId && handleCheckout(pkg.priceId, pkg.duration)}
                  disabled={!!loading || !pkg.priceId}
                  className="w-full rounded-lg bg-gray-900 px-4 py-2 text-white font-semibold hover:bg-gray-800 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Get Started
                </button>
              </div>
            ))}
          </div>
        )}
      </Section>

      {/* AI Credits Explanation */}
      <Section size="lg" surface="subtle" divider="bottom">
        <div className="mx-auto max-w-4xl">
          <div className="text-center mb-8">
            <h2 className="text-2xl font-bold text-gray-900 dark:text-slate-100 mb-4">How AI Credits Work</h2>
            <p className="text-gray-600 dark:text-slate-300">
              AI credits power our adaptive learning engine. Use them for personalized practice
              exams and detailed explanations.
            </p>
          </div>
          <div className="grid grid-cols-1 gap-6 md:grid-cols-3">
            <div
              className="rounded-lg border border-slate-200 bg-white p-6 text-center shadow-sm transition-colors dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
            >
              <Zap className="mx-auto mb-3 h-10 w-10 text-blue-600 dark:text-sky-200" />
              <h3 className="mb-2 font-semibold text-gray-900 dark:text-slate-100">Full Practice Exam</h3>
              <p className="text-2xl font-bold text-blue-600 dark:text-sky-200">{AI_CREDIT_USAGE.fullExam} Credit</p>
              <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">Complete 60-question adaptive exam</p>
            </div>
            <div
              className="rounded-lg border border-slate-200 bg-white p-6 text-center shadow-sm transition-colors dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
            >
              <TrendingUp className="mx-auto mb-3 h-10 w-10 text-blue-600 dark:text-sky-200" />
              <h3 className="mb-2 font-semibold text-gray-900 dark:text-slate-100">Domain Quiz</h3>
              <p className="text-2xl font-bold text-blue-600 dark:text-sky-200">
                {AI_CREDIT_USAGE.domainQuiz} Credit
              </p>
              <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">25-question focused practice</p>
            </div>
            <div
              className="rounded-lg border border-slate-200 bg-white p-6 text-center shadow-sm transition-colors dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100"
            >
              <Award className="mx-auto mb-3 h-10 w-10 text-blue-600 dark:text-sky-200" />
              <h3 className="mb-2 font-semibold text-gray-900 dark:text-slate-100">AI Explanation</h3>
              <p className="text-2xl font-bold text-blue-600 dark:text-sky-200">
                {AI_CREDIT_USAGE.explanation} Credit
              </p>
              <p className="mt-2 text-sm text-gray-600 dark:text-slate-300">Detailed answer explanation</p>
            </div>
          </div>
          <p className="text-center text-sm text-gray-600 dark:text-slate-300 mt-6">
            Need more credits? Purchase additional at ${AI_CREDIT_USAGE.additionalCreditPrice}
            /credit or upgrade your plan
          </p>
        </div>
      </Section>

      {/* Social Proof Section */}
      <Section size="lg" surface="default">
          <h2 className="text-3xl font-bold text-center text-gray-900 mb-12">
            Trusted by Cloud Professionals Worldwide
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            {PRICING_TESTIMONIALS.map((testimonial, index) => (
              <div key={index} className="bg-gray-50 rounded-lg p-6">
                <div className="flex mb-4">
                  {[...Array(5)].map((_, i) => (
                    <Star key={i} className="h-5 w-5 text-yellow-400 fill-current" />
                  ))}
                </div>
                <p className="text-gray-700 mb-4 italic">&ldquo;{testimonial.quote}&rdquo;</p>
                <div className="border-t pt-4">
                  <p className="font-semibold text-gray-900">{testimonial.author}</p>
                  <p className="text-sm text-gray-600">{testimonial.role}</p>
                  <p className="text-sm text-blue-600 font-medium mt-1">
                    {testimonial.tier} Customer
                  </p>
                </div>
              </div>
            ))}
          </div>
      </Section>

      {/* Feature Comparison */}
      <Section size="lg" surface="subtle" divider="bottom">
          <div className="text-center mb-12">
            <h2 className="text-3xl font-bold text-gray-900 mb-4">Compare Plans in Detail</h2>
            <button
              onClick={() => setShowComparison(!showComparison)}
              className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-semibold"
            >
              {showComparison ? "Hide" : "Show"} detailed comparison
              {showComparison ? (
                <ChevronUp className="h-5 w-5" />
              ) : (
                <ChevronDown className="h-5 w-5" />
              )}
            </button>
          </div>

          {showComparison && (
            <ComparisonTable
                categories={FEATURE_COMPARISON}
                onSelectPlan={(planId) => {
                  const element = document.getElementById("pricing-cards");
                  element?.scrollIntoView({ behavior: "smooth" });
                  // Find the matching tier and trigger checkout
                  const tier = SUBSCRIPTION_TIERS.find((t) => t.id === planId);
                  if (tier) {
                    const priceId =
                      billingInterval === "monthly" ? tier.monthlyPriceId : tier.annualPriceId;
                    if (priceId) handleCheckout(priceId, tier.name);
                  }
                }}
              />
          )}
      </Section>

      {/* FAQ Section */}
      <Section size="lg" surface="default" divider="bottom">
        <div className="mx-auto max-w-3xl">
          <h2 className="text-3xl font-bold text-center text-gray-900 mb-12">
            Frequently Asked Questions
          </h2>
          <div className="space-y-4">
            {PRICING_FAQ.map((faq, index) => (
              <div key={index} className="border border-gray-200 rounded-lg">
                <button
                  onClick={() => setOpenFaqIndex(openFaqIndex === index ? null : index)}
                  className="w-full px-6 py-4 text-left flex items-center justify-between hover:bg-gray-50 transition-colors"
                >
                  <span className="font-semibold text-gray-900">{faq.question}</span>
                  {openFaqIndex === index ? (
                    <ChevronUp className="h-5 w-5 text-gray-500" />
                  ) : (
                    <ChevronDown className="h-5 w-5 text-gray-500" />
                  )}
                </button>
                {openFaqIndex === index && (
                  <div className="px-6 pb-4">
                    <p className="text-gray-600">{faq.answer}</p>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      </Section>

      {/* Final CTA */}
      <Section
        contained={false}
        size="xl"
        surface="brand"
        divider="top"
        className="bg-gradient-to-r from-blue-600 to-cyan-600"
      >
        <Container className="max-w-4xl text-center text-white">
          <h2 className="text-3xl font-bold text-white mb-4">Ready to Pass Your Certification?</h2>
          <p className="text-xl text-blue-100 mb-8">
            Join thousands of professionals who achieved their certification goals with Testero
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button
              asChild
              size="lg"
              tone="accent"
              className="text-lg"
            >
              <Link href="/signup">Start Free Diagnostic</Link>
            </Button>
            <Button
              size="lg"
              variant="outline"
              tone="accent"
              className="text-lg"
              onClick={() => {
                const element = document.getElementById("pricing-cards");
                element?.scrollIntoView({ behavior: "smooth" });
              }}
            >
              View Pricing Plans
            </Button>
          </div>
          <div className="mt-8 flex items-center justify-center gap-2 text-white">
            <RefreshCw className="h-5 w-5" />
            <span>30-day money-back guarantee on all plans</span>
          </div>
        </Container>
      </Section>

      {/* Pricing Cards Anchor handled via Section id */}
    </div>
  );
}
</file>

<file path="app/waitlist/page.metadata.tsx">
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Join Waitlist | Testero',
  description: 'Join the waitlist for Testero, the AI-powered certification exam preparation platform.',
  openGraph: {
    title: 'Join Waitlist | Testero',
    description: 'Join the waitlist for Testero, the AI-powered certification exam preparation platform.',
    url: 'https://testero.ai/waitlist',
    siteName: 'Testero',
    locale: 'en_US',
    type: 'website',
  },
  alternates: {
    canonical: '/waitlist',
  },
};
</file>

<file path="app/waitlist/page.tsx">
"use client";

import React from 'react';
import Link from 'next/link';
import { usePostHog } from "posthog-js/react";
import { WaitlistForm } from "@/components/marketing/forms/waitlist-form";
import { motion } from "framer-motion";

const WaitlistPage = () => {
  const posthog = usePostHog(); // Get PostHog instance

  // Track page view in PostHog
  React.useEffect(() => {
    if (posthog) {
      posthog.capture('waitlist_page_viewed');
    }
  }, [posthog]);

  return (
    <div className="min-h-screen pt-24 pb-12 md:pt-32 flex flex-col items-center justify-start bg-gradient-to-b from-slate-50 to-slate-100">
      <div className="w-full max-w-2xl px-6">
        {/* Card Container */}
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="bg-white shadow-lg rounded-xl border border-slate-200 overflow-hidden"
        >
          {/* Header */}
          <div className="px-6 md:px-10 py-8 md:py-10 text-center border-b border-slate-200 bg-gradient-to-r from-slate-50 to-slate-100">
            <h1 className="text-2xl md:text-3xl font-bold text-slate-800 mb-4">Join the Testero Waitlist</h1>
            <p className="text-slate-600 md:text-lg max-w-xl mx-auto">
              Get early access to our AI-powered learning platform for cloud certification exams. Sign up now to secure your spot and a <span className="font-medium text-orange-600 bg-orange-50 px-2 py-1 rounded">30% lifetime discount</span>.
            </p>
          </div>

          {/* Form Container */}
          <div className="px-6 md:px-10 py-8 md:py-10">
            <div className="max-w-md mx-auto">
              <div className="grid gap-8">
                {/* Benefits List */}
                <div className="bg-blue-50 rounded-lg p-5 border border-blue-100">
                  <h3 className="font-semibold text-blue-800 mb-3 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5 mr-2">
                      <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Waitlist Benefits
                  </h3>
                  <ul className="space-y-2 text-blue-700">
                    <li className="flex items-start">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 mt-0.5 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                      </svg>
                      <span>Priority access to our beta launch (July 2025)</span>
                    </li>
                    <li className="flex items-start">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 mt-0.5 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                      </svg>
                      <span>30% lifetime discount on Pro subscription</span>
                    </li>
                    <li className="flex items-start">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 mt-0.5 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                      </svg>
                      <span>Opportunity to provide feedback and shape the platform</span>
                    </li>
                    <li className="flex items-start">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 mt-0.5 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                      </svg>
                      <span>Early access to new features and updates</span>
                    </li>
                  </ul>
                </div>

                {/* Waitlist Form */}
                <div>
                  <h3 className="font-medium text-slate-700 mb-3 text-center">Enter your email to secure your spot:</h3>
                  <WaitlistForm 
                    buttonText="Join the Waitlist" 
                    ctaLocation="waitlist_page" 
                    includeExamDropdown={true}
                  />
                </div>
              </div>
            </div>
          </div>
        </motion.div>

        {/* FAQ Preview */}
        <div className="mt-10 text-center">
          <h2 className="text-xl font-semibold text-slate-800 mb-4">Frequently Asked Questions</h2>
          <div className="bg-white p-5 rounded-lg shadow-md border border-slate-200 mb-6">
            <h3 className="font-medium text-slate-700 mb-2">When will Testero launch?</h3>
            <p className="text-slate-600">Testero will be launched as a private beta in July 2025, with priority access for waitlist members. The public launch is scheduled for Q4 2025.</p>
          </div>
          <div className="bg-white p-5 rounded-lg shadow-md border border-slate-200 mb-6">
            <h3 className="font-medium text-slate-700 mb-2">Which certification exams will be supported?</h3>
            <p className="text-slate-600">At launch, we&apos;ll support Google Cloud (GCP), AWS, and Microsoft Azure certification exams, with more platforms being added based on user demand.</p>
          </div>
          <Link 
            href="/faq" 
            className="text-orange-500 hover:text-orange-600 transition-colors font-medium flex items-center justify-center"
          >
            <span>View all FAQs</span>
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </Link>
        </div>

        {/* Already have an account link */}
        <div className="mt-8 text-center">
          <p className="text-slate-600">
            Already have an account?{' '}
            <Link 
              href="/login" 
              className="text-orange-500 hover:text-orange-600 transition-colors font-medium"
            >
              Sign in
            </Link>
          </p>
        </div>
      </div>

      {/* Visual Decoration */}
      <div className="absolute inset-0 opacity-10 pointer-events-none" aria-hidden="true">
        <div className="absolute top-0 left-1/4 w-64 h-64 rounded-full bg-blue-500 mix-blend-multiply blur-3xl"></div>
        <div className="absolute bottom-0 right-1/4 w-64 h-64 rounded-full bg-orange-500 mix-blend-multiply blur-3xl"></div>
      </div>
    </div>
  );
};

export default WaitlistPage;
</file>

<file path="components/billing/TrialConversionModal.tsx">
"use client";

import React, { useState } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/components/providers/AuthProvider";
import { usePostHog } from "posthog-js/react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { CheckCircle, Zap, TrendingUp } from "lucide-react";

interface TrialConversionModalProps {
  open: boolean;
  onClose: () => void;
  diagnosticScore?: number;
  weakAreas?: string[];
}

export function TrialConversionModal({
  open,
  onClose,
  diagnosticScore = 0,
  weakAreas = [],
}: TrialConversionModalProps) {
  const router = useRouter();
  const { user } = useAuth();
  const posthog = usePostHog();
  const [isLoading, setIsLoading] = useState(false);

  const handleStartTrial = async () => {
    try {
      setIsLoading(true);

      // Track trial CTA click
      posthog?.capture("trial_cta_clicked", {
        source: "diagnostic_summary_modal",
        diagnostic_score: diagnosticScore,
        weak_areas: weakAreas,
      });

      // If not logged in, redirect to signup
      if (!user) {
        router.push("/signup?redirect=/api/billing/trial&source=diagnostic");
        return;
      }

      // Start trial via API
      const response = await fetch("/api/billing/trial", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      const data = await response.json();

      if (!response.ok) {
        console.error("Trial API error:", data);
        throw new Error(data.error || "Failed to start trial");
      }

      // Track successful trial start
      posthog?.capture("trial_started_from_modal", {
        trial_ends_at: data.trialEndsAt,
        subscription_id: data.subscriptionId,
      });

      // Redirect to dashboard
      router.push("/dashboard?trial=started");
    } catch (error) {
      console.error("Error starting trial:", error);
      // Could show error toast here
    } finally {
      setIsLoading(false);
    }
  };

  // Personalized headline based on score
  const getHeadline = () => {
    if (diagnosticScore < 40) {
      return "Build a Strong Foundation";
    } else if (diagnosticScore < 70) {
      return "Bridge the Gap to Success";
    } else {
      return "Perfect Your Performance";
    }
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="text-2xl font-bold">{getHeadline()}</DialogTitle>
          <DialogDescription className="text-base mt-2">
            Start your 14-day free trial and unlock your personalized study path
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Value Props */}
          <div className="space-y-3">
            <div className="flex items-start gap-3">
              <CheckCircle className="h-5 w-5 text-green-500 mt-0.5" />
              <div>
                <p className="font-medium">Personalized Study Plan</p>
                <p className="text-sm text-gray-600">
                  AI-powered path based on your diagnostic results
                </p>
              </div>
            </div>

            <div className="flex items-start gap-3">
              <Zap className="h-5 w-5 text-yellow-500 mt-0.5" />
              <div>
                <p className="font-medium">Unlimited Practice Questions</p>
                <p className="text-sm text-gray-600">2,000+ questions updated weekly</p>
              </div>
            </div>

            <div className="flex items-start gap-3">
              <TrendingUp className="h-5 w-5 text-blue-500 mt-0.5" />
              <div>
                <p className="font-medium">Pass Rate Guarantee</p>
                <p className="text-sm text-gray-600">92% first-attempt pass rate</p>
              </div>
            </div>
          </div>

          {/* Urgency Element */}
          <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
            <p className="text-sm text-amber-800">
              <strong>Limited time offer:</strong> Start today and get 30% off your first month
              after trial
            </p>
          </div>

          {/* CTAs */}
          <div className="flex flex-col gap-2">
            <Button
              onClick={handleStartTrial}
              disabled={isLoading}
              size="lg"
              tone="accent"
              fullWidth
            >
              {isLoading ? "Starting..." : "Start 14-Day Free Trial"}
            </Button>
            <Button onClick={onClose} variant="ghost" tone="neutral" size="sm" fullWidth>
              Maybe later
            </Button>
          </div>

          {/* Trust Signal */}
          <p className="text-xs text-center text-gray-500">
            No credit card required  Cancel anytime
          </p>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/patterns/__tests__/section.test.tsx">
import { render } from "@testing-library/react"

import { Section } from "../section"

describe("Section", () => {
  it("renders with default variants and container", () => {
    const { container } = render(<Section>Content</Section>)

    const section = container.querySelector("section")
    expect(section).toBeInTheDocument()
    expect(section).toHaveClass("bg-surface")

    const inner = section?.querySelector(":scope > div")
    expect(inner).toHaveClass("py-section_lg")

    const contained = inner?.firstElementChild as HTMLElement | null
    expect(contained).toHaveClass("mx-auto")
    expect(contained?.textContent).toBe("Content")
  })

  it("supports variant overrides and uncontained layout", () => {
    const { container } = render(
      <Section
        as="article"
        size="sm"
        surface="muted"
        divider="both"
        contained={false}
        className="custom"
      >
        <p>Inner content</p>
      </Section>,
    )

    const section = container.querySelector("article")
    expect(section).toBeInTheDocument()
    expect(section).toHaveClass("bg-surface-muted", "border-y", "border-divider", "custom")

    const inner = section?.querySelector(":scope > div")
    expect(inner).toHaveClass("py-section_sm")

    const contained = inner?.firstElementChild as HTMLElement | null
    expect(contained).not.toHaveClass("mx-auto")
    expect(contained?.tagName.toLowerCase()).toBe("p")
  })
})
</file>

<file path="components/patterns/container.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { Container, type ContainerProps } from "./Container"

const meta: Meta<typeof Container> = {
  title: "Patterns/Container",
  component: Container,
  parameters: {
    docs: {
      description: {
        component:
          "Tokenised width wrapper that centers content and applies responsive horizontal padding consistent with the design system.",
      },
    },
  },
  argTypes: {
    as: { control: false },
    className: { control: false },
    children: { control: false },
    size: {
      control: { type: "inline-radio" },
      options: ["sm", "md", "lg", "xl", "2xl", "full"],
    },
  },
  args: {
    size: "xl",
  },
}

export default meta

type Story = StoryObj<typeof meta>

const Placeholder = ({ label }: { label: string }) => (
  <div className="rounded-lg border border-dashed border-border bg-muted/40 p-6 text-sm text-muted-foreground">
    {label}
  </div>
)

export const Playground: Story = {
  render: (args: ContainerProps) => (
    <div className="space-y-6 bg-surface/60 py-10">
      <Container {...args}>
        <Placeholder label={`Container size: ${args.size ?? "xl"}`} />
      </Container>
    </div>
  ),
}

export const CustomElement: Story = {
  args: {
    as: "section",
    size: "lg",
  },
  render: (args: ContainerProps<"section">) => (
    <div className="space-y-6 bg-surface/60 py-10">
      <Container {...args}>
        <Placeholder label="Rendered as a semantic <section> element" />
      </Container>
    </div>
  ),
}
</file>

<file path="components/patterns/Container.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

type ContainerSize = "sm" | "md" | "lg" | "xl" | "2xl" | "full"

const sizeClass: Record<ContainerSize, string> = {
  sm: "max-w-screen-sm",
  md: "max-w-screen-md",
  lg: "max-w-screen-lg",
  xl: "max-w-7xl",
  "2xl": "max-w-screen-2xl",
  full: "w-full",
}

type PolymorphicProps<T extends keyof JSX.IntrinsicElements> = {
  as?: T
  size?: ContainerSize
  className?: string
  children?: React.ReactNode
} & Omit<JSX.IntrinsicElements[T], "className" | "children">

export type ContainerProps<T extends keyof JSX.IntrinsicElements = "div"> =
  PolymorphicProps<T>

export function Container<T extends keyof JSX.IntrinsicElements = "div">(
  props: ContainerProps<T>,
) {
  const { as, size = "xl", className, children, ...rest } = props
  const Comp = (as ?? "div") as React.ElementType
  const widthClass = sizeClass[size]

  return (
    <Comp
      className={cn("mx-auto px-4 sm:px-6 lg:px-8", widthClass, className)}
      {...rest}
    >
      {children}
    </Comp>
  )
}
</file>

<file path="components/patterns/index.ts">
export * from "./Container"
export * from "./section"
</file>

<file path="components/patterns/section.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import type { FC } from "react"

import { Button } from "@/components/ui/button"

import { Section, type SectionProps } from "./section"

const SectionStoryComponent: FC<SectionProps> = (props) => <Section {...props} />

const meta: Meta<typeof SectionStoryComponent> = {
  title: "Patterns/Section",
  component: SectionStoryComponent,
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "Reusable layout primitive that standardises vertical rhythm, background surfaces, and optional dividers.",
      },
    },
  },
  args: {
    size: "lg",
    surface: "default",
    divider: "none",
    contained: true,
  },
  argTypes: {
    size: {
      control: { type: "inline-radio" },
      options: ["sm", "md", "lg", "xl"],
    },
    surface: {
      control: { type: "select" },
      options: ["default", "subtle", "muted", "elevated", "brand"],
    },
    divider: {
      control: { type: "inline-radio" },
      options: ["none", "top", "bottom", "both"],
    },
    contained: {
      control: { type: "boolean" },
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Playground: Story = {
  render: (args) => (
    <Section {...args}>
      <div className="space-y-6">
        <div className="max-w-2xl space-y-3">
          <h2 className="text-3xl font-semibold tracking-tight">Consistent rhythm</h2>
          <p className="text-muted-foreground">
            Use semantic spacing, surfaces, and dividers to maintain predictable vertical rhythm across pages. Toggle the
            controls to preview each variant, including dark mode via the toolbar theme switcher.
          </p>
        </div>
        <div className="flex flex-wrap gap-4">
          <Button size="lg">Primary action</Button>
          <Button size="lg" variant="outline">
            Secondary
          </Button>
        </div>
      </div>
    </Section>
  ),
}

export const FullBleed: Story = {
  args: {
    contained: false,
    surface: "brand",
    size: "xl",
    divider: "both",
  },
  render: (args) => (
    <Section {...args} className="overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-br from-accent via-info to-info/90 opacity-90" />
      <div className="relative">
        <div className="py-section_lg">
          <div className="mx-auto max-w-4xl px-4 sm:px-6 lg:px-8 text-center text-accent-foreground">
            <h2 className="text-4xl font-bold tracking-tight">Full-bleed hero</h2>
            <p className="mt-4 text-lg text-foreground/90">
              Combine the Section primitive with your own layout primitives for wide experiences while preserving rhythm and
              divider tokens.
            </p>
          </div>
        </div>
      </div>
    </Section>
  ),
  parameters: {
    backgrounds: { default: "dark" },
  },
}
</file>

<file path="components/patterns/section.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

import { Container } from "./Container"

const outer = cva("relative w-full", {
  variants: {
    surface: {
      default: "bg-surface",
      subtle: "bg-surface-subtle",
      muted: "bg-surface-muted",
      elevated: "bg-surface-elevated shadow-sm",
      brand: "bg-surface-brand",
    },
    divider: {
      none: "",
      top: "border-t border-divider",
      bottom: "border-b border-divider",
      both: "border-y border-divider",
    },
  },
  defaultVariants: { surface: "default", divider: "none" },
})

const inner = cva("w-full", {
  variants: {
    size: {
      sm: "py-section_sm",
      md: "py-section_md",
      lg: "py-section_lg",
      xl: "py-section_xl",
    },
  },
  defaultVariants: { size: "lg" },
})

type SectionElement =
  | "section"
  | "div"
  | "header"
  | "footer"
  | "main"
  | "article"
  | "aside"

export type SectionProps<T extends SectionElement = "section"> = {
  as?: T
  contained?: boolean
  className?: string
  children?: React.ReactNode
} & VariantProps<typeof outer> &
  VariantProps<typeof inner> &
  Omit<React.ComponentPropsWithoutRef<T>, "as" | "className" | "children">

type SectionComponent = <T extends SectionElement = "section">(
  props: SectionProps<T> & { ref?: React.Ref<React.ElementRef<T>> },
) => React.ReactElement | null

const SectionBase = React.forwardRef(
  <T extends SectionElement = "section">(
    props: SectionProps<T>,
    ref: React.Ref<React.ElementRef<T>>,
  ) => {
    const {
      as,
      surface,
      divider,
      size,
      contained = true,
      className,
      children,
      ...rest
    } = props

    const Component = (as ?? "section") as React.ElementType

    return (
      <Component
        ref={ref}
        className={cn(outer({ surface, divider }), className)}
        {...rest}
      >
        <div className={cn(inner({ size }))}>
          {contained ? (
            <Container className="py-6 md:py-8">{children}</Container>
          ) : (
            <div className="py-6 md:py-8">{children}</div>
          )}
        </div>
      </Component>
    )
  },
)

SectionBase.displayName = "Section"

export const Section = SectionBase as SectionComponent
</file>

<file path="components/pricing/ComparisonTable.tsx">
"use client";

import React from "react";
import { Check, X } from "lucide-react";
import { cn } from "@/lib/utils";

interface Feature {
  name: string;
  basic: string | boolean;
  pro: string | boolean;
  allAccess: string | boolean;
}

interface FeatureCategory {
  category: string;
  features: Feature[];
}

interface ComparisonTableProps {
  categories: FeatureCategory[];
  onSelectPlan?: (planId: string) => void;
}

export function ComparisonTable({ categories, onSelectPlan }: ComparisonTableProps) {
  const renderFeatureValue = (value: string | boolean) => {
    if (typeof value === "boolean") {
      return value ? (
        <Check className="h-5 w-5 text-green-500 mx-auto" />
      ) : (
        <X className="h-5 w-5 text-gray-300 mx-auto" />
      );
    }
    return <span className="text-sm text-gray-900">{value}</span>;
  };

  return (
    <div className="overflow-hidden rounded-xl border border-gray-200 bg-white shadow-lg">
      {/* Desktop Table */}
      <div className="hidden lg:block">
        <table className="w-full">
          <thead>
            <tr className="border-b border-gray-200 bg-gray-50">
              <th className="px-6 py-4 text-left text-sm font-semibold text-gray-900">Features</th>
              <th className="px-6 py-4 text-center">
                <div className="space-y-1">
                  <div className="text-lg font-bold text-gray-900">Basic</div>
                  <div className="text-sm text-gray-600">$39/month</div>
                  {onSelectPlan && (
                    <button
                      onClick={() => onSelectPlan("basic")}
                      className="mt-2 rounded-md bg-gray-100 px-4 py-1.5 text-sm font-medium text-gray-700 hover:bg-gray-200 transition-colors"
                    >
                      Select Basic
                    </button>
                  )}
                </div>
              </th>
              <th className="px-6 py-4 text-center bg-blue-50">
                <div className="space-y-1">
                  <div className="flex items-center justify-center gap-2">
                    <div className="text-lg font-bold text-gray-900">Pro</div>
                    <span className="rounded-full bg-blue-500 px-2 py-0.5 text-xs font-semibold text-white">
                      POPULAR
                    </span>
                  </div>
                  <div className="text-sm text-gray-600">$59/month</div>
                  {onSelectPlan && (
                    <button
                      onClick={() => onSelectPlan("pro")}
                      className="mt-2 rounded-md bg-blue-600 px-4 py-1.5 text-sm font-medium text-white hover:bg-blue-700 transition-colors"
                    >
                      Select Pro
                    </button>
                  )}
                </div>
              </th>
              <th className="px-6 py-4 text-center">
                <div className="space-y-1">
                  <div className="text-lg font-bold text-gray-900">All-Access</div>
                  <div className="text-sm text-gray-600">$79/month</div>
                  {onSelectPlan && (
                    <button
                      onClick={() => onSelectPlan("all-access")}
                      className="mt-2 rounded-md bg-gray-900 px-4 py-1.5 text-sm font-medium text-white hover:bg-gray-800 transition-colors"
                    >
                      Select All-Access
                    </button>
                  )}
                </div>
              </th>
            </tr>
          </thead>
          <tbody>
            {categories.map((category) => (
              <React.Fragment key={category.category}>
                <tr className="border-t-2 border-gray-200">
                  <td
                    colSpan={4}
                    className="bg-gray-50 px-6 py-3 text-sm font-semibold text-gray-900"
                  >
                    {category.category}
                  </td>
                </tr>
                {category.features.map((feature, featureIndex) => (
                  <tr
                    key={feature.name}
                    className={cn(
                      "border-t border-gray-100",
                      featureIndex % 2 === 0 ? "bg-white" : "bg-gray-50/50"
                    )}
                  >
                    <td className="px-6 py-4 text-sm text-gray-700">{feature.name}</td>
                    <td className="px-6 py-4 text-center">{renderFeatureValue(feature.basic)}</td>
                    <td className="px-6 py-4 text-center bg-blue-50/30">
                      {renderFeatureValue(feature.pro)}
                    </td>
                    <td className="px-6 py-4 text-center">
                      {renderFeatureValue(feature.allAccess)}
                    </td>
                  </tr>
                ))}
              </React.Fragment>
            ))}
          </tbody>
        </table>
      </div>

      {/* Mobile Cards */}
      <div className="lg:hidden">
        <div className="border-b border-gray-200 bg-gray-50 p-4">
          <h3 className="text-lg font-semibold text-gray-900">Feature Comparison</h3>
        </div>
        <div className="divide-y divide-gray-200">
          {categories.map((category) => (
            <div key={category.category} className="p-4">
              <h4 className="mb-4 text-sm font-semibold text-gray-900">{category.category}</h4>
              {category.features.map((feature) => (
                <div key={feature.name} className="mb-4 last:mb-0">
                  <div className="mb-2 text-sm font-medium text-gray-700">{feature.name}</div>
                  <div className="grid grid-cols-3 gap-2 text-center">
                    <div className="rounded-lg bg-gray-50 p-2">
                      <div className="text-xs font-medium text-gray-600 mb-1">Basic</div>
                      {renderFeatureValue(feature.basic)}
                    </div>
                    <div className="rounded-lg bg-blue-50 p-2">
                      <div className="text-xs font-medium text-blue-600 mb-1">Pro</div>
                      {renderFeatureValue(feature.pro)}
                    </div>
                    <div className="rounded-lg bg-gray-50 p-2">
                      <div className="text-xs font-medium text-gray-600 mb-1">All-Access</div>
                      {renderFeatureValue(feature.allAccess)}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/pricing/PricingCard.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { PricingCard } from "./PricingCard"

const baseTier = {
  id: "starter",
  name: "Starter",
  description: "Essentials for individual learners preparing for Testero exams.",
  monthlyPrice: 29,
  annualPrice: 290,
  monthlyPriceId: "price_monthly",
  annualPriceId: "price_annual",
  aiCredits: 200,
  features: [
    "Adaptive practice exams",
    "Weekly study plan",
    "Email reminders",
  ],
  highlighted: ["Exam-day readiness checklist"],
  recommended: false,
  savingsPercentage: 20,
}

const recommendedTier = {
  ...baseTier,
  id: "pro",
  name: "Pro",
  monthlyPrice: 59,
  annualPrice: 590,
  aiCredits: 500,
  highlighted: ["1:1 readiness review", "Priority question support"],
  features: [...baseTier.features, "Live cohort workshops"],
  recommended: true,
  savingsPercentage: 25,
}

const meta: Meta<typeof PricingCard> = {
  title: "Pricing/PricingCard",
  component: PricingCard,
  args: {
    billingInterval: "monthly",
    loading: false,
    loadingId: null,
    onCheckout: (priceId: string, tierName: string) => {
      console.log(`Checkout  ${tierName} (${priceId})`)
    },
  },
  argTypes: {
    billingInterval: {
      control: { type: "inline-radio" },
      options: ["monthly", "annual"],
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Monthly: Story = {
  args: {
    tier: baseTier,
  },
}

export const AnnualRecommended: Story = {
  args: {
    tier: recommendedTier,
    billingInterval: "annual",
  },
}
</file>

<file path="components/pricing/PricingCard.tsx">
"use client";

import React from "react";
import { CheckCircle, Sparkles, TrendingUp } from "lucide-react";

import { Badge } from "@/components/ui/badge";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface PricingCardProps {
  tier: {
    id: string;
    name: string;
    description: string;
    monthlyPrice: number;
    annualPrice: number;
    monthlyPriceId?: string;
    annualPriceId?: string;
    aiCredits: number;
    features: string[];
    highlighted?: string[];
    recommended?: boolean;
    savingsPercentage?: number;
  };
  billingInterval: "monthly" | "annual";
  onCheckout: (priceId: string, tierName: string) => void;
  loading?: boolean;
  loadingId?: string | null;
}

export function PricingCard({
  tier,
  billingInterval,
  onCheckout,
  loading = false,
  loadingId = null,
}: PricingCardProps) {
  const price = billingInterval === "monthly" ? tier.monthlyPrice : tier.annualPrice;
  const priceId = billingInterval === "monthly" ? tier.monthlyPriceId : tier.annualPriceId;
  const checkoutPriceId = priceId ?? `${tier.id}-${billingInterval}`;
  const isCheckoutConfigured = Boolean(priceId);
  const isLoading = loading && loadingId === priceId;
  const monthlyEquivalent = billingInterval === "annual" ? Math.round(tier.annualPrice / 12) : null;

  return (
    <Card
      data-recommended={tier.recommended ? "true" : undefined}
      variant={tier.recommended ? "elevated" : "default"}
      size="lg"
      className={cn(
        "relative w-full",
        tier.recommended
          ? "border-accent/50 ring-2 ring-accent/25"
          : "border-border/60",
        billingInterval === "annual" && tier.savingsPercentage ? "pt-6" : ""
      )}
    >
      {tier.recommended ? (
        <div className="absolute inset-x-0 -top-4 flex justify-center">
          <Badge
            tone="accent"
            variant="solid"
            icon={<Sparkles className="h-4 w-4" aria-hidden="true" />}
            className="shadow-lg"
          >
            Most popular
          </Badge>
        </div>
      ) : null}

      {billingInterval === "annual" && tier.savingsPercentage ? (
        <div className={cn(
          "absolute right-6",
          tier.recommended ? "top-12" : "top-6"
        )}>
          <Badge
            tone="success"
            variant="soft"
            size="sm"
            className="shadow-sm bg-emerald-700 text-white"
          >
            Save {tier.savingsPercentage}%
          </Badge>
        </div>
      ) : null}

      <CardHeader className="gap-2">
        <CardTitle className="text-3xl font-semibold text-foreground">
          {tier.name}
        </CardTitle>
        <CardDescription>{tier.description}</CardDescription>
      </CardHeader>

      <CardContent className="gap-6">
        <div className="space-y-3">
          <div className="flex items-baseline gap-2">
            <span className="text-5xl font-semibold tracking-tight text-foreground">
              ${price}
            </span>
            <span className="text-lg text-muted-foreground">
              /{billingInterval === "monthly" ? "month" : "year"}
            </span>
          </div>
          {monthlyEquivalent ? (
            <p className="text-sm text-muted-foreground">
              That&apos;s only ${monthlyEquivalent}/month
            </p>
          ) : null}
          <div className="flex items-center gap-2 text-sm font-medium text-accent-foreground">
            <TrendingUp className="h-4 w-4" aria-hidden="true" />
            {tier.aiCredits} AI credits included monthly
          </div>
        </div>

        {tier.highlighted && tier.highlighted.length > 0 ? (
          <div className="space-y-2 rounded-lg border border-accent/30 bg-accent/5 p-4 md:p-6">
            {tier.highlighted.map((feature) => (
              <div key={feature} className="flex items-center gap-2">
                <CheckCircle className="h-5 w-5 flex-shrink-0 text-accent" aria-hidden="true" />
                <span className="text-sm font-medium text-foreground">{feature}</span>
              </div>
            ))}
          </div>
        ) : null}

        <ul className="space-y-3">
          {tier.features.map((feature) => (
            <li key={feature} className="flex items-start gap-3 text-sm text-muted-foreground">
              <CheckCircle className="mt-0.5 h-5 w-5 flex-shrink-0 text-success" aria-hidden="true" />
              <span>{feature}</span>
            </li>
          ))}
        </ul>
      </CardContent>

      <CardFooter className="flex-col items-stretch gap-3 border-0 pt-0">
        <Button
          fullWidth
          tone={tier.recommended ? "accent" : "neutral"}
          variant="solid"
          size="lg"
          loading={isLoading}
          disabled={isLoading || !isCheckoutConfigured}
          data-checkout-configured={isCheckoutConfigured ? "true" : "false"}
          onClick={() => onCheckout(checkoutPriceId, tier.name)}
        >
          Get started
        </Button>

        {tier.recommended ? (
          <p className="text-center text-xs text-muted-foreground">
            Chosen by 73% of our users
          </p>
        ) : null}
      </CardFooter>
    </Card>
  );
}
</file>

<file path="components/providers/AuthProvider.tsx">
"use client";

import React, { createContext, useContext, useEffect, useState } from "react";
import { supabase } from "@/lib/supabase/client";
import type { Session, User } from "@supabase/supabase-js";
import { usePostHog } from "posthog-js/react";

type AuthContextType = {
  session: Session | null;
  user: User | null;
  isLoading: boolean;
  signOut: () => Promise<void>;
  refreshSession: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Route protection is now handled by middleware

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const posthog = usePostHog();

  useEffect(() => {
    const fetchSession = async () => {
      try {
        // Get the initial session
        const { data, error } = await supabase.auth.getSession();

        if (error) {
          console.error("Error fetching session:", error.message);
        }

        handleSessionChange(data.session);
      } catch (err) {
        console.error("Unexpected error during session fetch:", err);
      } finally {
        setIsLoading(false);
      }
    };

    // Initial session fetch
    fetchSession();

    // Subscribe to auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      handleSessionChange(session);
    });

    return () => {
      subscription.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);


  const handleSessionChange = (newSession: Session | null) => {
    setSession(newSession);
    setUser(newSession?.user || null);

    // Identify user in PostHog when session changes
    if (newSession?.user && posthog) {
      // Identify the user with their ID
      posthog.identify(newSession.user.id, {
        email: newSession.user.email,
        created_at: newSession.user.created_at,
        is_early_access: newSession.user.user_metadata?.is_early_access === true,
        email_confirmed: !!newSession.user.email_confirmed_at,
        // Add any other user metadata that might be useful
        provider: newSession.user.app_metadata?.provider || "email",
      });

      // Track successful login/session restoration
      posthog.capture("user_session_started", {
        session_type: "authenticated",
        user_id: newSession.user.id,
      });
    } else if (!newSession && posthog) {
      // Reset PostHog when user logs out
      posthog.reset();

      // Track logout
      posthog.capture("user_session_ended", {
        session_type: "logged_out",
      });
    }
  };

  const signOut = async () => {
    try {
      setIsLoading(true);
      const { error } = await supabase.auth.signOut();
      if (error) throw error;

      // Clear the session state
      setSession(null);
      setUser(null);

      // Redirect will be handled by middleware
      window.location.href = "/login";
    } catch (error) {
      console.error("Error signing out:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const refreshSession = async () => {
    try {
      setIsLoading(true);
      const { data, error } = await supabase.auth.refreshSession();

      if (error) throw error;

      handleSessionChange(data.session);
    } catch (error) {
      console.error("Error refreshing session:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AuthContext.Provider value={{ session, user, isLoading, signOut, refreshSession }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
</file>

<file path="components/ui/__stories__/docs/EmptyState.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as EmptyStateStories from "../EmptyState.stories"

<Meta of={EmptyStateStories} title="Design System/EmptyState/Docs" />

# EmptyState

EmptyState communicates absence, loading, or error scenarios using consistent iconography, copy, and actions.

## When to use

- A collection has no data yet (first-run experience).
- A filter removes every result and we need to explain next steps.
- A recoverable error occurs and the user can retry or learn more.

## Usage

```tsx
import { EmptyState } from "@/components/ui"
import { Inbox } from "lucide-react"

export function NoSessions() {
  return (
    <EmptyState
      tone="info"
      icon={<Inbox aria-hidden="true" className="size-6" />}
      statusLabel="No sessions"
      title="You're all caught up"
      description="Start a new diagnostic session or import historic runs to compare trends."
      primaryAction={{ label: "Start session", onClick: () => console.log("start") }}
      secondaryAction={{ label: "Import CSV", onClick: () => console.log("import") }}
    />
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={EmptyStateStories.Neutral} />

## Do

- Tailor the headline to be outcome oriented (e.g. "Start your first experiment").
- Pair status icons with `statusLabel` so color is never the only cue.
- Keep descriptions short (two sentences max) and actionable.

## Don't

- Use destructive tone for empty resultsreserve it for actual failures.
- Stack more than two call-to-action buttons; link secondary tasks elsewhere.
- Leave the icon as the only focusable elementactions must be keyboard reachable.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/docs/PageHeader.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as PageHeaderStories from "../PageHeader.stories"

<Meta of={PageHeaderStories} title="Design System/PageHeader/Docs" />

# PageHeader

The PageHeader provides a consistent hero block for authenticated layouts. It aligns breadcrumbs, titles, descriptions, and quick actions so that every view opens with a predictable rhythm.

## When to use

- Introduce a new product surface or dashboard route.
- Provide contextual breadcrumbs and supporting copy above a dense layout.
- Pair with tabs or filters that live directly beneath the header.

Avoid using PageHeader for inline sections inside a pageprefer stacked `Card` components instead.

## Usage

```tsx
import { PageHeader, Button } from "@/components/ui"

export function ExperimentsHeader() {
  return (
    <PageHeader
      tone="muted"
      align="between"
      breadcrumbs={[
        { label: "Dashboard", href: "/app" },
        { label: "Experiments" },
      ]}
      title="Experiment overview"
      description="Compare how each test is trending and notify collaborators when an action is needed."
      actions={
        <div className="flex gap-2">
          <Button variant="ghost" tone="neutral">
            Share report
          </Button>
          <Button tone="accent">New experiment</Button>
        </div>
      }
    />
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={PageHeaderStories.Default} />

## Do

- Keep titles conciseone line is ideal and two lines is the maximum.
- Use `tone="muted"` when the page background needs subtle separation from the canvas.
- Switch `density="compact"` when the header sits above tables or forms.

## Don't

- Nest PageHeaders inside cards or modals.
- Combine more than three breadcrumb levels; collapse intermediate destinations instead.
- Place destructive actions (like delete) in the primary action slotprefer menus.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/docs/Table.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as TableStories from "../Table.stories"

<Meta of={TableStories} title="Design System/Table/Docs" />

# Table

Table renders accessible tabular data with sortable headers, zebra striping, and empty/loading states.

## When to use

- Display structured datasets such as experiments, billing history, or feature flags.
- Allow operators to sort by key metrics like status or conversion rate.
- Embed contextual empty states when a dataset has no rows.

## Usage

```tsx
import { Table } from "@/components/ui"

const columns = [
  { id: "name", header: "Study", sortable: true },
  { id: "moderator", header: "Moderator" },
  { id: "status", header: "Status" },
  { id: "lastRun", header: "Last run", sortable: true },
]

const data = [
  { id: "study-1", name: "GenAI onboarding", moderator: "Priya", status: "Running", lastRun: "Mar 12" },
  { id: "study-2", name: "Pricing survey", moderator: "Noah", status: "Draft", lastRun: "Mar 4" },
]

export function StudiesTable() {
  return (
    <Table
      columns={columns}
      data={data}
      caption="Current usability studies and moderators"
      onSortChange={(columnId, direction) => {
        // Update data ordering upstream when the user sorts.
      }}
    />
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={TableStories.InteractiveSorting} />

## Do

- Provide a `caption` for screen readers even if you hide it visually.
- Keep numeric columns right-aligned so magnitudes are easy to compare.
- Use the `emptyState` prop to show recovery guidance when there are zero rows.

## Don't

- Hide critical context in tooltips; keep key values visible.
- Overload headers with long sentencesuse concise nouns or verbs.
- Enable sorting on columns that render badges or custom JSX without a clear ordering.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/docs/Toast.mdx">
import { Controls, Meta, Primary, Props, Stories } from "@storybook/blocks"
import * as ToastStories from "../Toast.stories"

<Meta of={ToastStories} title="Design System/Toast/Docs" />

# Toast

Toast surfaces transient notifications without interrupting the current workflow.

## When to use

- Confirm that a background task completed (save, export, sync).
- Warn users about degraded performance while recovery continues.
- Offer an undo affordance shortly after an action.

## Usage

```tsx
import { Toast, useToastQueue } from "@/components/ui"

export function ToastManager() {
  const { toasts, addToast, dismissToast } = useToastQueue()

  return (
    <div>
      <button
        className="rounded-md bg-primary px-3 py-2 text-primary-foreground"
        onClick={() =>
          addToast({
            tone: "success",
            title: "Report exported",
            description: "We emailed the download link to you.",
            dismissible: true,
          })
        }
      >
        Trigger toast
      </button>

      <div className="mt-4 flex flex-col gap-3">
        {toasts.map(({ id, ...toast }) => (
          <Toast key={id} {...toast} onClose={() => dismissToast(id)} />
        ))}
      </div>
    </div>
  )
}
```

## Component API

<Primary />
<Controls />
<Props of={ToastStories.Info} />

## Do

- Set `tone` based on semantic meaning: `success` for confirmations, `warning` for recoverable risks, `danger` for critical issues.
- Provide meaningful button labels (e.g. "View report" instead of "OK").
- Respect reduced motion preferencesthe component removes transitions automatically.

## Don't

- Queue more than three toasts at once; collapse or replace older messages instead.
- Use toast for blocking confirmationsuse a modal or inline banner instead.
- Leave a toast dismissible without also wiring an `onClose` handler.

<Stories includePrimary={false} />
</file>

<file path="components/ui/__stories__/Badge.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { Badge, type BadgeProps } from "../badge"

const meta: Meta<typeof Badge> = {
  title: "UI/Badge",
  component: Badge,
  args: {
    children: "Badge label",
    variant: "soft",
    tone: "accent",
    size: "md",
  },
  argTypes: {
    variant: {
      control: { type: "inline-radio" },
      options: ["solid", "soft", "outline", "ghost"],
    },
    tone: {
      control: { type: "select" },
      options: ["default", "accent", "success", "warning", "danger", "neutral", "info"],
    },
    size: {
      control: { type: "inline-radio" },
      options: ["sm", "md"],
    },
    icon: { control: false },
    asChild: { control: { type: "boolean" } },
  },
  parameters: {
    docs: {
      description: {
        component:
          "Semantic badge primitive that maps tone + variant props to design tokens. Supports icon slots and ghost/outline styles for marketing use cases.",
      },
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Playground: Story = {}

const tones: BadgeProps["tone"][] = [
  "default",
  "accent",
  "success",
  "warning",
  "danger",
  "neutral",
  "info",
]

export const ToneMatrix: Story = {
  render: (args) => (
    <div className="flex flex-wrap gap-3">
      {tones.map((tone) => (
        <Badge key={tone} {...args} tone={tone}>
          {tone}
        </Badge>
      ))}
    </div>
  ),
}
</file>

<file path="components/ui/__stories__/EmptyState.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { Inbox, ShieldAlert, Sparkles, Star, Upload } from "lucide-react"

import { Button } from "../button"
import { EmptyState } from "../empty-state"

const meta: Meta<typeof EmptyState> = {
  title: "Design System/EmptyState",
  component: EmptyState,
  parameters: {
    layout: "centered",
  },
  args: {
    title: "No conversations yet",
    description: "Kick off your next study by inviting candidates or importing interview notes.",
    icon: <Inbox aria-hidden="true" className="size-6" />,
    iconAriaLabel: "Empty inbox",
    tone: "neutral",
    size: "md",
    alignment: "center",
  },
  argTypes: {
    tone: {
      control: "inline-radio",
      options: ["neutral", "info", "success", "warning", "danger"],
    },
    size: {
      control: "inline-radio",
      options: ["sm", "md", "lg"],
    },
    alignment: {
      control: "inline-radio",
      options: ["center", "left"],
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Neutral: Story = {
  args: {
    primaryAction: {
      label: "Invite participants",
      onClick: () => console.log("invite"),
    },
    secondaryAction: {
      label: "Import CSV",
      onClick: () => console.log("import"),
    },
  },
}

export const Informational: Story = {
  args: {
    tone: "info",
    icon: <Sparkles aria-hidden="true" className="size-6" />,
    statusLabel: "Recommendations",
    title: "Fine-tune your prompts",
    description:
      "Review the generative AI checklist to improve reliability before sharing with the team.",
  },
}

export const Success: Story = {
  args: {
    tone: "success",
    icon: <Star aria-hidden="true" className="size-6" />,
    title: "All caught up",
    description: "Every diagnostic has been reviewed. We'll notify you if something changes.",
  },
}

export const Warning: Story = {
  args: {
    tone: "warning",
    icon: <ShieldAlert aria-hidden="true" className="size-6" />,
    title: "Quota nearly reached",
    description: "Usage is at 92% of your monthly limit. Upgrade to avoid throttling.",
    primaryAction: {
      label: "Upgrade plan",
      onClick: () => console.log("upgrade"),
    },
  },
}

export const DangerLeftAligned: Story = {
  args: {
    tone: "danger",
    alignment: "left",
    size: "lg",
    icon: <Upload aria-hidden="true" className="size-6" />,
    statusLabel: "Upload failed",
    title: "We couldn't process your file",
    description: (
      <span>
        Double-check the template and try again. <Button variant="link">Download sample</Button>
      </span>
    ),
  },
}
</file>

<file path="components/ui/__stories__/PageHeader.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"

import { Button } from "../button"
import { PageHeader } from "../page-header"

const meta: Meta<typeof PageHeader> = {
  title: "Design System/PageHeader",
  component: PageHeader,
  parameters: {
    layout: "fullscreen",
  },
  args: {
    title: "Analytics overview",
    description: "Monitor how each experiment performs and spot bottlenecks before they grow.",
  },
  argTypes: {
    density: {
      control: "inline-radio",
      options: ["comfortable", "compact"],
    },
    align: {
      control: "inline-radio",
      options: ["left", "between"],
    },
    tone: {
      control: "inline-radio",
      options: ["default", "muted"],
    },
    headingLevel: {
      control: "inline-radio",
      options: ["h1", "h2", "h3", "h4", "h5", "h6"],
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Default: Story = {}

export const WithBreadcrumbs: Story = {
  args: {
    breadcrumbs: [
      { label: "Dashboard", href: "#" },
      { label: "Analytics", href: "#" },
      { label: "Overview" },
    ],
  },
}

export const WithActions: Story = {
  args: {
    align: "between",
    actions: (
      <div className="flex flex-wrap items-center gap-2">
        <Button variant="ghost" tone="neutral">
          Share
        </Button>
        <Button tone="accent">Create report</Button>
      </div>
    ),
  },
}

export const MutedSurface: Story = {
  args: {
    tone: "muted",
    breadcrumbs: [
      { label: "Billing", href: "#" },
      { label: "Plans" },
    ],
    actions: (
      <Button tone="accent">Upgrade plan</Button>
    ),
  },
}

export const CompactDensity: Story = {
  args: {
    density: "compact",
    description: "Use compact density for data-heavy views or layouts with limited vertical space.",
  },
}

export const NoDescription: Story = {
  args: {
    description: undefined,
    breadcrumbs: [{ label: "Settings" }],
  },
}
</file>

<file path="components/ui/__stories__/Table.stories.tsx">
import * as React from "react"
import type { Meta, StoryObj } from "@storybook/react"

import { Sparkles } from "lucide-react"

import { Badge } from "../badge"
import { Table, type SortDirection, type TableColumn, type TableProps } from "../table"
import { EmptyState } from "../empty-state"

type ExperimentRow = {
  id: string
  experiment: string
  owner: string
  status: "Running" | "Paused" | "Draft"
  conversions: number
  updated: string
}

const columns: TableColumn<ExperimentRow>[] = [
  {
    id: "experiment",
    header: "Experiment",
    accessor: (row) => row.experiment,
    sortable: true,
    width: "28%",
  },
  {
    id: "owner",
    header: "Owner",
    accessor: (row) => row.owner,
    sortable: true,
  },
  {
    id: "status",
    header: "Status",
    accessor: (row) => {
      const tone =
        row.status === "Running"
          ? "success"
          : row.status === "Paused"
          ? "warning"
          : "default"

      return (
        <Badge variant="soft" tone={tone} className="font-medium">
          {row.status}
        </Badge>
      )
    },
  },
  {
    id: "conversions",
    header: "Conversions",
    accessor: (row) => row.conversions.toLocaleString(),
    align: "right",
    sortable: true,
  },
  {
    id: "updated",
    header: "Last updated",
    accessor: (row) => row.updated,
    sortable: true,
  },
]

const data: ExperimentRow[] = [
  {
    id: "exp-01",
    experiment: "Pricing paywall copy",
    owner: "Leah Griffin",
    status: "Running",
    conversions: 1420,
    updated: "2025-02-14",
  },
  {
    id: "exp-02",
    experiment: "Onboarding checklist",
    owner: "Ibrahim Noor",
    status: "Paused",
    conversions: 980,
    updated: "2025-02-11",
  },
  {
    id: "exp-03",
    experiment: "New hero illustration",
    owner: "Joana Silva",
    status: "Draft",
    conversions: 312,
    updated: "2025-01-28",
  },
  {
    id: "exp-04",
    experiment: "Free trial CTA",
    owner: "Hector Lin",
    status: "Running",
    conversions: 1845,
    updated: "2025-02-03",
  },
]

const meta: Meta<typeof Table> = {
  title: "Design System/Table",
  component: Table,
  parameters: {
    layout: "fullscreen",
  },
  args: {
    columns: columns as unknown as TableColumn<unknown>[],
    data,
    caption: "List of experiments with owner, status, and conversions",
  },
  argTypes: {
    density: {
      control: "inline-radio",
      options: ["comfortable", "compact"],
    },
    zebra: {
      control: "boolean",
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

type SortState = { id: string; dir: SortDirection } | undefined

const useSortedData = (rows: ExperimentRow[], sort: SortState) => {
  return React.useMemo(() => {
    if (!sort) return rows
    const key = sort.id as keyof ExperimentRow
    return [...rows].sort((a, b) => {
      const aValue = a[key]
      const bValue = b[key]
      if (typeof aValue === "number" && typeof bValue === "number") {
        return sort.dir === "asc" ? aValue - bValue : bValue - aValue
      }
      return sort.dir === "asc"
        ? String(aValue).localeCompare(String(bValue))
        : String(bValue).localeCompare(String(aValue))
    })
  }, [rows, sort])
}

type ExperimentTableProps = TableProps<ExperimentRow>

const SortingExample: React.FC<ExperimentTableProps> = (props) => {
  const { data: rows, onSortChange, ...rest } = props
  const [sort, setSort] = React.useState<SortState>()
  const sortedRows = useSortedData((rows as ExperimentRow[]) ?? [], sort)

  const handleSortChange = React.useCallback(
    (columnId: string, direction: SortDirection | null) => {
      setSort(direction ? { id: columnId, dir: direction } : undefined)
      onSortChange?.(columnId, direction)
    },
    [onSortChange]
  )

  return (
    <Table<ExperimentRow>
      {...rest}
      data={sortedRows}
      sort={sort}
      onSortChange={handleSortChange}
    />
  )
}

export const InteractiveSorting: Story = {
  render: (args) => (
    <div className="mx-auto max-w-5xl p-6">
      <SortingExample {...(args as ExperimentTableProps)} />
    </div>
  ),
}

export const CompactDensity: Story = {
  render: (args) => (
    <div className="mx-auto max-w-4xl p-6">
      <SortingExample
        {...(args as ExperimentTableProps)}
        density="compact"
        zebra
      />
    </div>
  ),
}

export const Loading: Story = {
  args: {
    isLoading: true,
  },
}

export const Empty: Story = {
  args: {
    data: [],
  },
}

export const CustomEmptyState: Story = {
  args: {
    data: [],
    emptyState: (
      <EmptyState
        tone="info"
        icon={<Sparkles aria-hidden="true" className="size-6" />}
        statusLabel="No experiments yet"
        title="Start by launching your first test"
        description="A guided setup will walk you through defining hypotheses and rollout criteria."
        primaryAction={{ label: "Launch experiment", onClick: () => console.log("launch") }}
      />
    ),
  },
}
</file>

<file path="components/ui/__stories__/Toast.stories.tsx">
import * as React from "react"
import type { Meta, StoryObj } from "@storybook/react"

import { Button } from "../button"
import { Toast, type ToastProps, useToastQueue } from "../toast"

const meta: Meta<typeof Toast> = {
  title: "Design System/Toast",
  component: Toast,
  parameters: {
    layout: "centered",
  },
  args: {
    tone: "info",
    elevation: "sm",
    dismissible: true,
    title: "Changes published",
    description: "Your updates are now live for all reviewers.",
  },
  argTypes: {
    tone: {
      control: "inline-radio",
      options: ["info", "success", "warning", "danger"],
    },
    elevation: {
      control: "inline-radio",
      options: ["none", "sm", "md"],
    },
    dismissible: {
      control: "boolean",
    },
  },
}

export default meta

type Story = StoryObj<typeof meta>

export const Info: Story = {
  args: {
    action: {
      label: "View", 
      onClick: () => console.log("view"),
    },
  },
}

export const Success: Story = {
  args: {
    tone: "success",
    title: "Diagnostics exported",
    description: "We emailed the report to your analytics inbox.",
    action: {
      label: "Undo",
      onClick: () => console.log("undo"),
    },
  },
}

export const Warning: Story = {
  args: {
    tone: "warning",
    title: "Connection unstable",
    description: "We'll keep trying in the background and alert you if it fails.",
  },
}

export const Danger: Story = {
  args: {
    tone: "danger",
    title: "Sync failed",
    description: "Retry syncing the library or download a backup.",
    action: {
      label: "Retry",
      onClick: () => console.log("retry"),
    },
  },
}

const QueueDemo = () => {
  const { toasts, addToast, dismissToast } = useToastQueue()

  const pushToast = (overrides: Partial<ToastProps>) => {
    addToast({
      tone: "info",
      dismissible: true,
      elevation: "md",
      title: "Workflow saved",
      description: "Changes will publish once approved.",
      ...overrides,
    })
  }

  return (
    <div className="flex w-full max-w-sm flex-col gap-4">
      <div className="flex flex-wrap gap-2">
        <Button onClick={() => pushToast({ tone: "success", title: "Segment created", description: "It will appear in targeting shortly." })}>
          Success toast
        </Button>
        <Button variant="outline" onClick={() => pushToast({ tone: "warning", title: "API latency", description: "Traffic is spiking, we are scaling workers." })}>
          Warning toast
        </Button>
        <Button variant="ghost" tone="danger" onClick={() => pushToast({ tone: "danger", title: "Deployment failed", description: "Rollback triggered. Investigate the build logs." })}>
          Danger toast
        </Button>
      </div>
      <div className="flex flex-col gap-3">
        {toasts.length === 0 ? (
          <div className="rounded-lg border border-dashed border-border/60 p-6 text-sm text-muted-foreground">
            Trigger a toast to preview the stack.
          </div>
        ) : (
          toasts.map(({ id, ...toast }) => (
            <Toast
              key={id}
              {...toast}
              onClose={() => dismissToast(id)}
            />
          ))
        )}
      </div>
    </div>
  )
}

export const Queue: Story = {
  render: () => <QueueDemo />,
}
</file>

<file path="components/ui/__tests__/button.a11y.test.tsx">
import * as React from "react"
import { render, screen } from "@testing-library/react"
import userEvent from "@testing-library/user-event"

import { Button } from "../button"

describe("Button accessibility", () => {
  it("renders supported variants and tones", () => {
    const { container } = render(
      <div className="flex flex-wrap gap-2">
        {(["solid", "soft", "outline", "ghost", "link"] as const).map((variant) => (
          <Button key={variant} variant={variant} tone="accent" size="sm">
            {variant}
          </Button>
        ))}
        {(["default", "accent", "success", "warn", "danger", "neutral"] as const).map((tone) => (
          <Button key={tone} variant="solid" tone={tone} size="md">
            {tone}
          </Button>
        ))}
      </div>
    )

    expect(container.querySelectorAll("button").length).toBeGreaterThan(0)
  })

  it("exposes focus-visible ring classes for keyboard users", async () => {
    const user = userEvent.setup()
    render(<Button>Focus me</Button>)

    await user.tab()
    const button = screen.getByRole("button", { name: "Focus me" })

    expect(document.activeElement).toBe(button)
    expect(button.className).toEqual(expect.stringContaining("focus-visible:ring-2"))
    expect(button.className).toEqual(expect.stringContaining("focus-visible:ring-offset-2"))
  })

  it("prevents interaction when disabled or loading", async () => {
    const user = userEvent.setup()
    const onClick = jest.fn()

    render(
      <div className="space-y-2">
        <Button onClick={onClick} disabled>
          Disabled
        </Button>
        <Button onClick={onClick} loading icon={<span aria-hidden="true" />}>
          Loading
        </Button>
      </div>
    )

    const disabledButton = screen.getByRole("button", { name: "Disabled" })
    const loadingButton = screen.getByRole("button", { name: "Loading" })

    await user.click(disabledButton)
    await user.click(loadingButton)

    expect(onClick).not.toHaveBeenCalled()
    expect(disabledButton).toHaveAttribute("aria-disabled", "true")
    expect(loadingButton).toHaveAttribute("aria-disabled", "true")
    expect(loadingButton).toHaveAttribute("aria-busy", "true")
    expect(loadingButton.querySelector("svg")).toBeTruthy()
  })
})
</file>

<file path="components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full font-medium leading-none transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-foreground/20 focus-visible:ring-offset-2 focus-visible:ring-offset-background whitespace-nowrap select-none",
  {
    variants: {
      variant: {
        solid: "shadow-sm",
        soft: "ring-1 ring-inset",
        outline: "bg-background ring-1 ring-inset",
        ghost: "bg-transparent",
      },
      tone: {
        default: "text-foreground",
        accent: "text-accent",
        success: "text-success",
        warning: "text-warning",
        danger: "text-error",
        neutral: "text-muted-foreground",
        info: "text-info",
      },
      size: {
        sm: "h-6 px-2 text-xs gap-1",
        md: "h-7 px-2.5 text-sm gap-1.5",
      },
    },
    compoundVariants: [
      {
        variant: "solid",
        tone: "default",
        class: "bg-foreground text-background",
      },
      {
        variant: "solid",
        tone: "accent",
        class: "bg-accent text-accent-foreground",
      },
      {
        variant: "solid",
        tone: "success",
        class: "bg-success text-background",
      },
      {
        variant: "solid",
        tone: "warning",
        class: "bg-warning text-background",
      },
      {
        variant: "solid",
        tone: "danger",
        class: "bg-error text-background",
      },
      {
        variant: "solid",
        tone: "neutral",
        class: "bg-muted text-foreground",
      },
      {
        variant: "solid",
        tone: "info",
        class: "bg-info text-background",
      },
      {
        variant: "soft",
        tone: "default",
        class: "bg-muted text-foreground ring-border/60",
      },
      {
        variant: "soft",
        tone: "accent",
        class: "bg-accent/10 text-[color:var(--tone-accent)] ring-[color:var(--tone-accent)]/20",
      },
      {
        variant: "soft",
        tone: "success",
        class: "bg-success/10 text-success ring-success/20",
      },
      {
        variant: "soft",
        tone: "warning",
        class: "bg-warning/15 text-warning-dark ring-warning/30",
      },
      {
        variant: "soft",
        tone: "danger",
        class: "bg-error/10 text-error ring-error/20",
      },
      {
        variant: "soft",
        tone: "neutral",
        class: "bg-muted/70 text-muted-foreground ring-border/40",
      },
      {
        variant: "soft",
        tone: "info",
        class: "bg-info/10 text-info ring-info/20",
      },
      {
        variant: "outline",
        tone: "default",
        class: "text-foreground ring-border/70",
      },
      {
        variant: "outline",
        tone: "accent",
        class: "text-[color:var(--tone-accent)] ring-[color:var(--tone-accent)]/40",
      },
      {
        variant: "outline",
        tone: "success",
        class: "text-success ring-success/35",
      },
      {
        variant: "outline",
        tone: "warning",
        class: "text-warning-dark ring-warning/40",
      },
      {
        variant: "outline",
        tone: "danger",
        class: "text-error ring-error/40",
      },
      {
        variant: "outline",
        tone: "neutral",
        class: "text-muted-foreground ring-border/50",
      },
      {
        variant: "outline",
        tone: "info",
        class: "text-info ring-info/35",
      },
      {
        variant: "ghost",
        tone: "default",
        class: "hover:bg-muted/70",
      },
      {
        variant: "ghost",
        tone: "accent",
        class: "text-[color:var(--tone-accent)] hover:bg-accent/10",
      },
      {
        variant: "ghost",
        tone: "success",
        class: "text-success hover:bg-success/10",
      },
      {
        variant: "ghost",
        tone: "warning",
        class: "text-warning-dark hover:bg-warning/10",
      },
      {
        variant: "ghost",
        tone: "danger",
        class: "text-error hover:bg-error/10",
      },
      {
        variant: "ghost",
        tone: "neutral",
        class: "text-muted-foreground hover:bg-muted/60",
      },
      {
        variant: "ghost",
        tone: "info",
        class: "text-info hover:bg-info/10",
      },
    ],
    defaultVariants: {
      variant: "soft",
      tone: "default",
      size: "md",
    },
  }
)

const badgeIconVariants = cva("flex items-center justify-center shrink-0", {
  variants: {
    size: {
      sm: "h-3.5 w-3.5",
      md: "h-4 w-4",
    },
  },
  defaultVariants: {
    size: "md",
  },
})

export type BadgeProps = React.HTMLAttributes<HTMLSpanElement> &
  VariantProps<typeof badgeVariants> & {
    icon?: React.ReactNode
    asChild?: boolean
  }

const Badge = React.forwardRef<HTMLSpanElement, BadgeProps>(
  ({ className, variant, tone, size, icon, asChild, children, ...props }, ref) => {
    const Comp = asChild ? Slot : "span"

    return (
      <Comp
        ref={ref}
        data-slot="badge"
        className={cn(badgeVariants({ variant, tone, size }), className)}
        {...props}
      >
        {icon ? (
          <span aria-hidden className={badgeIconVariants({ size })}>
            {icon}
          </span>
        ) : null}
        <span className="truncate">{children}</span>
      </Comp>
    )
  }
)
Badge.displayName = "Badge"

export { Badge, badgeVariants }
export default Badge
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import {
  buttonBase,
  buttonSizeStyles,
  buttonVariantStyles,
} from "@/lib/design-system/components"

const button = cva(buttonBase, {
  variants: {
    variant: {
      solid: buttonVariantStyles.solid,
      soft: buttonVariantStyles.soft,
      outline: buttonVariantStyles.outline,
      ghost: buttonVariantStyles.ghost,
      link: buttonVariantStyles.link,
    },
    tone: {
      default: buttonVariantStyles.tone.default,
      accent: buttonVariantStyles.tone.accent,
      success: buttonVariantStyles.tone.success,
      warn: buttonVariantStyles.tone.warn,
      danger: buttonVariantStyles.tone.danger,
      neutral: buttonVariantStyles.tone.neutral,
    },
    size: {
      sm: buttonSizeStyles.sm,
      md: buttonSizeStyles.md,
      lg: buttonSizeStyles.lg,
    },
    fullWidth: {
      true: "w-full",
    },
  },
  defaultVariants: {
    variant: "solid",
    tone: "accent",
    size: "md",
  },
})

function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]) {
  return (value: T) => {
    for (const ref of refs) {
      if (typeof ref === "function") {
        ref(value)
      } else if (ref) {
        ;(ref as React.MutableRefObject<T | null>).current = value
      }
    }
  }
}

/**
 * The canonical button component for the Testero design system.
 *
 * @remarks
 * - `variant` controls the structural treatment (`solid`, `soft`, `outline`, `ghost`, `link`).
 * - `tone` applies semantic color intent mapped to tokens (`default`, `accent`, `success`, `warn`, `danger`, `neutral`).
 * - `size` ensures token-backed spacing with md/lg meeting a 44px hit area.
 * - `loading` shows a spinner, disables pointer interaction, and marks the control as busy.
 * - `icon`/`iconRight` render leading and trailing affordances while preserving accessible labels.
 * - `fullWidth` stretches the button to the available width while retaining variant styling.
 */
export type ButtonProps = Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, "type"> &
  VariantProps<typeof button> & {
    /** Visually replaces the content with a spinner and prevents user interaction. */
    loading?: boolean
    /** Optional leading icon, rendered before the children. */
    icon?: React.ReactNode
    /** Optional trailing icon, rendered after the children. */
    iconRight?: React.ReactNode
    /** Render the button as a different element while preserving styling. */
    asChild?: boolean
    /** Override the intrinsic button type (defaults to `button`). */
    type?: "button" | "submit" | "reset"
  }

const Spinner = ({ className }: { className?: string }) => (
  <svg
    aria-hidden="true"
    className={cn("size-4 animate-spin text-current", className)}
    viewBox="0 0 24 24"
    fill="none"
  >
    <circle
      className="opacity-25"
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    />
    <path
      className="opacity-75"
      d="M4 12a8 8 0 018-8V2a10 10 0 100 20v-2a8 8 0 01-8-8z"
      fill="currentColor"
    />
  </svg>
)

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      asChild = false,
      className,
      variant,
      tone,
      size,
      fullWidth,
      loading = false,
      icon,
      iconRight,
      disabled,
      type = "button",
      children,
      ...props
    },
    ref
  ) => {
    const isDisabled = disabled || loading
    const buttonClassName = cn(
      button({ variant, tone, size, fullWidth }),
      loading && "cursor-progress",
      className
    )

    const childContent =
      asChild && React.isValidElement(children)
        ? (children.props as { children?: React.ReactNode }).children
        : children

    const content = (
      <>
        {loading ? (
          <Spinner className="mr-2" />
        ) : icon ? (
          <span className="-ml-0.5 mr-2 flex shrink-0 items-center">{icon}</span>
        ) : null}
        <span className="inline-flex min-w-0 items-center justify-center">{childContent}</span>
        {iconRight && !loading ? (
          <span className="ml-2 -mr-0.5 flex shrink-0 items-center">{iconRight}</span>
        ) : null}
      </>
    )

    const { onClick, ...restProps } = props

    if (asChild && React.isValidElement(children)) {
      const child = children as React.ReactElement
      const childOnClick = child.props?.onClick as React.MouseEventHandler<unknown> | undefined
      const childRef = (child as React.ReactElement & { ref?: React.Ref<unknown> }).ref

      return React.cloneElement(child, {
        ...restProps,
        className: cn(buttonClassName, child.props.className),
        "data-variant": variant ?? "solid",
        "data-tone": tone ?? "accent",
        "data-loading": loading ? "true" : undefined,
        "data-disabled": isDisabled ? "true" : undefined,
        "aria-disabled": isDisabled || undefined,
        "aria-busy": loading || undefined,
        ref: mergeRefs(childRef as React.Ref<unknown>, ref as React.Ref<unknown>),
        onClick: (event: React.MouseEvent<unknown>) => {
          if (isDisabled) {
            event.preventDefault()
            event.stopPropagation()
            return
          }
          childOnClick?.(event)
          ;(onClick as React.MouseEventHandler<unknown> | undefined)?.(event)
        },
        children: content,
      })
    }

    return (
      <button
        ref={ref}
        type={type}
        data-variant={variant ?? "solid"}
        data-tone={tone ?? "accent"}
        data-loading={loading ? "true" : undefined}
        data-disabled={isDisabled ? "true" : undefined}
        aria-disabled={isDisabled || undefined}
        aria-busy={loading || undefined}
        disabled={isDisabled}
        className={buttonClassName}
        onClick={(event) => {
          if (isDisabled) {
            event.preventDefault()
            event.stopPropagation()
            return
          }
          ;(onClick as React.MouseEventHandler<HTMLButtonElement> | undefined)?.(event)
        }}
        {...restProps}
      >
        {content}
      </button>
    )
  }
)

Button.displayName = "Button"

export { button as buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const cardVariants = cva(
  "relative flex flex-col rounded-xl border border-border/60 bg-card text-card-foreground shadow-sm transition-all duration-200",
  {
    variants: {
      variant: {
        default:
          "hover:-translate-y-0.5 hover:shadow-lg",
        elevated:
          "rounded-2xl border-border/40 shadow-lg hover:-translate-y-1 hover:shadow-xl",
        glass:
          "rounded-2xl border-white/30 bg-white/20 backdrop-blur-sm hover:-translate-y-0.5 hover:shadow-md",
      },
      size: {
        sm: "",
        md: "",
        lg: "",
      },
      compact: {
        false: "",
        true: "",
      },
      inset: {
        none: "",
        content: "",
        all: "",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      compact: false,
      inset: "none",
    },
  }
)

type CardSize = NonNullable<VariantProps<typeof cardVariants>["size"]>
type CardInset = NonNullable<VariantProps<typeof cardVariants>["inset"]>

type CardContextValue = {
  size: CardSize
  compact: boolean
  inset: CardInset
}

const defaultContext: CardContextValue = {
  size: "md",
  compact: false,
  inset: "none",
}

const CardContext = React.createContext<CardContextValue>(defaultContext)

function useCardContext() {
  return React.useContext(CardContext)
}

const horizontalPadding: Record<CardSize, string> = {
  sm: "px-3",           // 12px
  md: "px-4 md:px-6",   // 16px mobile, 24px desktop
  lg: "px-6",           // 24px
}

const verticalPadding: Record<CardSize, string> = {
  sm: "py-3",           // 12px
  md: "py-4 md:py-6",   // 16px mobile, 24px desktop
  lg: "py-6",           // 24px
}

const compactVerticalPadding: Record<CardSize, string> = {
  sm: "py-3",           // 12px
  md: "py-3",           // 12px
  lg: "py-4",           // 16px
}

const gapSpacing: Record<CardSize, string> = {
  sm: "gap-2",          // 8px
  md: "gap-3",          // 12px
  lg: "gap-4",          // 16px
}

const compactGapSpacing: Record<CardSize, string> = {
  sm: "gap-2",
  md: "gap-2",
  lg: "gap-3",
}

const sectionGapSpacing: Record<CardSize, string> = {
  sm: "gap-2",
  md: "gap-3",
  lg: "gap-4",
}

const footerPaddingTop: Record<CardSize, { regular: string; compact: string }> = {
  sm: { regular: "pt-3", compact: "pt-3" },
  md: { regular: "pt-4", compact: "pt-3" },
  lg: { regular: "pt-6", compact: "pt-4" },
}

const actionGapSpacing: Record<CardSize, string> = {
  sm: "gap-2",
  md: "gap-3",
  lg: "gap-4",
}

const horizontalInsetSpacing: Record<CardSize, { negative: string; padding: string }> = {
  sm: { negative: "-mx-3", padding: "px-3" },
  md: { negative: "-mx-4", padding: "px-4" },
  lg: { negative: "-mx-6", padding: "px-6" },
}

const disallowedSpacingPattern = /\b(p[trblxy]?|px|py|gap|space-[xy])(-|\[)/

export type CardProps = React.ComponentPropsWithoutRef<"div"> &
  VariantProps<typeof cardVariants> & {
    allowInternalSpacingOverride?: boolean
  }

const Card = React.forwardRef<HTMLDivElement, CardProps>(function Card(
  {
    className,
    variant,
    size: sizeProp = "md",
    compact: compactProp = false,
    inset: insetProp = "none",
    allowInternalSpacingOverride = false,
    ...props
  },
  ref
) {
  const size = sizeProp as CardSize
  const compact = Boolean(compactProp)
  const inset = insetProp as CardInset

  if (!allowInternalSpacingOverride && typeof className === "string" && disallowedSpacingPattern.test(className)) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(
        "[Card]: Avoid applying padding or gap utilities via className. Use size/compact props or explicitly set allowInternalSpacingOverride."
      )
    }
  }

  const spacingClasses = cn(
    horizontalPadding[size],
    compact ? compactVerticalPadding[size] : verticalPadding[size],
    compact ? compactGapSpacing[size] : gapSpacing[size]
  )

  const contextValue = React.useMemo<CardContextValue>(
    () => ({ size, compact, inset }),
    [size, compact, inset]
  )

  return (
    <CardContext.Provider value={contextValue}>
      <div
        ref={ref}
        data-slot="card"
        data-card-size={size}
        data-card-compact={compact ? "true" : undefined}
        data-card-inset={inset}
        className={cn(cardVariants({ variant, size, compact, inset }), spacingClasses, className)}
        {...props}
      />
    </CardContext.Provider>
  )
})

const CardHeader = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardHeader({ className, ...props }, ref) {
    const { size, compact, inset } = useCardContext()
    const insetClasses =
      inset === "all"
        ? [horizontalInsetSpacing[size].negative, horizontalInsetSpacing[size].padding]
        : []
    const headerGap = compact ? compactGapSpacing[size] : sectionGapSpacing[size]

    return (
      <div
        ref={ref}
        data-slot="card-header"
        className={cn(
          "flex flex-col",
          headerGap,
          insetClasses,
          className
        )}
        {...props}
      />
    )
  }
)

const CardTitle = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardTitle({ className, ...props }, ref) {
    return (
      <div
        ref={ref}
        data-slot="card-title"
        className={cn("text-lg font-semibold leading-tight text-foreground", className)}
        {...props}
      />
    )
  }
)

const CardDescription = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardDescription({ className, ...props }, ref) {
    return (
      <div
        ref={ref}
        data-slot="card-description"
        className={cn("text-sm text-muted-foreground", className)}
        {...props}
      />
    )
  }
)

const CardAction = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardAction({ className, ...props }, ref) {
    const { size, compact } = useCardContext()
    const gap = compact ? compactGapSpacing[size] : actionGapSpacing[size]
    return (
      <div
        ref={ref}
        data-slot="card-action"
        className={cn("flex items-center justify-end", gap, className)}
        {...props}
      />
    )
  }
)

const CardContent = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardContent({ className, ...props }, ref) {
    const { size, compact, inset } = useCardContext()
    const insetClasses =
      inset === "content" || inset === "all"
        ? [horizontalInsetSpacing[size].negative, horizontalInsetSpacing[size].padding]
        : []

    return (
      <div
        ref={ref}
        data-slot="card-content"
        className={cn(
          "flex flex-1 flex-col",
          compact ? compactGapSpacing[size] : gapSpacing[size],
          insetClasses,
          className
        )}
        {...props}
      />
    )
  }
)

const CardFooter = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<"div">>(
  function CardFooter({ className, ...props }, ref) {
    const { size, compact, inset } = useCardContext()
    const insetClasses =
      inset === "all"
        ? [horizontalInsetSpacing[size].negative, horizontalInsetSpacing[size].padding]
        : []

    const paddingTop = compact ? footerPaddingTop[size].compact : footerPaddingTop[size].regular
    const footerGap = compact ? compactGapSpacing[size] : actionGapSpacing[size]

    return (
      <div
        ref={ref}
        data-slot="card-footer"
        className={cn(
          "flex items-center justify-between border-t border-border/60",
          paddingTop,
          insetClasses,
          footerGap,
          className
        )}
        {...props}
      />
    )
  }
)

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
  cardVariants,
}
</file>

<file path="components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="components/ui/dialog.tsx">
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="components/ui/empty-state.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"

import {
  emptyStateActions,
  emptyStateDescription,
  emptyStateIcon,
  emptyStateRoot,
  emptyStateTitle,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"
import { Button } from "./button"

type EmptyStateRootVariants = VariantProps<typeof emptyStateRoot>

type EmptyStateTone = NonNullable<EmptyStateRootVariants["tone"]>
type EmptyStateSize = NonNullable<EmptyStateRootVariants["size"]>
type EmptyStateAlignment = NonNullable<EmptyStateRootVariants["alignment"]>

type ButtonTone = NonNullable<React.ComponentProps<typeof Button>["tone"]>

export interface EmptyStateAction {
  label: string
  onClick?: () => void
  href?: string
}

export interface EmptyStateProps
  extends React.HTMLAttributes<HTMLDivElement>,
    EmptyStateRootVariants {
  title: string
  icon?: React.ReactNode
  iconAriaLabel?: string
  statusLabel?: string
  description?: React.ReactNode
  primaryAction?: EmptyStateAction
  secondaryAction?: EmptyStateAction
}

const toneToButtonTone: Record<EmptyStateTone, ButtonTone> = {
  neutral: "accent",
  info: "accent",
  success: "success",
  warning: "warn",
  danger: "danger",
}

const toneLabelMap: Record<EmptyStateTone, string> = {
  neutral: "Heads up",
  info: "Informational",
  success: "Success",
  warning: "Warning",
  danger: "Critical",
}

const toneLabelClassMap: Record<EmptyStateTone, string> = {
  neutral: "text-muted-foreground",
  info: "text-info",
  success: "text-success",
  warning: "text-warning",
  danger: "text-destructive",
}

export const EmptyState = React.forwardRef<HTMLDivElement, EmptyStateProps>(
  (
    {
      icon,
      iconAriaLabel,
      statusLabel,
      title,
      description,
      primaryAction,
      secondaryAction,
      tone = "neutral",
      size = "md",
      alignment = "center",
      elevated,
      className,
      ...props
    },
    ref
  ) => {
    const resolvedTone: EmptyStateTone = tone ?? "neutral"
    const resolvedSize: EmptyStateSize = size ?? "md"
    const resolvedAlignment: EmptyStateAlignment = alignment ?? "center"

    const resolvedStatusLabel = statusLabel ?? toneLabelMap[resolvedTone]
    const role = resolvedTone === "danger" || resolvedTone === "warning" ? "alert" : "status"
    const ariaLive = role === "alert" ? "assertive" : "polite"

    const descriptionContent = React.useMemo(() => {
      if (!description) return null

      if (typeof description === "string") {
        return (
          <p
            className={cn(
              emptyStateDescription({ size: resolvedSize, alignment: resolvedAlignment })
            )}
          >
            {description}
          </p>
        )
      }

      if (React.isValidElement(description)) {
        const element = description as React.ReactElement<{ className?: string }>
        return React.cloneElement(element, {
          className: cn(
            emptyStateDescription({ size: resolvedSize, alignment: resolvedAlignment }),
            element.props.className
          ),
        })
      }

      return (
        <div
          className={cn(
            emptyStateDescription({ size: resolvedSize, alignment: resolvedAlignment })
          )}
        >
          {description}
        </div>
      )
    }, [description, resolvedAlignment, resolvedSize])

    const renderAction = (
      action: EmptyStateAction,
      variant: "primary" | "secondary"
    ) => {
      if (!action) return null
      const buttonTone = toneToButtonTone[resolvedTone]
      const variantConfig =
        variant === "primary"
          ? { variant: "solid" as const, tone: buttonTone }
          : { variant: "ghost" as const, tone: "neutral" as ButtonTone }

      if (action.href) {
        return (
          <Button asChild variant={variantConfig.variant} tone={variantConfig.tone}>
            <a href={action.href} onClick={action.onClick}>
              {action.label}
            </a>
          </Button>
        )
      }

      return (
        <Button
          variant={variantConfig.variant}
          tone={variantConfig.tone}
          onClick={action.onClick}
        >
          {action.label}
        </Button>
      )
    }

    return (
      <div
        ref={ref}
        role={role}
        aria-live={ariaLive}
        className={cn(
          emptyStateRoot({
            tone: resolvedTone,
            size: resolvedSize,
            alignment: resolvedAlignment,
            elevated: elevated ? true : undefined,
          }),
          className
        )}
        {...props}
      >
        {icon ? (
          <span
            className={cn(emptyStateIcon({ tone: resolvedTone, size: resolvedSize }))}
            role={iconAriaLabel ? "img" : undefined}
            aria-label={iconAriaLabel}
            aria-hidden={iconAriaLabel ? undefined : "true"}
          >
            {icon}
          </span>
        ) : null}

        <span
          className={cn(
            "text-xs font-semibold uppercase tracking-wide",
            toneLabelClassMap[resolvedTone]
          )}
        >
          {resolvedStatusLabel}
        </span>

        <h2 className={cn(emptyStateTitle({ size: resolvedSize }))}>{title}</h2>
        {descriptionContent}

        {(primaryAction || secondaryAction) && (
          <div className={cn(emptyStateActions({ alignment: resolvedAlignment }))}>
            {secondaryAction ? renderAction(secondaryAction, "secondary") : null}
            {primaryAction ? renderAction(primaryAction, "primary") : null}
          </div>
        )}
      </div>
    )
  }
)

EmptyState.displayName = "EmptyState"
</file>

<file path="components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex w-full min-w-0 rounded-md border bg-transparent px-3 py-2.5 text-base leading-6 shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:items-center file:justify-center file:border-0 file:bg-transparent file:px-3 file:py-2.5 file:text-base file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm md:leading-5 min-h-[44px]",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="components/ui/page-header.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"

import {
  pageHeaderActions,
  pageHeaderBreadcrumbs,
  pageHeaderDescription,
  pageHeaderInner,
  pageHeaderRoot,
  pageHeaderText,
  pageHeaderTitle,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"

export type PageHeaderBreadcrumb = {
  label: string
  href?: string
}

type PageHeaderRootVariants = VariantProps<typeof pageHeaderRoot>
type PageHeaderInnerVariants = VariantProps<typeof pageHeaderInner>

type HeadingTag = "h1" | "h2" | "h3" | "h4" | "h5" | "h6"

export interface PageHeaderProps
  extends Omit<React.HTMLAttributes<HTMLElement>, "title">,
    PageHeaderRootVariants,
    Pick<PageHeaderInnerVariants, "align"> {
  title: string | React.ReactNode
  description?: React.ReactNode
  breadcrumbs?: PageHeaderBreadcrumb[]
  actions?: React.ReactNode
  headingLevel?: HeadingTag
}

export const PageHeader = React.forwardRef<HTMLElement, PageHeaderProps>(
  (
    {
      title,
      description,
      breadcrumbs,
      actions,
      tone,
      density,
      align = "left",
      headingLevel = "h1",
      className,
      ...props
    },
    ref
  ) => {
    const headingId = React.useId()

    const Heading = headingLevel as React.ElementType

    const descriptionContent = React.useMemo(() => {
      if (!description) return null

      if (typeof description === "string") {
        return (
          <p className={cn(pageHeaderDescription({ density }))}>{description}</p>
        )
      }

      if (React.isValidElement(description)) {
        const element = description as React.ReactElement<{ className?: string }>;
        return React.cloneElement(element, {
          className: cn(pageHeaderDescription({ density }), element.props.className),
        })
      }

      return (
        <div className={cn(pageHeaderDescription({ density }))}>{description}</div>
      )
    }, [description, density])

    return (
      <header
        ref={ref}
        aria-labelledby={headingId}
        className={cn(pageHeaderRoot({ tone, density }), className)}
        data-align={align}
        {...props}
      >
        <div className={cn(pageHeaderInner({ density, align }))}>
          <div className={cn(pageHeaderText({ density, align }), "w-full")}>
            {breadcrumbs && breadcrumbs.length > 0 ? (
              <nav aria-label="Breadcrumb" className="w-full">
                <ol className={cn(pageHeaderBreadcrumbs({ density }))}>
                  {breadcrumbs.map((breadcrumb, index) => {
                    const isLast = index === breadcrumbs.length - 1

                    return (
                      <li
                        key={`${breadcrumb.label}-${index}`}
                        aria-current={isLast ? "page" : undefined}
                        className="flex items-center gap-2"
                      >
                        {breadcrumb.href && !isLast ? (
                          <a
                            href={breadcrumb.href}
                            className="rounded-md px-1 py-0.5 text-sm text-muted-foreground transition-colors hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                          >
                            {breadcrumb.label}
                          </a>
                        ) : (
                          <span
                            className={cn(
                              "rounded-md px-1 py-0.5",
                              isLast ? "text-foreground" : "text-muted-foreground"
                            )}
                          >
                            {breadcrumb.label}
                          </span>
                        )}
                        {!isLast ? (
                          <span aria-hidden="true" className="text-muted-foreground/70">
                            /
                          </span>
                        ) : null}
                      </li>
                    )
                  })}
                </ol>
              </nav>
            ) : null}

            <div className="flex flex-col gap-3">
              <Heading
                id={headingId}
                className={cn(pageHeaderTitle({ density }))}
              >
                {title}
              </Heading>
              {descriptionContent}
            </div>
          </div>

          {actions ? (
            <div
              className={cn(
                pageHeaderActions({ density }),
                align === "between" ? "md:justify-end" : "md:justify-start",
                "w-full md:w-auto"
              )}
            >
              {actions}
            </div>
          ) : null}
        </div>
      </header>
    )
  }
)

PageHeader.displayName = "PageHeader"
</file>

<file path="components/ui/progress.tsx">
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="components/ui/table.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"
import { ArrowUpDown, ChevronDown, ChevronUp } from "lucide-react"

import {
  tableCell,
  tableContainer,
  tableHeaderCell,
  tableHeaderRow,
  tableRoot,
  tableRow,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"
import { EmptyState } from "./empty-state"

type TableContainerVariants = VariantProps<typeof tableContainer>

type DensityVariant = NonNullable<TableContainerVariants["density"]>

export type SortDirection = "asc" | "desc"

export interface TableColumn<TData> {
  id: string
  header: React.ReactNode
  accessor?: (row: TData) => React.ReactNode
  align?: "left" | "center" | "right"
  width?: string
  sortable?: boolean
}

export interface TableProps<TData>
  extends React.HTMLAttributes<HTMLDivElement>,
    TableContainerVariants {
  columns: TableColumn<TData>[]
  data: TData[]
  caption?: string
  captionClassName?: string
  tableProps?: React.TableHTMLAttributes<HTMLTableElement>
  isLoading?: boolean
  emptyState?: React.ReactNode
  onSortChange?: (columnId: string, direction: SortDirection | null) => void
  sort?: { id: string; dir: SortDirection }
  stickyHeader?: boolean
  getRowId?: (row: TData, index: number) => string
}

const LoadingIndicator = ({ density }: { density: DensityVariant }) => (
  <div className="flex items-center justify-center gap-3 text-sm text-muted-foreground">
    <span
      aria-hidden="true"
      className={cn(
        "size-4 animate-spin rounded-full border-2 border-border/80 border-t-transparent",
        density === "compact" ? "size-3" : "size-4"
      )}
    />
    <span>Loading</span>
  </div>
)

export const Table = <TData,>(
  {
    columns,
    data,
    caption,
    captionClassName,
    tableProps,
    isLoading,
    emptyState,
    onSortChange,
    sort,
    density = "comfortable",
    zebra,
    stickyHeader,
    getRowId,
    className,
    ...rest
  }: TableProps<TData>
) => {
  const colSpan = Math.max(columns.length, 1)
  const resolvedDensity: DensityVariant = density ?? "comfortable"

  const renderCellContent = React.useCallback(
    (row: TData, column: TableColumn<TData>) => {
      if (column.accessor) {
        return column.accessor(row)
      }

      const value = (row as Record<string, unknown>)[column.id]
      if (React.isValidElement(value)) {
        return value
      }

      if (typeof value === "string" || typeof value === "number") {
        return value
      }

      if (value === null || value === undefined) {
        return ""
      }

      return String(value)
    },
    []
  )

  const getSortState = (columnId: string): SortDirection | null => {
    if (!sort || sort.id !== columnId) return null
    return sort.dir
  }

  const handleSort = (column: TableColumn<TData>) => {
    if (!onSortChange || !column.sortable) return

    const current = getSortState(column.id)
    const next: SortDirection | null = current === "asc" ? "desc" : current === "desc" ? null : "asc"
    onSortChange(column.id, next)
  }

  const defaultEmpty = (
    <EmptyState
      tone="neutral"
      alignment="center"
      size={resolvedDensity === "compact" ? "sm" : "md"}
      title="No data yet"
      description="Once data is available it will appear here."
    />
  )

  return (
    <div
      className={cn(tableContainer({ density: resolvedDensity, zebra }), className)}
      {...rest}
    >
      <div className="relative w-full overflow-x-auto">
        <table
          className={cn(tableRoot({ density: resolvedDensity }))}
          aria-busy={isLoading || undefined}
          {...tableProps}
        >
          {caption ? (
            <caption className={cn("sr-only", captionClassName)}>{caption}</caption>
          ) : null}
          <thead>
            <tr className={cn(tableHeaderRow({ sticky: stickyHeader ? true : undefined }))}>
              {columns.map((column) => {
                const sortState = getSortState(column.id)
                const isSortable = Boolean(onSortChange && column.sortable)
                const ariaSort: React.AriaAttributes["aria-sort"] = sortState
                  ? sortState === "asc"
                    ? "ascending"
                    : "descending"
                  : "none"
                const textAlignment =
                  column.align === "right"
                    ? "text-right"
                    : column.align === "center"
                    ? "text-center"
                    : "text-left"
                const justifyAlignment =
                  column.align === "right"
                    ? "justify-end"
                    : column.align === "center"
                    ? "justify-center"
                    : "justify-between"

                return (
                  <th
                    key={column.id}
                    scope="col"
                    aria-sort={isSortable ? ariaSort : undefined}
                    className={cn(
                      tableHeaderCell({ density: resolvedDensity, align: column.align }),
                      "align-middle"
                    )}
                    style={column.width ? { width: column.width } : undefined}
                  >
                    {isSortable ? (
                      <button
                        type="button"
                        onClick={() => handleSort(column)}
                        className={cn(
                          "flex w-full items-center gap-2 rounded-md px-1 py-1 transition-colors hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-background",
                          textAlignment,
                          justifyAlignment
                        )}
                      >
                        <span className="truncate">{column.header}</span>
                        <span className="flex items-center text-muted-foreground" aria-hidden="true">
                          {sortState === "asc" ? (
                            <ChevronUp className="size-4" />
                          ) : sortState === "desc" ? (
                            <ChevronDown className="size-4" />
                          ) : (
                            <ArrowUpDown className="size-4" />
                          )}
                        </span>
                        <span className="sr-only">
                          {sortState === "asc"
                            ? "Sort descending"
                            : sortState === "desc"
                            ? "Clear sorting"
                            : "Sort ascending"}
                        </span>
                      </button>
                    ) : (
                      <span className={cn("block truncate", textAlignment)}>{column.header}</span>
                    )}
                  </th>
                )
              })}
            </tr>
          </thead>
          <tbody>
            {isLoading ? (
              <tr className={cn(tableRow({ density: resolvedDensity }))}>
                <td
                  colSpan={colSpan}
                  className={cn(
                    tableCell({ density: resolvedDensity, align: "center" }),
                    "py-10"
                  )}
                  aria-live="polite"
                >
                  <LoadingIndicator density={resolvedDensity} />
                </td>
              </tr>
            ) : data.length === 0 ? (
              <tr className={cn(tableRow({ density: resolvedDensity }))}>
                <td
                  colSpan={colSpan}
                  className={cn(
                    tableCell({ density: resolvedDensity, align: "center" }),
                    "py-12"
                  )}
                >
                  {emptyState ?? defaultEmpty}
                </td>
              </tr>
            ) : (
              data.map((row, rowIndex) => {
                const rowKey = getRowId ? getRowId(row, rowIndex) : `${rowIndex}`
                return (
                  <tr key={rowKey} className={cn(tableRow({ density: resolvedDensity }))}>
                    {columns.map((column) => (
                      <td
                        key={`${rowKey}-${column.id}`}
                        className={cn(
                          tableCell({ density: resolvedDensity, align: column.align })
                        )}
                        style={column.width ? { width: column.width } : undefined}
                      >
                        <div className="min-w-0 truncate">
                          {renderCellContent(row, column)}
                        </div>
                      </td>
                    ))}
                  </tr>
                )
              })
            )}
          </tbody>
        </table>
      </div>
    </div>
  )
}

Table.displayName = "Table"
</file>

<file path="components/ui/theme-toggle.tsx">
"use client";

import * as React from "react";
import { Monitor, MoonStar, SunMedium } from "lucide-react";
import { useTheme } from "next-themes";

const LABEL = "Toggle dark mode";

export function ThemeToggle() {
  const { theme, setTheme, resolvedTheme } = useTheme();
  const [isMounted, setIsMounted] = React.useState(false);

  React.useEffect(() => {
    setIsMounted(true);
  }, []);

  const currentTheme = theme === "system" ? resolvedTheme : theme;

  function getNextTheme() {
    if (!isMounted) {
      return "system";
    }

    if (theme === "system") {
      return resolvedTheme === "dark" ? "light" : "dark";
    }

    return currentTheme === "dark" ? "light" : "dark";
  }

  function handleToggle() {
    const next = getNextTheme();
    setTheme(next ?? "system");
  }

  const icon = !isMounted
    ? <Monitor className="h-5 w-5" aria-hidden="true" />
    : currentTheme === "dark"
      ? <MoonStar className="h-5 w-5" aria-hidden="true" />
      : <SunMedium className="h-5 w-5" aria-hidden="true" />;

  const isDark = isMounted ? currentTheme === "dark" : false;

  return (
    <button
      type="button"
      onClick={handleToggle}
      aria-pressed={isDark}
      title={`${LABEL} (current: ${currentTheme ?? "system"})`}
      className="inline-flex h-11 w-11 items-center justify-center rounded-full border border-border bg-transparent text-foreground transition-colors hover:bg-muted focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
    >
      <span className="sr-only">{LABEL}</span>
      {icon}
    </button>
  );
}
</file>

<file path="components/ui/toast.tsx">
import * as React from "react"
import { type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import {
  toastActions,
  toastDescription,
  toastRoot,
  toastTitle,
} from "@/lib/design-system/components"
import { cn } from "@/lib/utils"
import { Button } from "./button"

type ToastRootVariants = VariantProps<typeof toastRoot>

type ToastTone = NonNullable<ToastRootVariants["tone"]>
type ToastElevation = NonNullable<ToastRootVariants["elevation"]>

type ButtonTone = NonNullable<React.ComponentProps<typeof Button>["tone"]>

export interface ToastAction {
  label: string
  onClick: () => void
}

export interface ToastProps
  extends React.HTMLAttributes<HTMLDivElement>,
    ToastRootVariants {
  title?: string
  description?: React.ReactNode
  action?: ToastAction
  dismissible?: boolean
  onClose?: () => void
}

const toneToButtonTone: Record<ToastTone, ButtonTone> = {
  info: "accent",
  success: "success",
  warning: "warn",
  danger: "danger",
}

export const Toast = React.forwardRef<HTMLDivElement, ToastProps>(
  (
    {
      title,
      description,
      action,
      dismissible = true,
      onClose,
      tone = "info",
      elevation = "sm",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const resolvedTone: ToastTone = tone ?? "info"
    const resolvedElevation: ToastElevation = elevation ?? "sm"
    const isDismissible = dismissible ?? true
    const role =
      resolvedTone === "danger" || resolvedTone === "warning" ? "alert" : "status"
    const ariaLive = role === "alert" ? "assertive" : "polite"
    const buttonTone = toneToButtonTone[resolvedTone]

    const descriptionContent = React.useMemo(() => {
      if (!description) return null

      if (typeof description === "string") {
        return <p className={cn(toastDescription({ tone: resolvedTone }))}>{description}</p>
      }

      if (React.isValidElement(description)) {
        const element = description as React.ReactElement<{ className?: string }>
        return React.cloneElement(element, {
          className: cn(
            toastDescription({ tone: resolvedTone }),
            element.props.className
          ),
        })
      }

      return (
        <div className={cn(toastDescription({ tone: resolvedTone }))}>{description}</div>
      )
    }, [description, resolvedTone])

    return (
      <div
        ref={ref}
        role={role}
        aria-live={ariaLive}
        className={cn(
          toastRoot({
            tone: resolvedTone,
            elevation: resolvedElevation,
            dismissible: isDismissible && onClose ? true : undefined,
          }),
          className
        )}
        {...props}
      >
        {title ? <p className={cn(toastTitle({ tone: resolvedTone }))}>{title}</p> : null}
        {descriptionContent}
        {children}
        {(action || (isDismissible && onClose)) && (
          <div
            className={cn(
              toastActions({ dismissible: isDismissible && onClose ? true : undefined })
            )}
          >
            {action ? (
              <Button variant="link" tone={buttonTone} onClick={action.onClick} className="px-0">
                {action.label}
              </Button>
            ) : null}
            {isDismissible && onClose ? (
              <button
                type="button"
                onClick={onClose}
                className="inline-flex size-8 items-center justify-center rounded-full text-muted-foreground transition-colors hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-background"
              >
                <span className="sr-only">Dismiss notification</span>
                <X aria-hidden="true" className="size-4" />
              </button>
            ) : null}
          </div>
        )}
      </div>
    )
  }
)

Toast.displayName = "Toast"

let toastId = 0

export type ToastQueueItem = ToastProps & { id?: string }
export type ToastQueueEntry = ToastProps & { id: string }

export const useToastQueue = (initialToasts: ToastQueueItem[] = []) => {
  const toEntry = React.useCallback((toast: ToastQueueItem): ToastQueueEntry => ({
    ...toast,
    id: toast.id ?? `toast-${++toastId}`,
  }), [])

  const [toasts, setToasts] = React.useState<ToastQueueEntry[]>(() =>
    initialToasts.map((toast) => toEntry(toast))
  )

  const addToast = React.useCallback((toast: ToastQueueItem) => {
    setToasts((previous) => [...previous, toEntry(toast)])
  }, [toEntry])

  const dismissToast = React.useCallback((id: string) => {
    setToasts((previous) => previous.filter((toast) => toast.id !== id))
  }, [])

  return { toasts, addToast, dismissToast }
}
</file>

<file path="hooks/useSubscriptionStatus.ts">
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { useAuth } from "@/components/providers/AuthProvider";
import type { BillingStatusResponse } from "@/app/api/billing/status/route";

export interface UseSubscriptionStatusOptions {
  /** Initial billing status if provided by SSR */
  initial?: BillingStatusResponse;
}

export interface UseSubscriptionStatusReturn {
  /** Whether user is a subscriber (active or valid trialing) */
  isSubscriber: boolean;
  /** Current subscription status */
  status: BillingStatusResponse["status"];
  /** Whether status is currently being fetched */
  isLoading: boolean;
  /** Manually trigger a refetch of subscription status */
  refetch: () => Promise<void>;
}

/**
 * Client-side hook for subscription status (UX decisions only).
 * Server remains authoritative for authorization.
 * 
 * @param options - Configuration options
 * @returns Subscription status and loading state
 */
export function useSubscriptionStatus(
  options?: UseSubscriptionStatusOptions
): UseSubscriptionStatusReturn {
  const { user } = useAuth();
  const [status, setStatus] = useState<BillingStatusResponse>(
    options?.initial || { isSubscriber: false, status: "none" }
  );
  const [isLoading, setIsLoading] = useState(!options?.initial);

  const fetchStatus = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/billing/status");
      
      if (!response || !response.ok) {
        throw new Error(`Failed to fetch billing status: ${response?.status || "unknown"}`);
      }

      const data: BillingStatusResponse = await response.json();
      setStatus(data);
    } catch (error) {
      console.error("Error fetching subscription status:", error);
      // Fail gracefully - default to non-subscriber
      setStatus({ isSubscriber: false, status: "none" });
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Track previous user ID to detect changes
  const prevUserIdRef = useRef<string | undefined>(user?.id);
  const hasFetchedRef = useRef(false);

  // Fetch on mount if no initial value provided
  useEffect(() => {
    if (!options?.initial && !hasFetchedRef.current) {
      hasFetchedRef.current = true;
      fetchStatus();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Only run on mount

  // Re-fetch when user ID changes (but not on initial mount)
  useEffect(() => {
    // If user logged out (user?.id became undefined), reset to non-subscriber
    if (!user?.id && prevUserIdRef.current) {
      setStatus({ isSubscriber: false, status: "none" });
      setIsLoading(false);
      hasFetchedRef.current = false;
    }
    // If user ID changed (login or account switch), refetch (skip if SSR data provided)
    else if (!options?.initial && hasFetchedRef.current && user?.id && prevUserIdRef.current !== user?.id) {
      fetchStatus();
    }
    prevUserIdRef.current = user?.id;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.id]);

  return {
    isSubscriber: status.isSubscriber,
    status: status.status,
    isLoading,
    refetch: fetchStatus,
  };
}
</file>

<file path="lib/analytics/hooks/useSessionTracking.ts">
"use client";

import { useEffect, useRef, useCallback } from "react";
import { usePathname } from "next/navigation";
import { usePostHog } from "posthog-js/react";
import { trackEvent, trackEngagement, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";

interface SessionMetrics {
  sessionStartTime: number;
  pageStartTime: number;
  totalPageViews: number;
  totalScrollDepth: number;
  maxScrollDepth: number;
  idleTime: number;
  lastActivityTime: number;
}

const SESSION_STORAGE_KEY = "testero_session_metrics";
const IDLE_THRESHOLD = 30000; // 30 seconds of inactivity = idle
const SCROLL_DEBOUNCE = 500; // Debounce scroll tracking

export function useSessionTracking(userId?: string) {
  const posthog = usePostHog();
  const pathname = usePathname();
  const metricsRef = useRef<SessionMetrics | null>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const idleTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastPathRef = useRef<string>("");

  // Initialize or retrieve session metrics
  const initializeMetrics = useCallback(() => {
    const stored = sessionStorage.getItem(SESSION_STORAGE_KEY);
    const now = Date.now();

    if (stored) {
      const parsed = JSON.parse(stored) as SessionMetrics;
      // Check if session is still valid (less than 30 min old)
      if (now - parsed.sessionStartTime < 30 * 60 * 1000) {
        metricsRef.current = {
          ...parsed,
          pageStartTime: now,
          totalPageViews: parsed.totalPageViews + 1,
          maxScrollDepth: 0,
        };
      } else {
        // Start new session
        metricsRef.current = {
          sessionStartTime: now,
          pageStartTime: now,
          totalPageViews: 1,
          totalScrollDepth: 0,
          maxScrollDepth: 0,
          idleTime: 0,
          lastActivityTime: now,
        };
      }
    } else {
      // First visit - start new session
      metricsRef.current = {
        sessionStartTime: now,
        pageStartTime: now,
        totalPageViews: 1,
        totalScrollDepth: 0,
        maxScrollDepth: 0,
        idleTime: 0,
        lastActivityTime: now,
      };
    }

    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(metricsRef.current));
  }, []);

  // Track scroll depth
  const trackScrollDepth = useCallback(() => {
    if (!metricsRef.current) return;

    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    const scrollTop = window.scrollY;
    const scrollPercentage = Math.round((scrollTop / (documentHeight - windowHeight)) * 100);

    if (scrollPercentage > metricsRef.current.maxScrollDepth) {
      metricsRef.current.maxScrollDepth = scrollPercentage;
      metricsRef.current.totalScrollDepth += scrollPercentage - metricsRef.current.maxScrollDepth;

      // Track milestone scroll depths
      if (scrollPercentage >= 25 && metricsRef.current.maxScrollDepth < 25) {
        trackEngagement(posthog, "page_depth", 25, { page: pathname }, userId);
      } else if (scrollPercentage >= 50 && metricsRef.current.maxScrollDepth < 50) {
        trackEngagement(posthog, "page_depth", 50, { page: pathname }, userId);
      } else if (scrollPercentage >= 75 && metricsRef.current.maxScrollDepth < 75) {
        trackEngagement(posthog, "page_depth", 75, { page: pathname }, userId);
      } else if (scrollPercentage >= 90 && metricsRef.current.maxScrollDepth < 90) {
        trackEngagement(posthog, "page_depth", 90, { page: pathname }, userId);
      }
    }

    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(metricsRef.current));
  }, [pathname, posthog, userId]);

  // Handle scroll with debouncing
  const handleScroll = useCallback(() => {
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }

    scrollTimeoutRef.current = setTimeout(() => {
      trackScrollDepth();
    }, SCROLL_DEBOUNCE);
  }, [trackScrollDepth]);

  // Track user activity for idle detection
  const trackActivity = useCallback(() => {
    if (!metricsRef.current) return;

    const now = Date.now();
    const timeSinceLastActivity = now - metricsRef.current.lastActivityTime;

    if (timeSinceLastActivity > IDLE_THRESHOLD) {
      metricsRef.current.idleTime += timeSinceLastActivity;
    }

    metricsRef.current.lastActivityTime = now;
    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(metricsRef.current));

    // Reset idle timer
    if (idleTimeoutRef.current) {
      clearTimeout(idleTimeoutRef.current);
    }

    idleTimeoutRef.current = setTimeout(() => {
      // User has been idle
      if (metricsRef.current) {
        metricsRef.current.idleTime += IDLE_THRESHOLD;
        trackEngagement(
          posthog,
          "session_duration",
          metricsRef.current.idleTime,
          {
            type: "idle_detected",
            page: pathname,
          },
          userId
        );
      }
    }, IDLE_THRESHOLD);
  }, [pathname, posthog, userId]);

  // Track page exit and session duration
  const trackPageExit = useCallback(() => {
    if (!metricsRef.current || !lastPathRef.current) return;

    const now = Date.now();
    const pageTime = now - metricsRef.current.pageStartTime;
    const sessionTime = now - metricsRef.current.sessionStartTime;

    // Track page-specific metrics
    trackEngagement(
      posthog,
      "session_duration",
      pageTime,
      {
        type: "page_time",
        page: lastPathRef.current,
        scroll_depth: metricsRef.current.maxScrollDepth,
      },
      userId
    );

    // Track session metrics every page change
    trackEngagement(
      posthog,
      "session_duration",
      sessionTime - metricsRef.current.idleTime,
      {
        type: "active_session_time",
        total_pages: metricsRef.current.totalPageViews,
        avg_scroll_depth: Math.round(
          metricsRef.current.totalScrollDepth / metricsRef.current.totalPageViews
        ),
      },
      userId
    );

    // Check for bounce (single page session with quick exit)
    if (metricsRef.current.totalPageViews === 1 && pageTime < 10000) {
      trackEvent(
        posthog,
        ANALYTICS_EVENTS.FEATURE_DISCOVERED,
        {
          feature_name: "bounce_detected",
          discovery_type: "quick_exit",
          page: lastPathRef.current,
          time_on_page: pageTime,
        },
        userId
      );
    }
  }, [posthog, userId]);

  // Set up event listeners
  useEffect(() => {
    initializeMetrics();

    // Track scroll depth
    window.addEventListener("scroll", handleScroll);

    // Track user activity
    window.addEventListener("mousemove", trackActivity);
    window.addEventListener("keydown", trackActivity);
    window.addEventListener("click", trackActivity);
    window.addEventListener("touchstart", trackActivity);

    // Track page visibility changes
    const handleVisibilityChange = () => {
      if (document.hidden) {
        trackPageExit();
      } else {
        if (metricsRef.current) {
          metricsRef.current.pageStartTime = Date.now();
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Track before unload
    const handleBeforeUnload = () => {
      trackPageExit();
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("mousemove", trackActivity);
      window.removeEventListener("keydown", trackActivity);
      window.removeEventListener("click", trackActivity);
      window.removeEventListener("touchstart", trackActivity);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("beforeunload", handleBeforeUnload);

      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      if (idleTimeoutRef.current) {
        clearTimeout(idleTimeoutRef.current);
      }
    };
  }, [initializeMetrics, handleScroll, trackActivity, trackPageExit]);

  // Track page changes
  useEffect(() => {
    if (pathname !== lastPathRef.current && lastPathRef.current) {
      trackPageExit();
      initializeMetrics();
    }
    lastPathRef.current = pathname;
  }, [pathname, trackPageExit, initializeMetrics]);

  return {
    sessionMetrics: metricsRef.current,
  };
}
</file>

<file path="lib/analytics/campaign-analytics-integration.ts">
import {
  parseCampaignParams,
  storeCampaignAttribution,
  addCampaignAttributionToEvent,
  CampaignParams,
} from "./campaign-attribution";
import { trackEvent, ANALYTICS_EVENTS, PostHogClient, AnalyticsEvent } from "./analytics";

/**
 * Tracks email campaign landing with attribution
 *
 * @param posthog - PostHog client (server or client-side)
 * @param campaignParams - Campaign attribution parameters
 * @param userId - User ID for server-side tracking
 */
export function trackCampaignLanding(
  posthog: PostHogClient,
  campaignParams: CampaignParams,
  userId?: string
): void {
  if (!posthog) return;

  const eventProperties = {
    ...campaignParams,
    landing_page: typeof window !== "undefined" ? window.location.pathname : "/beta/welcome",
    timestamp: Date.now(),
  };

  trackEvent(posthog, ANALYTICS_EVENTS.EMAIL_CAMPAIGN_LANDING, eventProperties, userId);
}

/**
 * Tracks diagnostic start event enhanced with campaign attribution
 *
 * @param posthog - PostHog client
 * @param diagnosticData - Base diagnostic event data
 * @param userId - User ID for server-side tracking
 */
export function trackDiagnosticStartWithCampaign(
  posthog: PostHogClient,
  diagnosticData: Record<string, unknown>,
  userId?: string
): void {
  if (!posthog) return;

  const enhancedEvent = addCampaignAttributionToEvent(diagnosticData);
  trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_STARTED, enhancedEvent, userId);
}

/**
 * Tracks diagnostic completion event enhanced with campaign attribution
 *
 * @param posthog - PostHog client
 * @param completionData - Base diagnostic completion data
 * @param userId - User ID for server-side tracking
 */
export function trackDiagnosticCompleteWithCampaign(
  posthog: PostHogClient,
  completionData: Record<string, unknown>,
  userId?: string
): void {
  if (!posthog) return;

  const enhancedEvent = addCampaignAttributionToEvent(completionData);
  trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_COMPLETED, enhancedEvent, userId);
}

/**
 * Extracts campaign attribution from current URL and stores it
 *
 * @param posthog - Optional PostHog client to track attribution event
 * @param userId - User ID for server-side tracking
 * @returns Campaign parameters or null if none found
 */
export function setCampaignAttributionFromURL(
  posthog?: PostHogClient,
  userId?: string
): CampaignParams | null {
  if (typeof window === "undefined") return null;

  const currentUrl = window.location.href;
  const campaignParams = parseCampaignParams(currentUrl);

  // Check if any campaign parameters exist
  const hasParams = Object.values(campaignParams).some((value) => value !== undefined);

  if (!hasParams) return null;

  // Store attribution
  storeCampaignAttribution(campaignParams);

  // Track attribution event if PostHog is provided
  if (posthog) {
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.CAMPAIGN_ATTRIBUTION_SET,
      {
        ...campaignParams,
        source_url: currentUrl,
      },
      userId
    );
  }

  return campaignParams;
}

/**
 * Creates an enhanced track event function that automatically adds campaign attribution
 *
 * @param posthog - PostHog client to use
 * @returns Enhanced tracking function
 */
export function createEnhancedTrackEvent(posthog: PostHogClient) {
  return function enhancedTrackEvent(
    event: AnalyticsEvent,
    properties?: Record<string, unknown>,
    userId?: string
  ): void {
    if (!posthog) return;

    const enhancedProperties = addCampaignAttributionToEvent(properties || {});
    trackEvent(posthog, event, enhancedProperties, userId);
  };
}
</file>

<file path="lib/analytics/campaign-attribution.ts">
/**
 * Campaign attribution parameters extracted from UTM and custom parameters
 * Used for tracking beta campaign performance and A/B testing
 */
export interface CampaignParams {
  /** UTM source parameter (e.g., 'loops', 'email') */
  utm_source?: string;
  /** UTM campaign parameter (e.g., 'beta_launch_2025') */
  utm_campaign?: string;
  /** Custom campaign identifier for tracking specific campaigns */
  campaign_id?: string;
  /** A/B test variant - strictly 'A' or 'B' */
  variant?: "A" | "B";
  /** Email address for attribution (URL encoded) */
  email?: string;
}

/**
 * Supported A/B test variants for beta campaign
 */
export type CampaignVariant = "A" | "B";

/**
 * Valid UTM source values for campaign attribution
 */
export const VALID_UTM_SOURCES = ["loops", "email", "direct", "social"] as const;
export type ValidUtmSource = (typeof VALID_UTM_SOURCES)[number];

/**
 * Validates if a string is a valid campaign variant
 */
function isValidVariant(value: string | null): value is CampaignVariant {
  return value === "A" || value === "B";
}

/**
 * Safely decodes a URL parameter that might be URL encoded
 */
function safeDecodeParam(param: string | null): string | undefined {
  if (!param) return undefined;
  try {
    return decodeURIComponent(param);
  } catch {
    return param; // Return original if decode fails
  }
}

/**
 * Extracts campaign attribution parameters from a URL
 *
 * @param url - The URL to parse (can be relative or absolute)
 * @returns Campaign parameters object with undefined values for missing params
 *
 * @example
 * ```typescript
 * const params = parseCampaignParams('https://site.com/page?utm_source=loops&variant=A');
 * // Returns: { utm_source: 'loops', variant: 'A', ... }
 * ```
 */
export function parseCampaignParams(url: string): CampaignParams {
  try {
    // Handle relative URLs by providing a base URL
    const urlObj = url.startsWith("http") ? new URL(url) : new URL(url, "https://example.com");
    const params = urlObj.searchParams;

    // Extract and validate variant
    const variantParam = params.get("variant");
    const variant = isValidVariant(variantParam) ? variantParam : undefined;

    return {
      utm_source: safeDecodeParam(params.get("utm_source")),
      utm_campaign: safeDecodeParam(params.get("utm_campaign")),
      campaign_id: safeDecodeParam(params.get("campaign_id")),
      variant,
      email: safeDecodeParam(params.get("email")),
    };
  } catch (error) {
    // Invalid URL - return empty object with undefined values
    console.warn(`Failed to parse campaign parameters from URL: ${url}`, error);
    return {
      utm_source: undefined,
      utm_campaign: undefined,
      campaign_id: undefined,
      variant: undefined,
      email: undefined,
    };
  }
}

/**
 * Storage key for campaign attribution in sessionStorage
 */
const CAMPAIGN_ATTRIBUTION_KEY = "testero_campaign_attribution";

/**
 * Stores campaign attribution parameters in sessionStorage
 *
 * @param attribution - Campaign parameters to store
 * @param merge - If true, merge with existing attribution instead of replacing
 */
export function storeCampaignAttribution(attribution: CampaignParams, merge = false): void {
  if (typeof window === "undefined") return; // SSR safety

  try {
    let dataToStore = attribution;

    if (merge) {
      const existing = getCampaignAttribution();
      if (existing) {
        dataToStore = { ...existing, ...attribution };
      }
    }

    window.sessionStorage.setItem(CAMPAIGN_ATTRIBUTION_KEY, JSON.stringify(dataToStore));
  } catch (error) {
    console.warn("Failed to store campaign attribution:", error);
  }
}

/**
 * Retrieves campaign attribution parameters from sessionStorage
 *
 * @returns Campaign parameters or null if none stored/error
 */
export function getCampaignAttribution(): CampaignParams | null {
  if (typeof window === "undefined") return null; // SSR safety

  try {
    const stored = window.sessionStorage.getItem(CAMPAIGN_ATTRIBUTION_KEY);
    if (!stored) return null;

    return JSON.parse(stored) as CampaignParams;
  } catch (error) {
    console.warn("Failed to retrieve campaign attribution:", error);
    return null;
  }
}

/**
 * Clears campaign attribution from sessionStorage
 */
export function clearCampaignAttribution(): void {
  if (typeof window === "undefined") return; // SSR safety

  try {
    window.sessionStorage.removeItem(CAMPAIGN_ATTRIBUTION_KEY);
  } catch (error) {
    console.warn("Failed to clear campaign attribution:", error);
  }
}

/**
 * Adds campaign attribution to an analytics event object
 * Only adds values that don't already exist in the event
 *
 * @param event - The analytics event object
 * @returns Enhanced event with campaign attribution
 */
export function addCampaignAttributionToEvent<T extends Record<string, unknown>>(event: T): T {
  const attribution = getCampaignAttribution();
  if (!attribution) return event;

  const enhanced = { ...event } as T;

  // Only add attribution values that aren't already in the event and aren't undefined
  Object.entries(attribution).forEach(([key, value]) => {
    if (value !== undefined && !(key in enhanced)) {
      (enhanced as Record<string, unknown>)[key] = value;
    }
  });

  return enhanced;
}
</file>

<file path="lib/analytics/campaign-dashboard-integration.ts">
/**
 * PostHog Dashboard Integration for Campaign Analytics
 *
 * This module provides functions to create and manage PostHog dashboards
 * specifically for email campaign tracking and performance analysis.
 */

/**
 * Configuration for creating a campaign dashboard
 */
export interface CampaignDashboardConfig {
  name: string;
  description?: string;
  campaignId: string;
  insightConfigs: CampaignInsightConfig[];
}

/**
 * Configuration for individual campaign insights
 */
export interface CampaignInsightConfig {
  name: string;
  description?: string;
  query: string;
  dateRange?: {
    date_from: string;
    date_to: string;
  };
}

/**
 * Result of dashboard creation
 */
export interface CampaignDashboardResult {
  dashboardId: string;
  dashboardUrl: string;
  insights: Array<{
    id: string;
    name: string;
    url: string;
  }>;
}

/**
 * Result of insight creation
 */
export interface CampaignInsightResult {
  id: string;
  name: string;
  short_id?: string;
}

/**
 * Result of campaign insights query
 */
export interface CampaignInsightsResult {
  query: string;
  results: Array<Record<string, unknown>>;
}

/**
 * Result of dashboard update
 */
export interface CampaignDashboardUpdateResult {
  dashboardId: string;
  newInsightId: string;
  totalInsights: number;
}

/**
 * PostHog MCP interface for type safety
 */
export interface PostHogMCP {
  "insight-create-from-query": (params: unknown) => Promise<unknown>;
  "dashboard-create": (params: unknown) => Promise<unknown>;
  "dashboard-get": (params: unknown) => Promise<unknown>;
  "add-insight-to-dashboard": (params: unknown) => Promise<unknown>;
  "get-sql-insight": (params: unknown) => Promise<unknown>;
}

/**
 * Creates a complete campaign dashboard with all insights
 */
export async function createCampaignDashboard(
  posthogMCP: PostHogMCP,
  config: CampaignDashboardConfig
): Promise<CampaignDashboardResult> {
  // Create the dashboard first
  const dashboardResponse = await posthogMCP["dashboard-create"]({
    data: {
      name: config.name,
      description: config.description,
      pinned: true,
      tags: ["campaign", "beta", "email"],
    },
  });

  const dashboardId = (dashboardResponse as { id: string }).id;
  const dashboardUrl =
    (dashboardResponse as { url?: string }).url ||
    `https://app.posthog.com/dashboard/${dashboardId}`;

  // Create all insights and add them to the dashboard
  const insights: Array<{ id: string; name: string; url: string }> = [];

  for (const insightConfig of config.insightConfigs) {
    const insightResult = await createCampaignInsights(posthogMCP, insightConfig);

    // Add insight to dashboard
    await posthogMCP["add-insight-to-dashboard"]({
      data: {
        dashboardId: dashboardId,
        insightId: insightResult.id,
      },
    });

    insights.push({
      id: insightResult.id,
      name: insightResult.name,
      url: `https://app.posthog.com/insights/${insightResult.id}`,
    });
  }

  return {
    dashboardId,
    dashboardUrl,
    insights,
  };
}

/**
 * Creates individual insights with proper HogQL queries
 */
export async function createCampaignInsights(
  posthogMCP: PostHogMCP,
  config: CampaignInsightConfig
): Promise<CampaignInsightResult> {
  const dateRange = config.dateRange || {
    date_from: "-30d",
    date_to: "now",
  };

  const response = await posthogMCP["insight-create-from-query"]({
    data: {
      name: config.name,
      description: config.description,
      query: {
        kind: "DataVisualizationNode",
        source: {
          kind: "HogQLQuery",
          query: config.query,
          filters: {
            dateRange,
          },
        },
      },
      saved: true,
      favorited: false,
      tags: ["campaign"],
    },
  });

  return {
    id: (response as { id: string }).id,
    name: (response as { name: string }).name,
    short_id: (response as { short_id?: string }).short_id,
  };
}

/**
 * Retrieves campaign data using natural language queries
 */
export async function getCampaignInsights(
  posthogMCP: PostHogMCP,
  naturalLanguageQuery: string
): Promise<CampaignInsightsResult> {
  const response = await posthogMCP["get-sql-insight"]({
    query: naturalLanguageQuery,
  });

  return {
    query: (response as { query?: string }).query || "No query generated",
    results: (response as { results?: Array<Record<string, unknown>> }).results || [],
  };
}

/**
 * Updates existing dashboard with new insights
 */
export async function updateCampaignDashboard(
  posthogMCP: PostHogMCP,
  dashboardId: string,
  newInsightConfig: CampaignInsightConfig
): Promise<CampaignDashboardUpdateResult> {
  // Get current dashboard to count existing insights
  const dashboardData = await posthogMCP["dashboard-get"]({
    dashboardId: parseInt(dashboardId.replace("dashboard_", "")),
  });

  // Create the new insight
  const newInsight = await createCampaignInsights(posthogMCP, newInsightConfig);

  // Add insight to dashboard
  await posthogMCP["add-insight-to-dashboard"]({
    data: {
      dashboardId: dashboardId,
      insightId: newInsight.id,
    },
  });

  return {
    dashboardId,
    newInsightId: newInsight.id,
    totalInsights: ((dashboardData as { insights?: unknown[] }).insights?.length || 0) + 1,
  };
}
</file>

<file path="lib/analytics/campaign-metrics.ts">
/**
 * Core data structure for campaign metrics
 */
export interface CampaignMetricsData {
  emails_sent: number;
  emails_opened?: number;
  emails_clicked?: number;
  landing_page_views?: number;
  diagnostic_sessions_started?: number;
  diagnostic_sessions_completed?: number;
  bounce_rate?: number;
  unsubscribe_rate?: number;
}

/**
 * Funnel conversion metrics
 */
export interface FunnelMetrics {
  open_rate: number;
  click_through_rate: number;
  click_to_landing_rate: number;
  landing_to_diagnostic_rate: number;
  diagnostic_completion_rate: number;
  overall_conversion_rate: number;
  total_dropoff: number;
  largest_dropoff_stage: string;
  largest_dropoff_amount: number;
}

/**
 * A/B test variant comparison results
 */
export interface VariantComparison {
  variant_a_conversion_rate: number;
  variant_b_conversion_rate: number;
  conversion_rate_lift: number;
  relative_lift_percentage: number;
  winner: "A" | "B" | "tie";
  statistical_significance: boolean;
  confidence_level?: number;
}

/**
 * Time-based conversion rate analysis
 */
export interface ConversionRates {
  hourly_rates: Array<{ timestamp: number; rate: number }>;
  current_rate: number;
  average_rate: number;
  trend: "improving" | "declining" | "stable";
}

/**
 * Time series data point
 */
export interface TimeSeriesDataPoint {
  timestamp: number;
  emails_sent: number;
  completed: number;
}

/**
 * Event data structure for aggregation
 */
export interface EventData {
  event: string;
  properties: {
    campaign_id?: string;
    [key: string]: unknown;
  };
}

/**
 * Loops email platform data structure
 */
export interface LoopsData {
  emails_sent: number;
  emails_opened?: number;
  emails_clicked?: number;
  bounce_rate?: number;
  unsubscribe_rate?: number;
}

/**
 * Safely calculates percentage, handling division by zero
 */
function safePercentage(numerator: number, denominator: number): number {
  if (denominator === 0) return 0;
  return Math.round((numerator / denominator) * 10000) / 100; // Round to 2 decimal places
}

/**
 * Calculates comprehensive funnel metrics for a campaign
 */
export function calculateCampaignFunnelMetrics(data: CampaignMetricsData): FunnelMetrics {
  const {
    emails_sent,
    emails_opened = 0,
    emails_clicked = 0,
    landing_page_views = 0,
    diagnostic_sessions_started = 0,
    diagnostic_sessions_completed = 0,
  } = data;

  // Calculate basic conversion rates
  const open_rate = safePercentage(emails_opened, emails_sent);
  const click_through_rate = safePercentage(emails_clicked, emails_sent);
  const click_to_landing_rate = safePercentage(landing_page_views, emails_clicked);
  const landing_to_diagnostic_rate = safePercentage(
    diagnostic_sessions_started,
    landing_page_views
  );
  const diagnostic_completion_rate = safePercentage(
    diagnostic_sessions_completed,
    diagnostic_sessions_started
  );
  const overall_conversion_rate = safePercentage(diagnostic_sessions_completed, emails_sent);

  // Calculate dropoff analysis
  const total_dropoff = safePercentage(emails_sent - diagnostic_sessions_completed, emails_sent);

  // Find largest dropoff stage
  const dropoffs = [
    { stage: "email_open", amount: emails_sent - emails_opened },
    { stage: "email_click", amount: emails_opened - emails_clicked },
    { stage: "click_to_landing", amount: emails_clicked - landing_page_views },
    { stage: "landing_to_diagnostic", amount: landing_page_views - diagnostic_sessions_started },
    {
      stage: "diagnostic_completion",
      amount: diagnostic_sessions_started - diagnostic_sessions_completed,
    },
  ];

  const largestDropoff = dropoffs.reduce((max, current) =>
    current.amount > max.amount ? current : max
  );

  return {
    open_rate,
    click_through_rate,
    click_to_landing_rate,
    landing_to_diagnostic_rate,
    diagnostic_completion_rate,
    overall_conversion_rate,
    total_dropoff,
    largest_dropoff_stage: largestDropoff.stage,
    largest_dropoff_amount: largestDropoff.amount,
  };
}

/**
 * Compares two campaign variants for A/B testing
 */
export function calculateVariantComparison(
  variantA: Partial<CampaignMetricsData>,
  variantB: Partial<CampaignMetricsData>
): VariantComparison {
  const aConversionRate = safePercentage(
    variantA.diagnostic_sessions_completed || 0,
    variantA.emails_sent || 0
  );

  const bConversionRate = safePercentage(
    variantB.diagnostic_sessions_completed || 0,
    variantB.emails_sent || 0
  );

  const conversion_rate_lift = Math.round((aConversionRate - bConversionRate) * 100) / 100;
  const relative_lift_percentage = safePercentage(
    Math.abs(conversion_rate_lift),
    Math.min(aConversionRate, bConversionRate)
  );

  let winner: "A" | "B" | "tie" = "tie";
  if (aConversionRate > bConversionRate) winner = "A";
  else if (bConversionRate > aConversionRate) winner = "B";

  // Simple statistical significance calculation (z-test for proportions)
  const totalA = variantA.emails_sent || 0;
  const totalB = variantB.emails_sent || 0;
  const successA = variantA.diagnostic_sessions_completed || 0;
  const successB = variantB.diagnostic_sessions_completed || 0;

  let statistical_significance = false;
  let confidence_level: number | undefined;

  if (totalA > 30 && totalB > 30) {
    // Basic sample size requirement
    const p1 = successA / totalA;
    const p2 = successB / totalB;
    const pooled = (successA + successB) / (totalA + totalB);
    const se = Math.sqrt(pooled * (1 - pooled) * (1 / totalA + 1 / totalB));
    const z = Math.abs(p1 - p2) / se;

    // z > 1.96 indicates 95% confidence
    if (z > 1.96) {
      statistical_significance = true;
      confidence_level = 95 + (z - 1.96) * 2.5; // Rough confidence level
      confidence_level = Math.min(confidence_level, 99.9);
    }
  }

  return {
    variant_a_conversion_rate: aConversionRate,
    variant_b_conversion_rate: bConversionRate,
    conversion_rate_lift,
    relative_lift_percentage,
    winner,
    statistical_significance,
    confidence_level,
  };
}

/**
 * Calculates time-based conversion rates and trends
 */
export function calculateConversionRates(timeSeriesData: TimeSeriesDataPoint[]): ConversionRates {
  // Sort by timestamp (most recent first)
  const sortedData = [...timeSeriesData].sort((a, b) => b.timestamp - a.timestamp);

  const hourly_rates = sortedData.map((point) => ({
    timestamp: point.timestamp,
    rate: safePercentage(point.completed, point.emails_sent),
  }));

  const current_rate = hourly_rates[0]?.rate || 0;

  // Calculate average rate across all time periods
  const totalCompleted = sortedData.reduce((sum, point) => sum + point.completed, 0);
  const totalSent = sortedData.reduce((sum, point) => sum + point.emails_sent, 0);
  const average_rate = safePercentage(totalCompleted, totalSent);

  // Determine trend
  let trend: "improving" | "declining" | "stable" = "stable";
  const tolerance = 0.5; // 0.5% tolerance for "stable"

  if (current_rate > average_rate + tolerance) {
    trend = "improving";
  } else if (current_rate < average_rate - tolerance) {
    trend = "declining";
  }

  return {
    hourly_rates,
    current_rate,
    average_rate,
    trend,
  };
}

/**
 * Aggregates campaign data from multiple sources (Loops + PostHog)
 */
export function aggregateCampaignData(
  loopsData: Partial<LoopsData>,
  posthogEvents: EventData[],
  campaignId?: string
): CampaignMetricsData {
  // Filter PostHog events by campaign ID if provided
  const relevantEvents = campaignId
    ? posthogEvents.filter((event) => event.properties.campaign_id === campaignId)
    : posthogEvents;

  // Count specific event types
  const landing_page_views = relevantEvents.filter(
    (event) => event.event === "email_campaign_landing"
  ).length;

  const diagnostic_sessions_started = relevantEvents.filter(
    (event) => event.event === "diagnostic_started"
  ).length;

  const diagnostic_sessions_completed = relevantEvents.filter(
    (event) => event.event === "diagnostic_completed"
  ).length;

  return {
    emails_sent: loopsData.emails_sent || 0,
    emails_opened: loopsData.emails_opened || 0,
    emails_clicked: loopsData.emails_clicked || 0,
    landing_page_views,
    diagnostic_sessions_started,
    diagnostic_sessions_completed,
    bounce_rate: loopsData.bounce_rate,
    unsubscribe_rate: loopsData.unsubscribe_rate,
  };
}
</file>

<file path="lib/analytics/funnels.ts">
import { trackEvent, ANALYTICS_EVENTS, PostHogClient } from "./analytics";

// Funnel step definitions
export const FUNNEL_STEPS = {
  // Activation Funnel
  ACTIVATION: {
    LANDING: "activation_landing",
    SIGNUP_START: "activation_signup_start",
    EMAIL_VERIFY: "activation_email_verify",
    FIRST_DIAGNOSTIC: "activation_first_diagnostic",
    DIAGNOSTIC_COMPLETE: "activation_diagnostic_complete",
    ACTIVATED: "activation_complete",
  },

  // Purchase Funnel
  PURCHASE: {
    PRICING_VIEW: "purchase_pricing_view",
    PLAN_SELECT: "purchase_plan_select",
    CHECKOUT_START: "purchase_checkout_start",
    PAYMENT_INFO: "purchase_payment_info",
    PAYMENT_COMPLETE: "purchase_payment_complete",
  },

  // Retention Funnel
  RETENTION: {
    LOGIN: "retention_login",
    DASHBOARD: "retention_dashboard",
    PRACTICE_START: "retention_practice_start",
    PRACTICE_COMPLETE: "retention_practice_complete",
    RETURN_NEXT_DAY: "retention_return_next_day",
    RETURN_WEEK: "retention_return_week",
  },

  // Feature Adoption Funnel
  FEATURE_ADOPTION: {
    DISCOVER: "feature_adoption_discover",
    TRY: "feature_adoption_try",
    USE: "feature_adoption_use",
    HABIT: "feature_adoption_habit",
  },
} as const;

// Type definitions
export type FunnelName = keyof typeof FUNNEL_STEPS;
export type FunnelStep<T extends FunnelName> =
  (typeof FUNNEL_STEPS)[T][keyof (typeof FUNNEL_STEPS)[T]];

// Funnel state management
const FUNNEL_STORAGE_KEY = "testero_funnel_state";

interface FunnelState {
  [key: string]: {
    currentStep: string;
    startTime: number;
    stepTimes: Record<string, number>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    metadata?: Record<string, any>;
  };
}

// Get current funnel state from sessionStorage
function getFunnelState(): FunnelState {
  if (typeof window === "undefined") return {};

  const stored = sessionStorage.getItem(FUNNEL_STORAGE_KEY);
  return stored ? JSON.parse(stored) : {};
}

// Save funnel state to sessionStorage
function saveFunnelState(state: FunnelState) {
  if (typeof window === "undefined") return;

  sessionStorage.setItem(FUNNEL_STORAGE_KEY, JSON.stringify(state));
}

// Track funnel step progression
export function trackFunnelStep<T extends FunnelName>(
  posthog: PostHogClient,
  funnelName: T,
  step: FunnelStep<T>,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  if (!posthog) return;

  const state = getFunnelState();
  const now = Date.now();
  const stepStr = step as string; // Type assertion for string indexing

  // Initialize funnel if first step
  if (!state[funnelName]) {
    state[funnelName] = {
      currentStep: stepStr,
      startTime: now,
      stepTimes: { [stepStr]: now },
      metadata: properties,
    };
  } else {
    // Calculate time since last step
    const lastStepTime = Math.max(...Object.values(state[funnelName].stepTimes));
    const timeSinceLastStep = now - lastStepTime;
    const totalFunnelTime = now - state[funnelName].startTime;
    const previousStep = state[funnelName].currentStep;

    // Update state
    state[funnelName].currentStep = stepStr;
    state[funnelName].stepTimes[stepStr] = now;

    // Track step transition
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.FEATURE_USED,
      {
        funnel_name: funnelName,
        funnel_step: stepStr,
        previous_step: previousStep,
        time_since_last_step: timeSinceLastStep,
        total_funnel_time: totalFunnelTime,
        step_number: Object.keys(state[funnelName].stepTimes).length,
        ...properties,
      },
      userId
    );
  }

  saveFunnelState(state);

  // Track funnel entry
  if (Object.keys(state[funnelName].stepTimes).length === 1) {
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.FEATURE_DISCOVERED,
      {
        funnel_name: funnelName,
        entry_step: stepStr,
        discovery_type: "funnel_start",
        ...properties,
      },
      userId
    );
  }
}

// Track funnel completion
export function trackFunnelComplete<T extends FunnelName>(
  posthog: PostHogClient,
  funnelName: T,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  if (!posthog) return;

  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) {
    console.warn(`Funnel ${funnelName} not found in state`);
    return;
  }

  const now = Date.now();
  const totalTime = now - funnelData.startTime;
  const stepCount = Object.keys(funnelData.stepTimes).length;

  // Calculate step durations
  const stepDurations: Record<string, number> = {};
  const sortedSteps = Object.entries(funnelData.stepTimes).sort(([, a], [, b]) => a - b);

  for (let i = 0; i < sortedSteps.length - 1; i++) {
    const [currentStep, currentTime] = sortedSteps[i];
    const [, nextTime] = sortedSteps[i + 1];
    stepDurations[currentStep] = nextTime - currentTime;
  }

  // Track completion event
  trackEvent(
    posthog,
    ANALYTICS_EVENTS.TRIAL_TO_PAID_CONVERSION,
    {
      funnel_name: funnelName,
      total_time: totalTime,
      step_count: stepCount,
      step_durations: stepDurations,
      completion_rate: 100,
      ...funnelData.metadata,
      ...properties,
    },
    userId
  );

  // Clear funnel from state
  delete state[funnelName];
  saveFunnelState(state);
}

// Track funnel abandonment
export function trackFunnelAbandonment<T extends FunnelName>(
  posthog: PostHogClient,
  funnelName: T,
  reason?: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  if (!posthog) return;

  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) return;

  const now = Date.now();
  const totalTime = now - funnelData.startTime;
  const lastStep = funnelData.currentStep;
  const stepCount = Object.keys(funnelData.stepTimes).length;

  // Track abandonment event
  trackEvent(
    posthog,
    ANALYTICS_EVENTS.DIAGNOSTIC_ABANDONED,
    {
      funnel_name: funnelName,
      abandonment_step: lastStep,
      abandonment_reason: reason,
      total_time: totalTime,
      step_count: stepCount,
      completion_rate: (stepCount / Object.keys(FUNNEL_STEPS[funnelName]).length) * 100,
      ...funnelData.metadata,
      ...properties,
    },
    userId
  );

  // Clear funnel from state
  delete state[funnelName];
  saveFunnelState(state);
}

// Helper to track exit intent
export function trackExitIntent(
  posthog: PostHogClient,
  currentPage: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  const state = getFunnelState();
  const activeFunnels = Object.keys(state);

  if (activeFunnels.length > 0) {
    // User is leaving with active funnels
    activeFunnels.forEach((funnelName) => {
      trackFunnelAbandonment(
        posthog,
        funnelName as FunnelName,
        "exit_intent",
        {
          exit_page: currentPage,
          ...properties,
        },
        userId
      );
    });
  }
}

// Specialized funnel tracking functions
export function trackActivationFunnel(
  posthog: PostHogClient,
  step: keyof typeof FUNNEL_STEPS.ACTIVATION,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  trackFunnelStep(posthog, "ACTIVATION", FUNNEL_STEPS.ACTIVATION[step], properties, userId);
}

export function trackPurchaseFunnel(
  posthog: PostHogClient,
  step: keyof typeof FUNNEL_STEPS.PURCHASE,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  trackFunnelStep(posthog, "PURCHASE", FUNNEL_STEPS.PURCHASE[step], properties, userId);
}

export function trackRetentionFunnel(
  posthog: PostHogClient,
  step: keyof typeof FUNNEL_STEPS.RETENTION,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  trackFunnelStep(posthog, "RETENTION", FUNNEL_STEPS.RETENTION[step], properties, userId);
}

// Funnel optimization helpers
export function calculateFunnelDropoff(posthog: PostHogClient, funnelName: FunnelName): number {
  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) return 0;

  const totalSteps = Object.keys(FUNNEL_STEPS[funnelName]).length;
  const completedSteps = Object.keys(funnelData.stepTimes).length;

  return ((totalSteps - completedSteps) / totalSteps) * 100;
}

export function getFunnelMetrics(funnelName: FunnelName) {
  const state = getFunnelState();
  const funnelData = state[funnelName];

  if (!funnelData) return null;

  const now = Date.now();
  const totalTime = now - funnelData.startTime;
  const stepCount = Object.keys(funnelData.stepTimes).length;
  const totalSteps = Object.keys(FUNNEL_STEPS[funnelName]).length;

  return {
    currentStep: funnelData.currentStep,
    stepCount,
    totalSteps,
    completionRate: (stepCount / totalSteps) * 100,
    totalTime,
    averageStepTime: totalTime / stepCount,
    metadata: funnelData.metadata,
  };
}
</file>

<file path="lib/analytics/server-analytics.ts">
import { PostHog } from "posthog-node";

// Server-side PostHog instance for API routes
let serverPostHog: PostHog | null | undefined;

export function getServerPostHog(): PostHog | null {
  if (typeof serverPostHog === "undefined") {
    const apiKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;

    serverPostHog = apiKey
      ? new PostHog(apiKey, {
          host: process.env.NEXT_PUBLIC_POSTHOG_HOST || "https://app.posthog.com",
        })
      : null;
  }

  return serverPostHog ?? null;
}

// Reset function for testing
export function resetServerPostHog() {
  serverPostHog = undefined;
}
</file>

<file path="lib/auth/entitlements.ts">
import { LRUCache } from "lru-cache";
import { createServerSupabaseClient } from "@/lib/supabase/server";

interface CacheEntry {
  isSubscriber: boolean;
  timestamp: number;
}

// LRU cache with TTL: 60 seconds, max 500 entries
const subscriberCache = new LRUCache<string, CacheEntry>({
  max: 500,
  ttl: 60 * 1000, // 60 seconds in milliseconds
});

/**
 * Check if a user has an active or trialing subscription.
 * Results are cached for 60 seconds to reduce database queries.
 *
 * @param userId - The user ID to check
 * @returns Promise<boolean> - true if user has active/trialing subscription, false otherwise
 */
export async function isSubscriber(userId: string): Promise<boolean> {
  // Check cache first
  const cached = subscriberCache.get(userId);
  if (cached) {
    return cached.isSubscriber;
  }

  // Query database
  const supabase = createServerSupabaseClient();
  const { data, error } = await supabase
    .from("user_subscriptions")
    .select("id, status")
    .eq("user_id", userId)
    .in("status", ["active", "trialing"]);

  // Return false on error or no subscription
  const hasSubscription = !error && data && data.length > 0;

  // Cache the result
  subscriberCache.set(userId, {
    isSubscriber: hasSubscription,
    timestamp: Date.now(),
  });

  return hasSubscription;
}

/**
 * Clear the subscriber cache for a specific user.
 * Useful when subscription status changes and cache needs invalidation.
 *
 * @param userId - The user ID to clear from cache
 */
export function clearSubscriberCache(userId: string): void {
  subscriberCache.delete(userId);
}

/**
 * Clear all cached subscriber entries.
 * Useful for testing or cache invalidation scenarios.
 */
export function clearAllSubscriberCache(): void {
  subscriberCache.clear();
}
</file>

<file path="lib/auth/require-subscriber.ts">
import { NextRequest, NextResponse } from "next/server";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { isSubscriber } from "@/lib/auth/entitlements";
import { getServerPostHog } from "@/lib/analytics/server-analytics";
import { trackEvent, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";
import { verifyGraceCookie, hasGraceCookie, clearGraceCookie } from "@/lib/billing/grace-cookie";
import { isBillingEnforcementActive } from "@/lib/billing/enforcement";

/**
 * Create structured log entry for paywall block
 */
function createPaywallLog(route: string, userId: string | null, reason: string): string {
  return JSON.stringify({
    event: "paywall_block",
    route,
    userId,
    reason,
    ts: new Date().toISOString(),
  });
}

/**
 * Require subscriber access for premium API routes.
 * 
 * Checks in order:
 * 1. Billing enforcement flag - if disabled, allows all access
 * 2. Valid grace cookie (checkout_grace) - allows access without auth
 * 3. Authenticated user with active/trialing subscription
 * 
 * Returns null if access is granted, or NextResponse with 403 if blocked.
 * Grace cookies are cleared on first successful entitlement pass or when expired/invalid.
 * 
 * @param req - Request or NextRequest object
 * @param route - Route path for logging (e.g., "/api/questions/current")
 * @returns Promise<NextResponse | null> - null if allowed, NextResponse with 403 if blocked
 */
export async function requireSubscriber(
  req: Request | NextRequest,
  route: string
): Promise<NextResponse | null> {
  // When billing enforcement is disabled, never block (no paywall in this environment)
  if (!isBillingEnforcementActive()) {
    return null;
  }

  // Check grace cookie first
  const hasGrace = hasGraceCookie(req);
  const isValidGrace = verifyGraceCookie(req);
  
  if (hasGrace && isValidGrace) {
    // Valid grace cookie - allow access
    // Cookie will be cleared by caller when they detect successful subscription check
    return null;
  }
  
  // If grace cookie exists but is invalid/expired, clear it and continue checking
  // We don't block immediately - let auth/subscription checks proceed
  if (hasGrace && !isValidGrace) {
    // Cookie is present but invalid/expired - log but continue to auth checks
    const logEntry = createPaywallLog(route, null, "grace_cookie_expired_or_invalid");
    console.log(logEntry);
  }

  // Check authentication
  const supabase = createServerSupabaseClient();
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    // Unauthenticated - block
    const logEntry = createPaywallLog(route, null, "unauthenticated");
    console.log(logEntry);

    const posthog = getServerPostHog();
    if (posthog) {
      trackEvent(
        posthog,
        ANALYTICS_EVENTS.ENTITLEMENT_CHECK_FAILED,
        {
          route,
          reason: "unauthenticated",
          userId: null,
        },
        undefined
      );
    }

    return NextResponse.json({ code: "PAYWALL" }, { status: 403 });
  }

  // Check subscription status
  const hasSubscription = await isSubscriber(user.id);

  if (!hasSubscription) {
    // Not a subscriber - block
    // If grace cookie exists but is invalid, clear it in the error response
    const response = NextResponse.json({ code: "PAYWALL" }, { status: 403 });
    
    if (hasGrace && !isValidGrace) {
      // Clear invalid/expired grace cookie
      const { name, value, options } = clearGraceCookie();
      response.cookies.set(name, value, options);
    }
    
    const logEntry = createPaywallLog(route, user.id, "not_subscriber");
    console.log(logEntry);

    const posthog = getServerPostHog();
    if (posthog) {
      trackEvent(
        posthog,
        ANALYTICS_EVENTS.ENTITLEMENT_CHECK_FAILED,
        {
          route,
          reason: "not_subscriber",
          userId: user.id,
        },
        user.id
      );
    }

    return response;
  }

  // User is authenticated and has subscription - allow
  // Note: Grace cookie clearing on successful entitlement pass should be handled
  // by the caller in their response, or by middleware/access.ts
  return null;
}
</file>

<file path="lib/billing/access.ts">
import { NextRequest } from "next/server";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { getBillingEnforcement } from "@/lib/config/billing";
import { verifyGraceCookie, hasGraceCookie } from "@/lib/billing/grace-cookie";
import { getServerPostHog } from "@/lib/analytics/server-analytics";
import { trackEvent, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";

interface CacheEntry {
  value: boolean;
  expiresAt: number;
}

// Per-user LRU cache with TTL
const cache = new Map<string, CacheEntry>();
const accessOrder: string[] = [];
const MAX_CACHE_SIZE = 1000;
const POSITIVE_TTL_MS = 60 * 1000; // 60 seconds
const NEGATIVE_TTL_MS = 30 * 1000; // 30 seconds

function updateAccessOrder(userId: string): void {
  // Remove from current position
  const index = accessOrder.indexOf(userId);
  if (index > -1) {
    accessOrder.splice(index, 1);
  }
  // Add to end (most recently used)
  accessOrder.push(userId);
}

function evictIfNeeded(): void {
  if (cache.size >= MAX_CACHE_SIZE) {
    // Remove least recently used
    const lru = accessOrder.shift();
    if (lru) {
      cache.delete(lru);
    }
  }
}

function getCachedValue(userId: string): boolean | null {
  const entry = cache.get(userId);
  if (!entry) {
    return null;
  }

  const now = Date.now();
  if (now >= entry.expiresAt) {
    cache.delete(userId);
    const index = accessOrder.indexOf(userId);
    if (index > -1) {
      accessOrder.splice(index, 1);
    }
    return null;
  }

  updateAccessOrder(userId);
  return entry.value;
}

function setCachedValue(userId: string, value: boolean): void {
  const now = Date.now();
  const ttl = value ? POSITIVE_TTL_MS : NEGATIVE_TTL_MS;
  const expiresAt = now + ttl;

  if (!cache.has(userId)) {
    evictIfNeeded();
  }

  cache.set(userId, { value, expiresAt });
  updateAccessOrder(userId);
}

function computeSubscriptionEntitlement(
  status: string,
  cancelAtPeriodEnd: boolean,
  currentPeriodEnd: string | null
): boolean {
  const now = new Date();
  const periodEnd = currentPeriodEnd ? new Date(currentPeriodEnd) : null;

  // Active or trialing status grants access
  if (status === "active" || status === "trialing") {
    // If cancel_at_period_end is true, check if period hasn't ended yet
    if (cancelAtPeriodEnd && periodEnd) {
      return now < periodEnd;
    }
    // If cancel_at_period_end is false, grant access
    return true;
  }

  // All other statuses (past_due, canceled, etc.) do not grant access
  return false;
}

/**
 * Check if a user has an active subscription
 * Results are cached per user with TTL (60s for positive, 30s for negative)
 */
export async function isSubscriber(userId: string): Promise<boolean> {
  // Check cache first
  const cached = getCachedValue(userId);
  if (cached !== null) {
    return cached;
  }

  // Query database
  const supabase = createServerSupabaseClient();
  const { data, error } = await supabase
    .from("user_subscriptions")
    .select("status, cancel_at_period_end, current_period_end")
    .eq("user_id", userId)
    .order("current_period_end", { ascending: false })
    .limit(1)
    .single();

  if (error || !data) {
    // No subscription found or error
    setCachedValue(userId, false);
    return false;
  }

  const isEntitled = computeSubscriptionEntitlement(
    data.status,
    data.cancel_at_period_end || false,
    data.current_period_end
  );

  setCachedValue(userId, isEntitled);
  return isEntitled;
}

export interface AccessResult {
  allowed: boolean;
  code?: string;
  details?: {
    route?: string;
    computed_status?: string;
    cancel_at_period_end?: boolean;
    current_period_end?: string | null;
    request_id?: string;
  };
}

/**
 * Require subscriber access based on feature flag
 * Returns access result object that caller can map to HTTP response
 */
export async function requireSubscriber(
  req: NextRequest | Request,
  userId: string
): Promise<AccessResult> {
  const enforcement = getBillingEnforcement();

  // Feature flag: 'off' always allows
  if (enforcement === "off") {
    return { allowed: true };
  }

  // Feature flag: 'active_required' checks subscription or grace cookie
  if (enforcement === "active_required") {
    const hasSubscription = await isSubscriber(userId);
    const hasValidGraceCookie = verifyGraceCookie(req);
    const graceCookiePresent = hasGraceCookie(req);

    // Clear grace cookie if subscription is active (first successful entitlement pass)
    if (hasSubscription && graceCookiePresent) {
      // Return access result with cookie clearing instruction
      // The caller should clear the cookie in their response
      return { allowed: true };
    }

    // Clear invalid/expired grace cookie
    if (graceCookiePresent && !hasValidGraceCookie) {
      // Cookie is present but invalid/expired - will be cleared by caller
    }

    if (hasSubscription || hasValidGraceCookie) {
      return { allowed: true };
    }

    // Blocked - gather details for logging and analytics
    const supabase = createServerSupabaseClient();
    const { data } = await supabase
      .from("user_subscriptions")
      .select("status, cancel_at_period_end, current_period_end")
      .eq("user_id", userId)
      .order("current_period_end", { ascending: false })
      .limit(1)
      .single();

    const route = req instanceof NextRequest
      ? req.nextUrl.pathname
      : new URL(req.url).pathname;

    const requestId =
      req.headers.get("x-request-id") || req.headers.get("x-vercel-id") || undefined;

    const details = {
      route,
      computed_status: data?.status,
      cancel_at_period_end: data?.cancel_at_period_end || false,
      current_period_end: data?.current_period_end || null,
      request_id: requestId,
    };

    // Structured logging
    console.warn({
      paywall_block: {
        user_id: userId,
        ...details,
      },
    });

    // Analytics event
    const posthog = getServerPostHog();
    trackEvent(
      posthog,
      ANALYTICS_EVENTS.ENTITLEMENT_CHECK_FAILED,
      {
        user_id: userId,
        ...details,
      },
      userId
    );

    return {
      allowed: false,
      code: "PAYWALL",
      details,
    };
  }

  // Unknown enforcement mode - default to allow
  return { allowed: true };
}

/**
 * Clear cache - exposed for testing purposes only
 */
export function clearCache(): void {
  cache.clear();
  accessOrder.length = 0;
}
</file>

<file path="lib/billing/enforcement.ts">
/**
 * Billing enforcement configuration helper
 * Checks if billing enforcement is active via environment variable
 */
export function isBillingEnforcementActive(): boolean {
  return process.env.BILLING_ENFORCEMENT === "active_required";
}
</file>

<file path="lib/billing/gated-layout.ts">
import { redirect } from "next/navigation";
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { isBillingEnforcementActive } from "@/lib/billing/enforcement";
import { isSubscriber } from "@/lib/billing/is-subscriber";

type FeatureName = "diagnostic" | "practice";

/**
 * Creates a redirect URL for gated features
 */
function createGatedRedirectUrl(feature: FeatureName): string {
  return `/pricing?gated=1&feature=${feature}`;
}

/**
 * Checks if user should have access to gated content
 * Returns true if access is allowed, false if redirect should occur
 */
async function checkAccess(): Promise<boolean> {
  try {
    const supabase = createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    return user ? await isSubscriber(user.id) : false;
  } catch (error) {
    // Handle any errors (auth failure, network issues, etc.)
    // Fail closed - redirect to pricing if check fails
    console.error("Error checking access:", error);
    return false;
  }
}

/**
 * Server-side layout gating for premium features
 * Redirects to pricing page if enforcement is active and user is not a subscriber
 */
export function createGatedLayout(feature: FeatureName) {
  return async function Layout({ children }: { children: React.ReactNode }) {
    // If enforcement is not active, allow all access
    if (!isBillingEnforcementActive()) {
      return children;
    }

    // Check user authentication and subscription status
    const allowed = await checkAccess();
    
    if (!allowed) {
      redirect(createGatedRedirectUrl(feature));
    }

    return children;
  };
}
</file>

<file path="lib/billing/grace-cookie.ts">
import { NextRequest } from "next/server";
import { createHmac } from "crypto";
import type { SerializeOptions } from "cookie";

export const PAYWALL_GRACE_COOKIE = "checkout_grace";
const GRACE_COOKIE_TTL_SECONDS = 900; // 15 minutes

export interface SignedCookie {
  name: string;
  value: string;
  options: SerializeOptions;
}

/**
 * Sign a grace cookie indicating successful checkout
 * Cookie expires in 15 minutes
 */
export function signGraceCookie(): SignedCookie {
  const secret = process.env.PAYWALL_SIGNING_SECRET;
  if (!secret) {
    throw new Error("PAYWALL_SIGNING_SECRET environment variable is required");
  }

  const now = Math.floor(Date.now() / 1000);
  const exp = now + GRACE_COOKIE_TTL_SECONDS;

  const payload = JSON.stringify({ checkoutSuccess: true, exp });
  const signature = createHmac("sha256", secret).update(payload).digest("base64url");
  const value = `${Buffer.from(payload).toString("base64url")}.${signature}`;

  return {
    name: PAYWALL_GRACE_COOKIE,
    value,
    options: {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      path: "/",
      maxAge: GRACE_COOKIE_TTL_SECONDS,
    },
  };
}

/**
 * Verify a grace cookie from request
 * Returns true if cookie is valid and not expired
 */
export function verifyGraceCookie(req: NextRequest | Request): boolean {
  const secret = process.env.PAYWALL_SIGNING_SECRET;
  if (!secret) {
    return false;
  }

  // Extract cookie value from request
  let cookieValue: string | null = null;

  if (req instanceof NextRequest) {
    cookieValue = req.cookies.get(PAYWALL_GRACE_COOKIE)?.value || null;
  } else {
    // Standard Request object - parse cookie header manually
    const cookieHeader = req.headers.get("cookie");
    if (cookieHeader) {
      const cookies = cookieHeader.split(";").map((c) => c.trim().split("="));
      const cookie = cookies.find(([name]) => name === PAYWALL_GRACE_COOKIE);
      cookieValue = cookie?.[1] || null;
    }
  }

  if (!cookieValue) {
    return false;
  }

  try {
    // Parse value: base64url(payload).signature
    const [encodedPayload, signature] = cookieValue.split(".");
    if (!encodedPayload || !signature) {
      return false;
    }

    // Decode payload
    const payload = JSON.parse(Buffer.from(encodedPayload, "base64url").toString("utf-8"));

    // Verify signature
    const expectedSignature = createHmac("sha256", secret).update(JSON.stringify(payload)).digest("base64url");
    if (signature !== expectedSignature) {
      return false;
    }

    // Verify expiration
    const now = Math.floor(Date.now() / 1000);
    if (payload.exp && payload.exp < now) {
      return false;
    }

    // Verify checkoutSuccess flag
    if (payload.checkoutSuccess !== true) {
      return false;
    }

    return true;
  } catch {
    return false;
  }
}

/**
 * Get grace cookie value from request
 */
export function getGraceCookieValue(req: NextRequest | Request): string | null {
  if (req instanceof NextRequest) {
    return req.cookies.get(PAYWALL_GRACE_COOKIE)?.value || null;
  } else {
    // Standard Request object - parse cookie header manually
    const cookieHeader = req.headers.get("cookie");
    if (cookieHeader) {
      const cookies = cookieHeader.split(";").map((c) => c.trim().split("="));
      const cookie = cookies.find(([name]) => name === PAYWALL_GRACE_COOKIE);
      return cookie?.[1] || null;
    }
  }
  return null;
}

/**
 * Check if grace cookie exists in request (regardless of validity)
 */
export function hasGraceCookie(req: NextRequest | Request): boolean {
  return getGraceCookieValue(req) !== null;
}

/**
 * Get cookie clearing options
 * Returns cookie options to clear the grace cookie
 */
export function clearGraceCookie(): SignedCookie {
  return {
    name: PAYWALL_GRACE_COOKIE,
    value: "",
    options: {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      path: "/",
      maxAge: 0,
    },
  };
}
</file>

<file path="lib/billing/is-subscriber.ts">
import { createServerSupabaseClient } from "@/lib/supabase/server";
import { computeIsSubscriber } from "@/lib/billing/subscription-status";

/**
 * Checks if a user has an active or valid trialing subscription
 * @param userId - The Supabase user ID
 * @returns true if user has active subscription or valid trialing subscription (trial_ends_at in future)
 */
export async function isSubscriber(userId: string): Promise<boolean> {
  try {
    const supabase = createServerSupabaseClient();
    
    const { data, error } = await supabase
      .from("user_subscriptions")
      .select("status, trial_ends_at")
      .eq("user_id", userId)
      .in("status", ["active", "trialing"])
      .limit(1)
      .maybeSingle();

    if (error || !data) return false;
    
    return computeIsSubscriber(data);
  } catch (error) {
    // Handle any unexpected errors (network, database connection, etc.)
    console.error("Error checking subscription status:", error);
    return false;
  }
}
</file>

<file path="lib/billing/subscription-status.ts">
/**
 * Shared utilities for computing subscription status.
 * Used by both server-side authorization checks and client-side status API.
 */

export type SubscriptionStatus =
  | "none"
  | "active"
  | "trialing"
  | "past_due"
  | "canceled"
  | "incomplete"
  | "incomplete_expired"
  | "unpaid"
  | "paused";

export interface SubscriptionData {
  status: SubscriptionStatus;
  trial_ends_at: string | null;
}

/**
 * Computes isSubscriber boolean from subscription data.
 * Active subscriptions always count. Trialing subscriptions only count if trial_ends_at is in the future.
 */
export function computeIsSubscriber(data: SubscriptionData | null): boolean {
  if (!data) return false;

  if (data.status === "active") {
    return true;
  }

  if (data.status === "trialing") {
    // Trialing only counts if trial_ends_at is in the future
    return !!data.trial_ends_at && new Date(data.trial_ends_at) > new Date();
  }

  return false;
}
</file>

<file path="lib/config/billing.ts">
export type BillingEnforcement = "off" | "active_required";

/**
 * Get billing enforcement mode from environment variable
 * Defaults to 'off' if not set or invalid value
 */
export function getBillingEnforcement(): BillingEnforcement {
  const value = process.env.BILLING_ENFORCEMENT;
  if (value === "active_required") {
    return "active_required";
  }
  return "off";
}
</file>

<file path="lib/pricing/__mocks__/constants.ts">
// Manual mock for pricing constants in tests
export const SUBSCRIPTION_TIERS = [
  {
    id: "basic",
    name: "Basic",
    monthlyPriceId: "price_basic_monthly",
    annualPriceId: "price_basic_yearly",
  },
  {
    id: "pro",
    name: "Pro",
    monthlyPriceId: "price_monthly",
    annualPriceId: "price_yearly",
  },
  {
    id: "all-access",
    name: "All-Access",
    monthlyPriceId: "price_all_monthly",
    annualPriceId: "price_all_yearly",
  },
];

export const EXAM_PACKAGES = [
  { id: "3-month", priceId: "price_exam_3month" },
  { id: "6-month", priceId: "price_exam_6month" },
  { id: "12-month", priceId: "price_exam_12month" },
];
</file>

<file path="lib/pricing/constants.ts">
// Comprehensive pricing configuration based on revenue model

// Runtime validation for required environment variables
const validatePriceIds = () => {
  const requiredPriceIds = [
    {
      key: "NEXT_PUBLIC_STRIPE_BASIC_MONTHLY",
      value: process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY,
    },
    { key: "NEXT_PUBLIC_STRIPE_BASIC_ANNUAL", value: process.env.NEXT_PUBLIC_STRIPE_BASIC_ANNUAL },
    { key: "NEXT_PUBLIC_STRIPE_PRO_MONTHLY", value: process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY },
    { key: "NEXT_PUBLIC_STRIPE_PRO_ANNUAL", value: process.env.NEXT_PUBLIC_STRIPE_PRO_ANNUAL },
    {
      key: "NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY",
      value: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY,
    },
    {
      key: "NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL",
      value: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL,
    },
    // Exam package price IDs
    { key: "NEXT_PUBLIC_STRIPE_EXAM_3MONTH", value: process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH },
    { key: "NEXT_PUBLIC_STRIPE_EXAM_6MONTH", value: process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH },
    { key: "NEXT_PUBLIC_STRIPE_EXAM_12MONTH", value: process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH },
  ];

  const missingIds = requiredPriceIds.filter(({ value }) => !value);

  if (missingIds.length > 0) {
    // Only log warning, never throw during module initialization
    console.warn(
      `Missing Stripe price IDs:`,
      missingIds.map(({ key }) => key)
    );
  }
};

// Only validate in browser context, not during build or SSR
if (typeof window !== "undefined") {
  validatePriceIds();
}

export interface PricingTier {
  id: string;
  name: string;
  description: string;
  monthlyPrice: number;
  annualPrice: number;
  monthlyPriceId?: string;
  annualPriceId?: string;
  aiCredits: number;
  features: string[];
  highlighted?: string[];
  recommended?: boolean;
  savingsPercentage?: number;
}

export interface ExamPackage {
  id: string;
  duration: string;
  months: number;
  price: number;
  priceId?: string;
  aiCredits: number;
  features: string[];
}

// Annual subscription tiers from revenue model
export const SUBSCRIPTION_TIERS: PricingTier[] = [
  {
    id: "basic",
    name: "Basic",
    description: "Perfect for focused certification prep",
    monthlyPrice: 39,
    annualPrice: 349,
    monthlyPriceId: process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY,
    annualPriceId: process.env.NEXT_PUBLIC_STRIPE_BASIC_ANNUAL,
    aiCredits: 5,
    features: [
      "1 certification track",
      "Core practice questions",
      "Basic analytics dashboard",
      "Progress tracking",
      "Mobile access",
      "Email support",
    ],
    highlighted: ["1 certification track", "5 AI credits/month"],
    savingsPercentage: 25,
  },
  {
    id: "pro",
    name: "Pro",
    description: "Most popular for serious learners",
    monthlyPrice: 59,
    annualPrice: 549,
    monthlyPriceId: process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY,
    annualPriceId: process.env.NEXT_PUBLIC_STRIPE_PRO_ANNUAL,
    aiCredits: 20,
    features: [
      "3 certification tracks",
      "All practice modes",
      "Advanced analytics",
      "Adaptive learning paths",
      "Spaced repetition",
      "Priority support",
      "Early access to new features",
      "Detailed explanations",
      "Performance insights",
    ],
    highlighted: ["3 certification tracks", "20 AI credits/month", "Advanced analytics"],
    recommended: true,
    savingsPercentage: 23,
  },
  {
    id: "all-access",
    name: "All-Access",
    description: "Ultimate learning experience",
    monthlyPrice: 79,
    annualPrice: 749,
    monthlyPriceId: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY,
    annualPriceId: process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL,
    aiCredits: 50,
    features: [
      "All certifications",
      "Unlimited tracks",
      "Team features",
      "API access",
      "Custom study plans",
      "1-on-1 coaching session",
      "Exclusive content",
      "White-glove support",
      "Bulk question generation",
      "Export capabilities",
    ],
    highlighted: ["All certifications", "50 AI credits/month", "Team features"],
    savingsPercentage: 21,
  },
];

// One-time exam packages
export const EXAM_PACKAGES: ExamPackage[] = [
  {
    id: "3-month",
    duration: "3-Month Access",
    months: 3,
    price: 99,
    priceId: process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH,
    aiCredits: 10,
    features: ["Full exam content", "10 AI practice exams", "Progress tracking", "Basic analytics"],
  },
  {
    id: "6-month",
    duration: "6-Month Access",
    months: 6,
    price: 149,
    priceId: process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH,
    aiCredits: 25,
    features: [
      "Full exam content",
      "25 AI practice exams",
      "Progress tracking",
      "Advanced analytics",
      "Priority support",
    ],
  },
  {
    id: "12-month",
    duration: "12-Month Access",
    months: 12,
    price: 199,
    priceId: process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH,
    aiCredits: 50,
    features: [
      "Full exam content",
      "50 AI practice exams",
      "Progress tracking",
      "Advanced analytics",
      "Priority support",
      "Exam retake coverage",
    ],
  },
];

// AI Credit pricing and usage
export const AI_CREDIT_USAGE = {
  fullExam: 1,
  domainQuiz: 0.5,
  explanation: 0.2,
  additionalCreditPrice: 2,
  bulkDiscounts: [
    { credits: 10, price: 18, discount: 10 },
    { credits: 25, price: 40, discount: 20 },
    { credits: 50, price: 75, discount: 25 },
  ],
};

// Value propositions for pricing page
export const VALUE_PROPS = {
  mainHeadline: "Pass Your Certification 15% FasterGuaranteed",
  subHeadline:
    "Join 5,000+ professionals who passed on their first attempt with AI-powered adaptive learning",
  guarantees: [
    "7-day money-back guarantee",
    "Pass guarantee or get 3 months free",
    "Content updated within 14 days of exam changes",
  ],
  trustBadges: [
    "5,000+ Professionals Certified",
    "92% First-Attempt Pass Rate",
    "4.8/5 Average Rating",
    "Updated Weekly",
  ],
  valueAnchors: {
    examCost: "Invest $149 to protect your $300 exam fee",
    salary: "PMLE-certified professionals earn $150k+ on average",
    time: "Save 40% study time with AI-personalized paths",
    success: "Join 5,000+ professionals who passed on first attempt",
  },
};

// Comparison table data
export const FEATURE_COMPARISON = [
  {
    category: "Core Features",
    features: [
      { name: "Practice Questions", basic: "500+", pro: "2,000+", allAccess: "Unlimited" },
      { name: "Certification Tracks", basic: "1", pro: "3", allAccess: "All" },
      { name: "AI Credits/Month", basic: "5", pro: "20", allAccess: "50" },
      { name: "Diagnostic Tests", basic: true, pro: true, allAccess: true },
      { name: "Progress Tracking", basic: true, pro: true, allAccess: true },
    ],
  },
  {
    category: "Advanced Features",
    features: [
      { name: "Adaptive Learning", basic: false, pro: true, allAccess: true },
      { name: "Spaced Repetition", basic: false, pro: true, allAccess: true },
      { name: "Performance Analytics", basic: "Basic", pro: "Advanced", allAccess: "Premium" },
      { name: "Custom Study Plans", basic: false, pro: false, allAccess: true },
      { name: "Team Features", basic: false, pro: false, allAccess: true },
    ],
  },
  {
    category: "Support & Resources",
    features: [
      { name: "Support", basic: "Email", pro: "Priority", allAccess: "White-glove" },
      { name: "Response Time", basic: "48h", pro: "24h", allAccess: "2h" },
      { name: "1-on-1 Coaching", basic: false, pro: false, allAccess: "1 session" },
      { name: "Exclusive Content", basic: false, pro: "Early access", allAccess: true },
      { name: "API Access", basic: false, pro: false, allAccess: true },
    ],
  },
];

// FAQ data for pricing page
export const PRICING_FAQ = [
  {
    question: "Can I switch between plans?",
    answer:
      "Yes! You can upgrade or downgrade your plan at any time. Changes are prorated, so you only pay for what you use.",
  },
  {
    question: "What happens when I run out of AI credits?",
    answer:
      "You can purchase additional credits at $2 per credit, or upgrade to a higher tier for better value. Basic practice questions don't require credits.",
  },
  {
    question: "Do you offer refunds?",
    answer:
      "Absolutely. We offer a 7-day money-back guarantee. If you're not satisfied, contact us within 7 days for a full refund, no questions asked.",
  },
  {
    question: "What's included in the pass guarantee?",
    answer:
      "If you complete 80% of your personalized study plan and don't pass your exam, we'll give you 3 additional months free to prepare for your retake.",
  },
  {
    question: "Can I pause my subscription?",
    answer:
      "Yes, you can pause your subscription for up to 3 months if you need to take a break. Your progress and credits will be saved.",
  },
  {
    question: "Is there a free trial?",
    answer:
      "We offer a free diagnostic test and limited practice questions. This lets you experience our platform before committing to a paid plan.",
  },
  {
    question: "How often is the content updated?",
    answer:
      "We update our content within 14 days of any exam blueprint changes. Our AI continuously generates new questions to keep your practice fresh.",
  },
  {
    question: "Can my company purchase team licenses?",
    answer:
      "Yes! Contact us for enterprise pricing. We offer volume discounts, admin dashboards, and custom integration options for teams of 5+.",
  },
];

// Testimonials for pricing page
export const PRICING_TESTIMONIALS = [
  {
    quote:
      "The Pro plan paid for itself when I passed PMLE on my first try. The adaptive learning saved me at least 40 hours of study time.",
    author: "Sarah Chen",
    role: "ML Engineer at Google",
    certification: "Google PMLE",
    tier: "Pro",
  },
  {
    quote:
      "Started with Basic for my PCA cert, upgraded to All-Access and passed 3 certs in 6 months. Best career investment I've made.",
    author: "Michael Rodriguez",
    role: "Cloud Architect",
    certification: "Multiple GCP Certs",
    tier: "All-Access",
  },
  {
    quote:
      "The 6-month exam package was perfect. Enough time to study at my pace, and the 25 AI credits were exactly what I needed.",
    author: "Jennifer Park",
    role: "DevOps Engineer",
    certification: "Google ACE",
    tier: "6-Month Package",
  },
];
</file>

<file path="lib/pricing/price-utils.ts">
// Pricing analytics helper functions
// Centralizes logic for extracting tier names, payment modes, and plan types from Stripe price IDs

/**
 * Determines if a price ID corresponds to an exam package (one-time payment)
 * vs a subscription tier (recurring payment)
 */
export function isExamPackagePrice(priceId: string): boolean {
  return [
    process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH,
    process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH,
    process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH,
  ].includes(priceId);
}

/**
 * Returns the payment mode for a given price ID
 * - "payment" for one-time exam packages
 * - "subscription" for recurring subscription tiers
 */
export function getPaymentMode(priceId: string): "subscription" | "payment" {
  return isExamPackagePrice(priceId) ? "payment" : "subscription";
}

/**
 * Returns the plan type for a given price ID
 * - "exam_package" for one-time exam packages
 * - "subscription" for recurring subscription tiers
 */
export function getPlanType(priceId: string): "subscription" | "exam_package" {
  return isExamPackagePrice(priceId) ? "exam_package" : "subscription";
}

/**
 * Extracts the tier name from a Stripe price ID
 * Maps price IDs to human-readable tier names for analytics tracking
 *
 * @param priceId - The Stripe price ID to look up
 * @returns Tier name string (Basic, Pro, All-Access, or exam package name, or "Unknown")
 */
export function getTierNameFromPriceId(priceId: string): string {
  // Basic tier
  if (
    priceId === process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY ||
    priceId === process.env.NEXT_PUBLIC_STRIPE_BASIC_ANNUAL
  ) {
    return "Basic";
  }

  // Pro tier
  if (
    priceId === process.env.NEXT_PUBLIC_STRIPE_PRO_MONTHLY ||
    priceId === process.env.NEXT_PUBLIC_STRIPE_PRO_ANNUAL
  ) {
    return "Pro";
  }

  // All-Access tier
  if (
    priceId === process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_MONTHLY ||
    priceId === process.env.NEXT_PUBLIC_STRIPE_ALL_ACCESS_ANNUAL
  ) {
    return "All-Access";
  }

  // Exam packages
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_EXAM_3MONTH) {
    return "3-Month Package";
  }
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_EXAM_6MONTH) {
    return "6-Month Package";
  }
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_EXAM_12MONTH) {
    return "12-Month Package";
  }

  return "Unknown";
}
</file>

<file path="lib/stripe/stripe-service.ts">
import Stripe from "stripe";

export class StripeService {
  private stripe: Stripe;

  constructor() {
    if (!process.env.STRIPE_SECRET_KEY) {
      console.error("STRIPE_SECRET_KEY is not defined in environment variables");
      throw new Error(
        "STRIPE_SECRET_KEY is not defined. Please configure Stripe in your environment variables."
      );
    }

    this.stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
      // Use the default API version from the Stripe dashboard
      // or specify a valid version via environment variable
      apiVersion: process.env.STRIPE_API_VERSION as Stripe.LatestApiVersion | undefined,
      typescript: true,
    });
  }

  async createOrRetrieveCustomer(userId: string, email: string): Promise<Stripe.Customer> {
    try {
      // Search for existing customer with this Supabase user ID
      // Escape special characters in userId to prevent query issues
      const escapedUserId = userId.replace(/["\\]/g, "\\$&");
      const existingCustomers = await this.stripe.customers.search({
        query: `metadata["supabase_user_id"]:"${escapedUserId}"`,
      });

      if (existingCustomers.data.length > 0) {
        return existingCustomers.data[0];
      }

      // Create new customer
      const customer = await this.stripe.customers.create({
        email,
        metadata: {
          supabase_user_id: userId,
        },
      });

      return customer;
    } catch (error) {
      console.error("Error creating/retrieving customer:", error);
      throw new Error(
        `Failed to create or retrieve customer: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  /**
   * Retrieve a price from Stripe and determine if it's a subscription or one-time payment
   */
  async getPriceType(priceId: string): Promise<"subscription" | "payment"> {
    try {
      const price = await this.stripe.prices.retrieve(priceId);
      return price.type === "recurring" ? "subscription" : "payment";
    } catch (error) {
      console.error("Error retrieving price:", error);
      throw new Error(
        `Failed to retrieve price: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async createCheckoutSession({
    customerId,
    priceId,
    successUrl,
    cancelUrl,
    userId,
    mode,
  }: {
    customerId: string;
    priceId: string;
    successUrl: string;
    cancelUrl: string;
    userId: string;
    mode?: "subscription" | "payment";
  }): Promise<Stripe.Checkout.Session> {
    try {
      // Determine mode if not provided
      const checkoutMode = mode || (await this.getPriceType(priceId));

      const sessionParams: Stripe.Checkout.SessionCreateParams = {
        customer: customerId,
        payment_method_types: ["card"],
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        mode: checkoutMode,
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: {
          user_id: userId,
        },
        allow_promotion_codes: true,
      };

      // Only include subscription_data for subscription mode
      if (checkoutMode === "subscription") {
        sessionParams.subscription_data = {
          metadata: {
            user_id: userId,
          },
        };
      }

      const session = await this.stripe.checkout.sessions.create(sessionParams);

      return session;
    } catch (error) {
      console.error("Error creating checkout session:", error);
      throw new Error(
        `Failed to create checkout session: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async createPortalSession(
    customerId: string,
    returnUrl: string
  ): Promise<Stripe.BillingPortal.Session> {
    try {
      const session = await this.stripe.billingPortal.sessions.create({
        customer: customerId,
        return_url: returnUrl,
      });

      return session;
    } catch (error) {
      console.error("Error creating portal session:", error);
      throw new Error(
        `Failed to create portal session: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  constructWebhookEvent(payload: string | Buffer, signature: string, secret: string): Stripe.Event {
    try {
      return this.stripe.webhooks.constructEvent(payload, signature, secret);
    } catch (error) {
      console.error("Webhook signature verification failed:", error);
      throw new Error("Invalid webhook signature");
    }
  }

  async retrieveSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
    try {
      const subscription = await this.stripe.subscriptions.retrieve(subscriptionId, {
        expand: ["items.data.price"],
      });

      return subscription;
    } catch (error) {
      console.error("Error retrieving subscription:", error);
      throw new Error(
        `Failed to retrieve subscription: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async cancelSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
    try {
      const subscription = await this.stripe.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true,
      });

      return subscription;
    } catch (error) {
      console.error("Error cancelling subscription:", error);
      throw new Error(
        `Failed to cancel subscription: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async retrieveCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session> {
    try {
      const session = await this.stripe.checkout.sessions.retrieve(sessionId, {
        expand: ["subscription", "customer"],
      });

      return session;
    } catch (error) {
      console.error("Error retrieving checkout session:", error);
      throw new Error(
        `Failed to retrieve checkout session: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async retrievePaymentIntent(
    paymentIntentId: string,
    expand?: string[]
  ): Promise<Stripe.PaymentIntent> {
    try {
      const paymentIntent = await this.stripe.paymentIntents.retrieve(paymentIntentId, {
        expand: expand || [],
      });

      return paymentIntent;
    } catch (error) {
      console.error("Error retrieving payment intent:", error);
      throw new Error(
        `Failed to retrieve payment intent: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async listCustomerSubscriptions(
    customerId: string
  ): Promise<Stripe.ApiList<Stripe.Subscription>> {
    try {
      const subscriptions = await this.stripe.subscriptions.list({
        customer: customerId,
        status: "all",
        expand: ["data.items.data.price"],
      });

      return subscriptions;
    } catch (error) {
      console.error("Error listing customer subscriptions:", error);
      throw new Error("Failed to list customer subscriptions");
    }
  }

  async createTrialSubscription({
    customerId,
    priceId,
    trialDays = 14,
    userId,
  }: {
    customerId: string;
    priceId: string;
    trialDays?: number;
    userId: string;
    promotionCode?: string; // Reserved for future use with checkout sessions
  }): Promise<Stripe.Subscription> {
    try {
      const subscriptionData: Stripe.SubscriptionCreateParams = {
        customer: customerId,
        items: [{ price: priceId }],
        trial_period_days: trialDays,
        metadata: {
          user_id: userId,
        },
        payment_settings: {
          save_default_payment_method: "on_subscription",
        },
        trial_settings: {
          end_behavior: {
            missing_payment_method: "cancel",
          },
        },
      };

      // Note: Promotion codes can be applied via checkout session or customer portal
      // but not directly on subscription creation. For trials, we'll skip this for now.

      const subscription = await this.stripe.subscriptions.create(subscriptionData);

      return subscription;
    } catch (error) {
      console.error("Error creating trial subscription:", error);
      throw new Error(
        `Failed to create trial subscription: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }

  async convertTrialToPaid(
    subscriptionId: string,
    paymentMethodId: string
  ): Promise<Stripe.Subscription> {
    try {
      const subscription = await this.stripe.subscriptions.update(subscriptionId, {
        default_payment_method: paymentMethodId,
        trial_end: "now",
      });

      return subscription;
    } catch (error) {
      console.error("Error converting trial to paid:", error);
      throw new Error(
        `Failed to convert trial to paid: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

// Utility function to merge Tailwind CSS classes
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="app/dashboard/billing/page.tsx">
"use client";

import React, { useEffect, useState, Suspense } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useAuth } from "@/components/providers/AuthProvider";
import { createClient } from "@/lib/supabase/client";
import { CheckCircleIcon, XCircleIcon, ClockIcon } from "@heroicons/react/24/outline";
import { usePostHog } from "posthog-js/react";

interface Subscription {
  id: string;
  status: string;
  plan_id: string;
  stripe_customer_id: string;
  stripe_subscription_id: string;
  current_period_start: string;
  current_period_end: string;
  cancel_at_period_end: boolean;
  created_at: string;
  updated_at: string;
  plan?: {
    name: string;
    price_monthly: number;
    price_yearly: number;
  };
}

interface PaymentHistory {
  id: string;
  amount: number;
  status: string;
  created_at: string;
  stripe_payment_intent_id: string;
}

function BillingDashboardContent() {
  const [subscription, setSubscription] = useState<Subscription | null>(null);
  const [paymentHistory, setPaymentHistory] = useState<PaymentHistory[]>([]);
  const [loading, setLoading] = useState(true);
  const [portalLoading, setPortalLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showSuccessBanner, setShowSuccessBanner] = useState(false);
  const { user } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();
  const posthog = usePostHog();
  const supabase = createClient();

  useEffect(() => {
    const fetchSubscriptionData = async () => {
      try {
        // Fetch subscription with plan details
        const { data: subData, error: subError } = await supabase
          .from("user_subscriptions")
          .select(
            `
            *,
            plan:subscription_plans(*)
          `
          )
          .eq("user_id", user?.id)
          .single();

        if (subError && subError.code !== "PGRST116") {
          console.error("Error fetching subscription:", subError);
        } else if (subData) {
          setSubscription(subData);
        }

        // Fetch payment history
        const { data: paymentData, error: paymentError } = await supabase
          .from("payment_history")
          .select("*")
          .eq("user_id", user?.id)
          .order("created_at", { ascending: false })
          .limit(10);

        if (paymentError) {
          console.error("Error fetching payment history:", paymentError);
        } else if (paymentData) {
          setPaymentHistory(paymentData);
        }
      } catch (error) {
        console.error("Error fetching billing data:", error);
      } finally {
        setLoading(false);
      }
    };

    if (user) {
      fetchSubscriptionData();

      // Track successful checkout
      if (searchParams.get("success") === "true" || searchParams.get("success") === "1") {
        posthog?.capture("checkout_completed", {
          user_id: user.id,
        });
      }
    } else if (!user && !loading) {
      router.push("/login?redirect=/dashboard/billing");
    }
  }, [user, loading, router, posthog, searchParams, supabase]);

  useEffect(() => {
    const successParam = searchParams.get("success");
    if (successParam === "1" || successParam === "true") {
      setShowSuccessBanner(true);
    }
  }, [searchParams]);

  const handleManageSubscription = async () => {
    try {
      setPortalLoading(true);

      posthog?.capture("billing_portal_requested", {
        user_id: user?.id,
        subscription_status: subscription?.status,
      });

      const response = await fetch("/api/billing/portal", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      const data = (await response.json()) as { error?: string; url?: string };

      if (!response.ok) {
        throw new Error(data.error || "Failed to create portal session");
      }

      if (data.url) {
        window.location.href = data.url;
      }
    } catch (error) {
      console.error("Portal session error:", error);
      setError("Failed to open billing portal. Please try again.");
      setTimeout(() => setError(null), 5000);
    } finally {
      setPortalLoading(false);
    }
  };

  const getStatusBadge = (status: string) => {
    const statusConfig = {
      active: {
        icon: CheckCircleIcon,
        text: "Active",
        className: "bg-green-100 text-green-800",
      },
      trialing: {
        icon: ClockIcon,
        text: "Trial",
        className: "bg-blue-100 text-blue-800",
      },
      past_due: {
        icon: XCircleIcon,
        text: "Past Due",
        className: "bg-red-100 text-red-800",
      },
      canceled: {
        icon: XCircleIcon,
        text: "Canceled",
        className: "bg-gray-100 text-gray-800",
      },
      incomplete: {
        icon: ClockIcon,
        text: "Incomplete",
        className: "bg-yellow-100 text-yellow-800",
      },
    };

    const config = statusConfig[status as keyof typeof statusConfig] || statusConfig.canceled;
    const Icon = config.icon;

    return (
      <span
        className={`inline-flex items-center px-3 py-1 rounded-full text-sm font-medium ${config.className}`}
      >
        <Icon className="h-4 w-4 mr-1" />
        {config.text}
      </span>
    );
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  const formatAmount = (amount: number) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
    }).format(amount / 100);
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">Billing & Subscription</h1>

        {/* Error Alert */}
        {error && (
          <div className="mb-6 rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="ml-3">
                <p className="text-sm font-medium text-red-800">{error}</p>
              </div>
            </div>
          </div>
        )}

        {/* Success Alert */}
        {showSuccessBanner && (
          <div className="mb-6 rounded-md bg-green-50 p-4 flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-start gap-3">
              <CheckCircleIcon className="h-5 w-5 text-green-500" />
              <div>
                <p className="text-sm font-medium text-green-800">
                  Payment successful! Your subscription is now active.
                </p>
                <p className="text-sm text-green-700">
                  You&apos;re all setjump back into your PMLE study plan.
                </p>
              </div>
            </div>
            <button
              onClick={() => router.push("/dashboard")}
              className="inline-flex w-full sm:w-auto justify-center rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
              Back to your PMLE study plan
            </button>
          </div>
        )}

        {/* Subscription Status */}
        <div className="bg-white shadow rounded-lg p-6 mb-8">
          <h2 className="text-xl font-semibold text-gray-900 mb-4">Current Subscription</h2>

          {subscription ? (
            <div className="space-y-4">
              <div className="flex justify-between items-start">
                <div>
                  <p className="text-lg font-medium text-gray-900">
                    {subscription.plan?.name || "Subscription"}
                  </p>
                  <p className="text-sm text-gray-600 mt-1">
                    {subscription.plan && (
                      <>
                        {subscription.current_period_end &&
                        new Date(subscription.current_period_end).getTime() -
                          new Date(subscription.current_period_start).getTime() >
                          31 * 24 * 60 * 60 * 1000
                          ? formatAmount(subscription.plan.price_yearly) + "/year"
                          : formatAmount(subscription.plan.price_monthly) + "/month"}
                      </>
                    )}
                  </p>
                </div>
                {getStatusBadge(subscription.status)}
              </div>

              <div className="border-t pt-4 space-y-2">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">Current period</span>
                  <span className="text-gray-900">
                    {formatDate(subscription.current_period_start)} -{" "}
                    {formatDate(subscription.current_period_end)}
                  </span>
                </div>

                {subscription.cancel_at_period_end && (
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600">Cancels on</span>
                    <span className="text-red-600 font-medium">
                      {formatDate(subscription.current_period_end)}
                    </span>
                  </div>
                )}
              </div>

              <div className="pt-4">
                <button
                  onClick={handleManageSubscription}
                  disabled={portalLoading}
                  className="w-full sm:w-auto px-6 py-3 border border-gray-300 rounded-md shadow-sm text-base font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {portalLoading ? (
                    <span className="flex items-center">
                      <svg
                        className="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-700"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        />
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        />
                      </svg>
                      Loading...
                    </span>
                  ) : (
                    "Manage Subscription"
                  )}
                </button>
              </div>
            </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-600 mb-4">You don&apos;t have an active subscription.</p>
              <button
                onClick={() => router.push("/pricing")}
                className="px-6 py-3 bg-blue-600 text-white font-medium rounded-md hover:bg-blue-700 transition-colors"
              >
                View Plans
              </button>
            </div>
          )}
        </div>

        {/* Payment History */}
        {paymentHistory.length > 0 && (
          <div className="bg-white shadow rounded-lg p-6">
            <h2 className="text-xl font-semibold text-gray-900 mb-4">Payment History</h2>

            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead>
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Amount
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {paymentHistory.map((payment) => (
                    <tr key={payment.id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {formatDate(payment.created_at)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {formatAmount(payment.amount)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                            payment.status === "succeeded"
                              ? "bg-green-100 text-green-800"
                              : payment.status === "failed"
                                ? "bg-red-100 text-red-800"
                                : "bg-gray-100 text-gray-800"
                          }`}
                        >
                          {payment.status}
                        </span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default function BillingDashboard() {
  return (
    <Suspense
      fallback={
        <div className="min-h-screen flex items-center justify-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
        </div>
      }
    >
      <BillingDashboardContent />
    </Suspense>
  );
}
</file>

<file path="app/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useInView } from "react-intersection-observer";
import { usePostHog } from "posthog-js/react";
import { trackEvent, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";
import dynamic from "next/dynamic";
import Link from "next/link";
import { BenefitsSectionSkeleton } from "@/components/marketing/sections/benefits-section";
import { HeroSection } from "@/components/marketing/sections/hero-section";
import { TestimonialCarousel } from "@/components/marketing/sections/testimonial-carousel";
import { Button } from "@/components/ui/button";
import { JsonLd } from "./page.metadata";
import {
  CheckCircle,
  TrendingUp,
  Clock,
  Shield,
  Star,
  Zap,
  ArrowRight,
  Award,
} from "lucide-react";
import { SUBSCRIPTION_TIERS } from "@/lib/pricing/constants";
import { cn } from "@/lib/utils";

// Dynamically import the BenefitsSection component
const BenefitsSection = dynamic(
  () =>
    import("@/components/marketing/sections/benefits-section").then((mod) => mod.BenefitsSection),
  {
    loading: () => <BenefitsSectionSkeleton />,
    ssr: false,
  }
);

// Helper hook for tracking section views and lazy loading
function useTrackSectionView(sectionName: string, loadThreshold = 0.1) {
  const posthog = usePostHog();
  const [shouldLoad, setShouldLoad] = useState(false);
  const { ref, inView } = useInView({
    triggerOnce: true,
    threshold: loadThreshold,
    rootMargin: "200px 0px",
  });

  useEffect(() => {
    if (inView) {
      if (posthog) {
        trackEvent(posthog, ANALYTICS_EVENTS.FEATURE_DISCOVERED, {
          feature_name: sectionName,
          discovery_type: "scroll_view",
        });
      }
      setShouldLoad(true);
    }
  }, [inView, sectionName, posthog]);

  return { ref, shouldLoad, inView };
}

export default function Home() {
  const { ref: benefitsRef, shouldLoad: loadBenefits } = useTrackSectionView("benefits");
  const { ref: pricingPreviewRef, shouldLoad: loadPricingPreview } =
    useTrackSectionView("pricing_preview");
  const { ref: finalCtaRef } = useTrackSectionView("final_cta");
  const posthog = usePostHog();

  const handlePricingClick = (source: string) => {
    trackEvent(posthog, ANALYTICS_EVENTS.PRICING_PAGE_VIEWED, {
      source: `homepage_${source}`,
      referrer: "homepage",
    });
  };

  return (
    <main className="flex min-h-screen flex-col items-stretch justify-start bg-gradient-to-b from-slate-50 to-white">
      {/* Add JSON-LD structured data */}
      <JsonLd />

      {/* Hero Section */}
      <HeroSection />

      {/* Main content sections */}
      <div role="main" id="main-content" className="w-full overflow-x-hidden">
        {/* Value Anchors Section */}
        {/* eslint-disable-next-line no-restricted-syntax */}
        <section className="w-full py-16 px-4 sm:px-6 bg-white">
          <div className="max-w-6xl mx-auto">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
              <div className="text-center">
                <div className="bg-green-100 rounded-full p-4 w-16 h-16 mx-auto mb-4 flex items-center justify-center">
                  <TrendingUp className="h-8 w-8 text-green-600" />
                </div>
                <h3 className="text-xl font-bold text-gray-900 mb-2">Protect Your $200 Exam Fee</h3>
                <p className="text-gray-600">
                  70% of PMLE test-takers fail and lose $200. Our diagnostic shows your exact 
                  readiness level before you book.
                </p>
              </div>
              <div className="text-center">
                <div className="bg-blue-100 rounded-full p-4 w-16 h-16 mx-auto mb-4 flex items-center justify-center">
                  <Clock className="h-8 w-8 text-blue-600" />
                </div>
                <h3 className="text-xl font-bold text-gray-900 mb-2">October 2024 Exam Updated</h3>
                <p className="text-gray-600">
                  Google changed 30% of PMLE topics in October. Our questions are updated within 
                  14 days of any exam changes.
                </p>
              </div>
              <div className="text-center">
                <div className="bg-purple-100 rounded-full p-4 w-16 h-16 mx-auto mb-4 flex items-center justify-center">
                  <Shield className="h-8 w-8 text-purple-600" />
                </div>
                <h3 className="text-xl font-bold text-gray-900 mb-2">30-Day Pass Guarantee</h3>
                <p className="text-gray-600">
                  Follow our 30-day PMLE study plan and pass on your first attemptor get your 
                  money back. No questions asked.
                </p>
              </div>
            </div>
          </div>
        </section>

        {/* Pricing Preview Section */}
        <section
          ref={pricingPreviewRef}
          // eslint-disable-next-line no-restricted-syntax
          className="w-full py-16 sm:py-20 px-4 sm:px-6 bg-gradient-to-b from-blue-50 to-white"
        >
          {loadPricingPreview && (
            <div className="max-w-7xl mx-auto">
              <div className="text-center mb-12">
                <h2 className="text-3xl sm:text-4xl font-bold text-gray-900 mb-4">
                  Choose Your PMLE Success Plan
                </h2>
                <p className="text-xl text-gray-600 max-w-3xl mx-auto">
                  All plans include 500+ PMLE-specific questions, AI explanations, and our 
                  30-day pass guarantee.
                </p>
              </div>

              {/* Pricing Cards Preview */}
              <div className="grid grid-cols-1 gap-6 md:grid-cols-3 md:gap-8 mb-12">
                {SUBSCRIPTION_TIERS.map((tier) => (
                  <div
                    key={tier.id}
                    className={cn(
                      "relative rounded-2xl p-5 sm:p-6 bg-white border-2 transition-all",
                      tier.recommended
                        ? "border-blue-500 shadow-xl md:scale-105"
                        : "border-gray-200 hover:border-gray-300 hover:shadow-lg"
                    )}
                  >
                    {tier.recommended && (
                      <div className="absolute -top-3 left-1/2 -translate-x-1/2">
                        <span className="bg-gradient-to-r from-blue-600 to-cyan-600 text-white text-xs font-bold px-3 py-1 rounded-full">
                          MOST POPULAR
                        </span>
                      </div>
                    )}

                    <div className="text-center mb-6 space-y-2">
                      <h3 className="text-2xl font-bold text-gray-900">{tier.name}</h3>
                      <div className="flex items-baseline justify-center">
                        <span className="text-3xl sm:text-4xl font-bold">${tier.monthlyPrice}</span>
                        <span className="text-sm text-gray-500 ml-2">/month</span>
                      </div>
                      <p className="text-sm sm:text-base text-green-600 font-medium">
                        Save {tier.savingsPercentage}% with annual billing
                      </p>
                    </div>

                    <ul className="space-y-3 mb-6 text-left">
                      {tier.highlighted?.slice(0, 3).map((feature) => (
                        <li key={feature} className="flex items-start gap-2">
                          <CheckCircle className="h-5 w-5 text-green-500 flex-shrink-0" />
                          <span className="text-sm sm:text-base text-gray-700">{feature}</span>
                        </li>
                      ))}
                    </ul>

                    <Button
                      asChild
                      size="md"
                      fullWidth
                      tone={tier.recommended ? "accent" : "neutral"}
                      variant={tier.recommended ? "solid" : "outline"}
                      className="text-base font-semibold h-12"
                      onClick={() => handlePricingClick(`preview_${tier.id}`)}
                    >
                      <Link href="/pricing">Get Started</Link>
                    </Button>
                  </div>
                ))}
              </div>

              <div className="text-center">
                <Link
                  href="/pricing"
                  className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-semibold text-lg"
                  onClick={() => handlePricingClick("preview_compare")}
                >
                  Compare all features
                  <ArrowRight className="h-5 w-5" />
                </Link>
              </div>
            </div>
          )}
        </section>

        {/* Benefits Section - Lazy loaded */}
        <section ref={benefitsRef} aria-labelledby="benefits-heading">
          {loadBenefits ? <BenefitsSection /> : <BenefitsSectionSkeleton />}
        </section>

        {/* Enhanced Testimonials Section with Pricing Context */}
        {/* eslint-disable-next-line no-restricted-syntax */}
        <section className="w-full py-10 sm:py-16 md:py-24 px-4 sm:px-6 bg-slate-50">
          <div className="max-w-5xl mx-auto">
            <div className="text-center mb-12">
              <h2 className="text-2xl sm:text-3xl md:text-4xl font-bold text-slate-800 mb-4">
                Real Success Stories from Our Students
              </h2>
              <p className="text-lg text-gray-600">
                See how professionals like you achieved their certification goals
              </p>
            </div>

            <TestimonialCarousel
              testimonials={[
                {
                  id: "1",
                  quote:
                    "Failed PMLE twice before finding Testero. The diagnostic showed I was only 58% ready. After 30 days of focused practice, I passed with 89%. Worth every penny.",
                  author: "Alex Chen",
                  role: "ML Engineer at Google",
                },
                {
                  id: "2",
                  quote:
                    "The October 2024 exam changes caught me off guard. Testero had updated questions within days. Their AI explanations for ML concepts are better than any course I've taken.",
                  author: "Sarah Martinez",
                  role: "Senior Data Scientist",
                },
                {
                  id: "3",
                  quote:
                    "PMLE is brutal70% fail rate for a reason. Testero's diagnostic saved me from wasting $200. Studied for 30 days, passed first try. The money-back guarantee gave me confidence.",
                  author: "Michael Johnson",
                  role: "Cloud ML Engineer",
                },
              ]}
            />

            {/* Success Metrics */}
            <div className="mt-12 grid grid-cols-2 md:grid-cols-4 gap-6 text-center">
              <div>
                <div className="text-3xl font-bold text-blue-600">70%</div>
                <div className="text-sm text-gray-600">PMLE Fail Rate</div>
              </div>
              <div>
                <div className="text-3xl font-bold text-green-600">$200</div>
                <div className="text-sm text-gray-600">Exam Cost at Risk</div>
              </div>
              <div>
                <div className="text-3xl font-bold text-purple-600">30</div>
                <div className="text-sm text-gray-600">Days to Pass</div>
              </div>
              <div>
                <div className="text-3xl font-bold text-orange-600">Oct 2024</div>
                <div className="text-sm text-gray-600">Content Updated</div>
              </div>
            </div>
          </div>
        </section>

        {/* AI Credits Explainer */}
        {/* eslint-disable-next-line no-restricted-syntax */}
        <section className="w-full py-16 px-4 sm:px-6 bg-white">
          <div className="max-w-4xl mx-auto text-center">
            <h2 className="text-2xl sm:text-3xl font-bold text-gray-900 mb-8">
              PMLE-Specific AI Training System
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="p-6">
                <Zap className="h-10 w-10 text-blue-600 mx-auto mb-4" />
                <h3 className="font-semibold text-lg mb-2">ML Concept Mastery</h3>
                <p className="text-gray-600">
                  Deep coverage of TensorFlow, Vertex AI, BigQuery ML, and MLOps practices
                </p>
              </div>
              <div className="p-6">
                <Award className="h-10 w-10 text-green-600 mx-auto mb-4" />
                <h3 className="font-semibold text-lg mb-2">October 2024 Updates</h3>
                <p className="text-gray-600">
                  500+ questions covering new Gemini, GenAI, and Vertex AI features
                </p>
              </div>
              <div className="p-6">
                <TrendingUp className="h-10 w-10 text-purple-600 mx-auto mb-4" />
                <h3 className="font-semibold text-lg mb-2">Readiness Score</h3>
                <p className="text-gray-600">
                  Know your exact PMLE readiness percentage before booking your $200 exam
                </p>
              </div>
            </div>
          </div>
        </section>

        {/* Enhanced Final CTA Section */}
        <section
          ref={finalCtaRef}
          // eslint-disable-next-line no-restricted-syntax
          className="w-full py-20 bg-gradient-to-r from-blue-600 to-cyan-600"
        >
          <div className="max-w-4xl mx-auto px-4 sm:px-6 text-center text-white">
            <h2 className="text-3xl sm:text-4xl font-bold mb-6">
              Pass PMLE in 30 DaysGuaranteed
            </h2>
            <p className="text-xl mb-8 text-blue-100">
              Don&apos;t waste $200 on a failed attempt. Start with our free diagnostic to know exactly where you stand.
            </p>

            {/* Urgency Elements */}
            <div className="bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-8 max-w-2xl mx-auto">
              <div className="flex items-center justify-center gap-4 mb-4">
                <Clock className="h-6 w-6 text-yellow-300" />
                <span className="text-lg font-semibold">Limited Time Offer</span>
              </div>
              <p className="text-blue-100 mb-4">
                New in 2025  30-day money-back guarantee  Cancel anytime
              </p>
              <div className="grid grid-cols-3 gap-4 text-center">
                <div>
                  <div className="text-2xl font-bold">$39</div>
                  <div className="text-sm text-blue-200">Basic/month</div>
                </div>
                <div className="border-2 border-yellow-400 rounded-lg p-2">
                  <div className="text-2xl font-bold text-yellow-300">$59</div>
                  <div className="text-sm text-blue-200">Pro/month</div>
                  <div className="text-xs text-yellow-300">POPULAR</div>
                </div>
                <div>
                  <div className="text-2xl font-bold">$79</div>
                  <div className="text-sm text-blue-200">All-Access</div>
                </div>
              </div>
            </div>

            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <Button
                asChild
                size="lg"
                tone="accent"
                className="text-lg"
                iconRight={<ArrowRight className="h-5 w-5" />}
                onClick={() => handlePricingClick("final_cta_primary")}
              >
                <Link href="/pricing">See Pricing & Start Today</Link>
              </Button>
              <Button asChild variant="outline" tone="neutral" size="lg" className="text-lg">
                <Link href="/diagnostic">Take Free Diagnostic First</Link>
              </Button>
            </div>

            {/* Trust Signals */}
            <div className="mt-8 flex flex-wrap justify-center gap-6 text-sm">
              <div className="flex items-center gap-2">
                <Shield className="h-5 w-5 text-green-400" />
                <span>7-day money-back guarantee</span>
              </div>
              <div className="flex items-center gap-2">
                <CheckCircle className="h-5 w-5 text-green-400" />
                <span>Cancel anytime</span>
              </div>
              <div className="flex items-center gap-2">
                <Star className="h-5 w-5 text-yellow-400" />
                <span>PMLE-focused</span>
              </div>
            </div>
          </div>
        </section>
      </div>

      {/* Related Content Links - Now with Pricing Focus */}
      {/* eslint-disable-next-line no-restricted-syntax */}
      <section className="w-full py-12 md:py-20 px-6 bg-slate-50">
        <div className="max-w-5xl mx-auto text-center">
          <h2 className="text-2xl sm:text-3xl font-bold text-slate-800 mb-8">
            PMLE Resources & Study Guides
          </h2>
          <div className="flex flex-wrap justify-center gap-6">
            <Link
              href="/pricing"
              className="text-blue-600 hover:underline text-lg font-semibold"
              onClick={() => handlePricingClick("footer_link")}
            >
              View All Pricing Options 
            </Link>
            <Link
              href="/content/hub/pmle-exam-study-guide"
              className="text-blue-600 hover:underline text-lg"
            >
              Complete PMLE Study Guide 2025
            </Link>
            <Link
              href="/content/hub/google-professional-machine-learning-engineer-certification-roadmap-2025"
              className="text-blue-600 hover:underline text-lg"
            >
              PMLE Certification Roadmap
            </Link>
            <Link href="/faq" className="text-blue-600 hover:underline text-lg">
              Frequently Asked Questions
            </Link>
          </div>
        </div>
      </section>
    </main>
  );
}
</file>

<file path="components/billing/UpgradePrompt.tsx">
"use client";

import React, { useEffect, useRef, useState } from "react";
import { usePathname } from "next/navigation";
import { usePostHog } from "posthog-js/react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { ANALYTICS_EVENTS } from "@/lib/analytics/analytics";
import { useStartBasicCheckout } from "@/hooks/useStartBasicCheckout";

export interface UpgradePromptProps {
  featureName?: string;
}

export function UpgradePrompt({ featureName }: UpgradePromptProps) {
  const pathname = usePathname();
  const posthog = usePostHog();
  const [open, setOpen] = useState(true);
  const hasTrackedView = useRef(false);
  const { startBasicCheckout } = useStartBasicCheckout();

  // Track gate_viewed on mount (only once)
  useEffect(() => {
    if (!hasTrackedView.current && posthog) {
      posthog.capture(ANALYTICS_EVENTS.GATE_VIEWED, {
        route: pathname,
        distinct_id: posthog.get_distinct_id?.() || undefined,
        feature: featureName ?? "unknown",
      });
      hasTrackedView.current = true;
    }
  }, [posthog, pathname, featureName]);

  const handlePricingClick = () => {
    if (posthog) {
      posthog.capture(ANALYTICS_EVENTS.GATE_CTA_CLICKED, {
        route: pathname,
        plan_context: "unknown",
        feature: featureName ?? "unknown",
        source: "upgrade_prompt",
      });
    }

    startBasicCheckout(`upgrade_prompt_${featureName ?? "generic"}`);
  };

  const handleDismiss = () => {
    if (posthog) {
      posthog.capture(ANALYTICS_EVENTS.GATE_DISMISSED, {
        route: pathname,
        feature: featureName ?? "unknown",
      });
    }
    setOpen(false);
  };

  return (
    <Dialog open={open} onOpenChange={handleDismiss}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="text-2xl font-bold">
            Unlock premium features
          </DialogTitle>
          <DialogDescription className="text-base mt-2">
            A paid plan is required to use this feature. Choose a plan to
            continue.
          </DialogDescription>
        </DialogHeader>

        <div className="flex flex-col gap-2 mt-4">
          <Button
            onClick={handlePricingClick}
            size="lg"
            tone="accent"
            fullWidth
          >
            Choose a plan
          </Button>
          <Button
            onClick={handleDismiss}
            variant="ghost"
            tone="neutral"
            size="sm"
            fullWidth
          >
            Dismiss
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/ui/index.ts">
export * from "./button"
export * from "./badge"
export * from "./card"
export * from "./page-header"
export * from "./empty-state"
export * from "./table"
export * from "./toast"
export * from "./dropdown-menu"
</file>

<file path="components/ui/radio-group.tsx">
"use client";

import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
</file>

<file path="components/ui/select.tsx">
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-11 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2.5 text-base shadow-xs transition-colors outline-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm md:leading-5",
      "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
      "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="hooks/useUpsell.ts">
import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/components/providers/AuthProvider';
import { usePostHog } from 'posthog-js/react';

export type UpsellTrigger = 'paywall' | 'engagement' | 'exit-intent' | 'performance' | 'quota_exceeded';
export type UpsellVariant = 'foundation' | 'almost' | 'polish' | 'quota_exceeded';

interface UpsellState {
  isOpen: boolean;
  trigger: UpsellTrigger | null;
  variant: UpsellVariant;
  dwellStartTime: number;
  hasShownThisSession: boolean;
}

interface UpsellOptions {
  score: number;
  enableExitIntent?: boolean;
  enableDeepScroll?: boolean;
  weakDomains?: string[];
}

export const useUpsell = (options: UpsellOptions) => {
  const { user } = useAuth();
  const posthog = usePostHog();
  
  const [state, setState] = useState<UpsellState>({
    isOpen: false,
    trigger: null,
    variant: getVariantFromScore(options.score),
    dwellStartTime: Date.now(),
    hasShownThisSession: false,
  });

  // A/B test holdout (1020% no modal)
  const rawFlag = posthog?.getFeatureFlag('upsell_modal_test');
  const abBucket = typeof rawFlag === 'string' ? rawFlag : rawFlag ? 'treatment' : 'control';
  const isInHoldout = abBucket === 'holdout';
  // Check if user is in snooze period
  const isInSnooze = useCallback(() => {
    const storageKey = user?.id ? `upsell_snooze_${user.id}` : 'upsell_snooze_anon';
    const snoozeUntil = localStorage.getItem(storageKey);
    
    if (!snoozeUntil) return false;
    
    const snoozeTime = parseInt(snoozeUntil, 10);
    const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
    return Date.now() < (snoozeTime + sevenDaysMs);
  }, [user?.id]);

  // Get dwell time in milliseconds
  const getDwellTime = useCallback(() => {
    return Date.now() - state.dwellStartTime;
  }, [state.dwellStartTime]);

  // Check if we can show modal (guardrails)
  const canShowModal = useCallback(() => {
    // Never show within first 20 seconds
    if (getDwellTime() < 20000) return false;
    
    // Never show more than once per session
    if (state.hasShownThisSession) return false;
    
    // Respect 7-day snooze
    if (isInSnooze()) return false;
    
    // Don't show for high scores (unless feature flagged)
    if (options.score >= 80 && !posthog?.isFeatureEnabled('upsell_high_score')) {
      return false;
    }
    
    // A/B test holdout
    if (isInHoldout) return false;
    
    return true;
  }, [getDwellTime, state.hasShownThisSession, isInSnooze, options.score, posthog, isInHoldout]);

  // Get weak domains for analytics
  const getWeakDomains = useCallback(() => {
    return options.weakDomains || [];
  }, [options.weakDomains]);

  // Maybe open modal with specific trigger
  const maybeOpen = useCallback((trigger: UpsellTrigger) => {
    if (!canShowModal()) return false;
    
    setState(prev => {
      const newState = {
        ...prev,
        isOpen: true,
        trigger,
        hasShownThisSession: true,
      };

      // Fire analytics with current variant (after potential score-based updates)
      const currentVariant = getVariantFromScore(options.score);
      posthog?.capture('upsell_view', {
        trigger,
        score: options.score,
        dwellMs: getDwellTime(),
        weakDomains: getWeakDomains(),
        variant: currentVariant,
        abBucket,
      });

      return newState;
    });

    return true;
  }, [canShowModal, posthog, options.score, getDwellTime, getWeakDomains, abBucket]);

  // Force open modal (for testing)
  const openNow = useCallback((variant?: UpsellVariant) => {
    const finalVariant = variant || getVariantFromScore(options.score);
    
    setState(prev => ({
      ...prev,
      isOpen: true,
      trigger: 'paywall', // Default trigger for forced opens
      variant: finalVariant,
      hasShownThisSession: true,
    }));

    posthog?.capture('upsell_view', {
      trigger: 'forced',
      score: options.score,
      dwellMs: getDwellTime(),
      weakDomains: getWeakDomains(),
      variant: finalVariant,
      abBucket,
    });
  }, [posthog, options.score, getDwellTime, getWeakDomains, abBucket]);

  // Dismiss modal and set snooze
  const dismiss = useCallback(() => {
    setState(prev => ({ ...prev, isOpen: false, trigger: null }));
    
    // Set snooze period
    try {
      if (typeof window !== 'undefined') {
        const storageKey = user?.id ? `upsell_snooze_${user.id}` : 'upsell_snooze_anon';
        window.localStorage.setItem(storageKey, Date.now().toString());
      }
    } catch {
      // no-op
    }
    
    // Fire analytics
    posthog?.capture('upsell_dismiss', {
      trigger: state.trigger,
      score: options.score,
      dwellMs: getDwellTime(),
      variant: state.variant,
      abBucket,
    });
  }, [user?.id, posthog, state.trigger, state.variant, options.score, getDwellTime, abBucket]);

  // Handle CTA click
  const handleCTAClick = useCallback(() => {
    posthog?.capture('upsell_cta_click', {
      trigger: state.trigger,
      score: options.score,
      dwellMs: getDwellTime(),
      variant: state.variant,
      abBucket,
    });
    
    // Close modal and navigate to signup/billing
    setState(prev => ({ ...prev, isOpen: false, trigger: null }));
  }, [posthog, state.trigger, state.variant, options.score, getDwellTime, abBucket]);

  return {
    isOpen: state.isOpen,
    trigger: state.trigger,
    variant: state.variant,
    canShowModal: canShowModal(),
    maybeOpen,
    openNow,
    dismiss,
    handleCTAClick,
    dwellTime: getDwellTime(),
  };
};

// Helper function to get variant based on score
function getVariantFromScore(score: number): UpsellVariant {
  if (score < 50) return 'foundation';
  if (score < 80) return 'almost';
  return 'polish';
}
</file>

<file path="lib/access/pmleEntitlements.server.ts">
/**
 * Server-side PMLE Access & Entitlements Helper
 * 
 * This file contains server-only helpers that require Next.js server APIs.
 * Import this only in API routes and Server Components.
 */

import type { User } from "@supabase/supabase-js";
import { getAccessLevel, type AccessLevel } from "./pmleEntitlements";

/**
 * Server-side helper to get PMLE access level from a Request
 * 
 * This function:
 * 1. Gets the authenticated user from Supabase
 * 2. Checks subscription status using isSubscriber()
 * 3. Returns the computed access level
 * 
 * @returns Promise with access level and user object
 */
export async function getPmleAccessLevelForRequest(): Promise<{ accessLevel: AccessLevel; user: User | null }> {
  // Dynamic import to avoid circular dependencies
  const { createServerSupabaseClient } = await import("@/lib/supabase/server");
  const { isSubscriber } = await import("@/lib/auth/entitlements");

  const supabase = createServerSupabaseClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { accessLevel: "ANONYMOUS", user: null };
  }

  const hasSubscription = await isSubscriber(user.id);
  const accessLevel = getAccessLevel({ user, isSubscriber: hasSubscription });

  return { accessLevel, user };
}
</file>

<file path="lib/access/pmleEntitlements.ts">
/**
 * PMLE Access & Entitlements Helper
 * 
 * Centralizes PMLE access logic for anonymous users, free accounts, and subscribers
 * so gating is consistent across diagnostic summary, practice, and dashboard.
 * 
 * Usage:
 * - Server-side: Use `getPmleAccessLevelForRequest()` to get access level from a Request
 * - Client-side: Use `getPmleAccessLevelForUser()` with billing status from `/api/billing/status`
 * - Check feature access: Use `canUseFeature(accessLevel, feature)` for gating decisions
 * 
 * Adding new exams or features:
 * 1. Add new feature to `PmleFeature` type
 * 2. Update `FEATURE_MATRIX` with access rules for the new feature
 * 3. Update this documentation with the new feature's behavior
 */

import type { User } from "@supabase/supabase-js";
import type { BillingStatusResponse } from "@/app/api/billing/status/route";

/**
 * Access levels for PMLE users
 * - ANONYMOUS: No account (not logged in)
 * - FREE: Logged in, no active subscription
 * - SUBSCRIBER: Has active or trialing subscription (status in ("active","trialing"))
 */
export type AccessLevel = "ANONYMOUS" | "FREE" | "SUBSCRIBER";

/**
 * PMLE features that can be gated by access level
 * - DIAGNOSTIC_RUN: Ability to start/run a diagnostic test
 * - DIAGNOSTIC_SUMMARY_BASIC: View basic diagnostic summary (score, domain breakdown)
 * - DIAGNOSTIC_SUMMARY_FULL: View full diagnostic summary including question-level details
 * - EXPLANATIONS: Access to question explanations in diagnostic results
 * - PRACTICE_SESSION: Create unlimited, domain-targeted practice sessions
 * - PRACTICE_SESSION_FREE_QUOTA: Create limited practice sessions (free tier quota)
 */
export type PmleFeature =
  | "DIAGNOSTIC_RUN"
  | "DIAGNOSTIC_SUMMARY_BASIC"
  | "DIAGNOSTIC_SUMMARY_FULL"
  | "EXPLANATIONS"
  | "PRACTICE_SESSION"
  | "PRACTICE_SESSION_FREE_QUOTA";

/**
 * Feature access matrix encoding Week 4 rules:
 * 
 * ANONYMOUS:
 * -  DIAGNOSTIC_RUN: 1 diagnostic run allowed
 * -  DIAGNOSTIC_SUMMARY_BASIC: Can view basic summary (score + domain breakdown)
 * -  DIAGNOSTIC_SUMMARY_FULL: Cannot view full summary with question details
 * -  EXPLANATIONS: No explanations access
 * -  PRACTICE_SESSION: No unlimited practice
 * -  PRACTICE_SESSION_FREE_QUOTA: No free practice quota
 * 
 * FREE (logged in, no subscription):
 * -  DIAGNOSTIC_RUN: Can run diagnostics
 * -  DIAGNOSTIC_SUMMARY_BASIC: Can view basic summary
 * -  DIAGNOSTIC_SUMMARY_FULL: Can view full summary with question details
 * -  EXPLANATIONS: No explanations (paid feature)
 * -  PRACTICE_SESSION: No unlimited practice
 * -  PRACTICE_SESSION_FREE_QUOTA: Limited practice quota (e.g., ~5 questions per week)
 * 
 * SUBSCRIBER (active or trialing subscription):
 * -  All features: Full access to everything
 */
const FEATURE_MATRIX: Record<AccessLevel, Record<PmleFeature, boolean>> = {
  ANONYMOUS: {
    DIAGNOSTIC_RUN: true,
    DIAGNOSTIC_SUMMARY_BASIC: true,
    DIAGNOSTIC_SUMMARY_FULL: false,
    EXPLANATIONS: false,
    PRACTICE_SESSION: false,
    PRACTICE_SESSION_FREE_QUOTA: false,
  },
  FREE: {
    DIAGNOSTIC_RUN: true,
    DIAGNOSTIC_SUMMARY_BASIC: true,
    DIAGNOSTIC_SUMMARY_FULL: true,
    EXPLANATIONS: false,
    PRACTICE_SESSION: false,
    PRACTICE_SESSION_FREE_QUOTA: true,
  },
  SUBSCRIBER: {
    DIAGNOSTIC_RUN: true,
    DIAGNOSTIC_SUMMARY_BASIC: true,
    DIAGNOSTIC_SUMMARY_FULL: true,
    EXPLANATIONS: true,
    PRACTICE_SESSION: true,
    PRACTICE_SESSION_FREE_QUOTA: true,
  },
};

/**
 * Determines access level from user and subscription status
 * 
 * @param params - Object containing user and subscription status
 * @param params.user - Supabase user object (null if anonymous)
 * @param params.isSubscriber - Whether user has active/trialing subscription
 * @returns AccessLevel - "ANONYMOUS", "FREE", or "SUBSCRIBER"
 */
export function getAccessLevel({
  user,
  isSubscriber,
}: {
  user: User | null;
  isSubscriber: boolean;
}): AccessLevel {
  if (!user) {
    return "ANONYMOUS";
  }

  if (isSubscriber) {
    return "SUBSCRIBER";
  }

  return "FREE";
}

/**
 * Checks if a given access level can use a specific PMLE feature
 * 
 * @param accessLevel - The user's access level
 * @param feature - The feature to check access for
 * @returns boolean - true if access is allowed, false otherwise
 */
export function canUseFeature(
  accessLevel: AccessLevel,
  feature: PmleFeature
): boolean {
  return FEATURE_MATRIX[accessLevel][feature];
}

/**
 * Client-side helper to get PMLE access level from user and billing status
 * 
 * @param user - Supabase user object (null if anonymous)
 * @param billingStatus - Billing status from `/api/billing/status` (null if not fetched)
 * @returns AccessLevel - Computed access level
 */
export function getPmleAccessLevelForUser(
  user: User | null,
  billingStatus: BillingStatusResponse | null
): AccessLevel {
  const isSubscriber = billingStatus?.isSubscriber ?? false;
  return getAccessLevel({ user, isSubscriber });
}
</file>

<file path="app/dashboard/layout.tsx">
import { AppShell } from "@/components/layout/AppShell";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <AppShell>{children}</AppShell>;
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />;
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="components/ui/navigator-tile.tsx">
"use client";

import * as React from "react";
import { Flag } from "lucide-react";
import { cn } from "@/lib/utils";

export interface NavigatorTileProps {
  questionNumber: number;
  onClick: () => void;
  isAnswered?: boolean;
  isCurrent?: boolean;
  isFlagged?: boolean;
}

export const NavigatorTile = React.forwardRef<
  HTMLButtonElement,
  NavigatorTileProps
>(({ questionNumber, onClick, isAnswered = false, isCurrent = false, isFlagged = false }, ref) => {
  return (
    <button
      ref={ref}
      type="button"
      onClick={onClick}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center rounded-md border text-sm font-medium transition-colors",
        "hover:border-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1",
        // Default state (unanswered)
        !isCurrent && !isAnswered && "border-slate-200 bg-white text-slate-700",
        // Answered state
        !isCurrent && isAnswered && "border-blue-200 bg-blue-50 text-blue-700",
        // Current state
        isCurrent && "border-blue-600 bg-blue-600 text-white"
      )}
      aria-label={`Question ${questionNumber}${isFlagged ? ", flagged" : ""}${isAnswered ? ", answered" : ""}`}
    >
      {questionNumber}
      {isFlagged && (
        <Flag
          data-testid="flag-icon"
          className="absolute -right-1 -top-1 h-3 w-3 text-amber-400"
          fill="currentColor"
          aria-hidden="true"
        />
      )}
    </button>
  );
});

NavigatorTile.displayName = "NavigatorTile";
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-transparent px-3 py-2.5 text-base shadow-xs transition-[color,box-shadow] outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50 md:text-sm md:leading-5",
          "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
          "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
          "resize-y",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="hooks/useStartBasicCheckout.ts">
"use client";

import { useCallback } from "react";
import { useRouter } from "next/navigation";
import { usePostHog } from "posthog-js/react";
import { useAuth } from "@/components/providers/AuthProvider";
import { ANALYTICS_EVENTS, trackEvent } from "@/lib/analytics/analytics";

const BASIC_MONTHLY_PRICE_ID = process.env.NEXT_PUBLIC_STRIPE_BASIC_MONTHLY;

export function useStartBasicCheckout() {
  const router = useRouter();
  const posthog = usePostHog();
  const { user } = useAuth();

  const startBasicCheckout = useCallback(
    async (source: string) => {
      posthog?.capture(ANALYTICS_EVENTS.UPGRADE_CTA_CLICKED, {
        source,
        user_id: user?.id,
      });

      // For anonymous users, always redirect to signup even if price ID is missing
      // This ensures signup flows work regardless of Stripe configuration
      if (!user) {
        if (!BASIC_MONTHLY_PRICE_ID) {
          // Log warning for configuration issues but don't block UX
          console.warn("Basic monthly price ID is not configured - signup redirect will proceed");
          trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_ERROR, {
            source,
            error: "missing_basic_monthly_price_id",
            user_state: "anonymous",
          });
        }
        trackEvent(posthog, ANALYTICS_EVENTS.UPGRADE_SIGNUP_REDIRECT, {
          source,
        });
        router.push("/signup?redirect=/pricing");
        return;
      }

      // For authenticated users, require price ID before initiating checkout
      if (!BASIC_MONTHLY_PRICE_ID) {
        console.error("Basic monthly price ID is not configured");
        trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_ERROR, {
          source,
          error: "missing_basic_monthly_price_id",
          user_state: "authenticated",
        });
        // Redirect to pricing page as fallback instead of silent failure
        router.push("/pricing");
        return;
      }

      trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_INITIATED, {
        source,
        price_id: BASIC_MONTHLY_PRICE_ID,
        billing_interval: "monthly",
        plan_name: "Basic",
        user_id: user.id,
      });

      try {
        const response = await fetch("/api/billing/checkout", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ priceId: BASIC_MONTHLY_PRICE_ID }),
        });

        const data = (await response.json()) as { error?: string; url?: string };

        if (!response.ok) {
          throw new Error(data.error || "Failed to create checkout session");
        }

        trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_SESSION_CREATED, {
          source,
          price_id: BASIC_MONTHLY_PRICE_ID,
          billing_interval: "monthly",
          plan_name: "Basic",
          user_id: user.id,
        });

        if (data.url) {
          window.location.href = data.url;
        }
      } catch (error) {
        console.error("Error starting checkout:", error);
        trackEvent(posthog, ANALYTICS_EVENTS.CHECKOUT_ERROR, {
          source,
          price_id: BASIC_MONTHLY_PRICE_ID,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    },
    [posthog, router, user]
  );

  return { startBasicCheckout };
}
</file>

<file path="lib/analytics/analytics.ts">
// Type for PostHog client (both client-side and server-side)
export type PostHogClient =
  | {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      capture: (event: string, properties?: Record<string, any>) => void;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      identify: (userId: string, properties?: Record<string, any>) => void;
    }
  | {
      capture: (params: {
        distinctId: string;
        event: string;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        properties?: Record<string, any>;
      }) => void;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      identify: (params: { distinctId: string; properties?: Record<string, any> }) => void;
      shutdown?: () => void;
    }
  | null;

// For typing purposes in client-side code
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type PostHog = any;

// Event names as constants to prevent typos and ensure consistency
export const ANALYTICS_EVENTS = {
  // Authentication & Session
  USER_SESSION_STARTED: "user_session_started",
  USER_SESSION_ENDED: "user_session_ended",
  USER_IDENTIFIED: "user_identified",
  SIGNUP_ATTEMPT: "signup_attempt",
  SIGNUP_SUCCESS: "signup_success",
  SIGNUP_ERROR: "signup_error",
  LOGIN_ATTEMPT: "login_attempt",
  LOGIN_ERROR: "login_error",

  // Dashboard
  DASHBOARD_VIEWED: "dashboard_viewed",
  DASHBOARD_LOADED: "dashboard_loaded",
  DASHBOARD_ERROR: "dashboard_error",

  // Diagnostic
  DIAGNOSTIC_STARTED: "diagnostic_started",
  DIAGNOSTIC_RESUME_SHOWN: "diagnostic_resume_shown",
  DIAGNOSTIC_RESUMED: "diagnostic_resumed",
  DIAGNOSTIC_QUESTION_ANSWERED: "diagnostic_question_answered",
  DIAGNOSTIC_COMPLETED: "diagnostic_completed",
  DIAGNOSTIC_ABANDONED: "diagnostic_abandoned",
  DIAGNOSTIC_SUMMARY_VIEWED: "diagnostic_summary_viewed",
  DIAGNOSTIC_SUMMARY_GATED_VIEWED: "diagnostic_summary_gated_viewed",
  DIAGNOSTIC_SUMMARY_SIGNUP_CTA_CLICKED: "diagnostic_summary_signup_cta_clicked",
  DIAGNOSTIC_DOMAIN_CLICKED: "diagnostic_domain_clicked",
  STUDY_PLAN_START_PRACTICE_CLICKED: "study_plan_start_practice_clicked",

  // Study Path
  STUDY_PATH_VIEWED: "study_path_viewed",
  STUDY_PATH_GENERATED: "study_path_generated",
  STUDY_PATH_ERROR: "study_path_error",

  // Practice Questions
  PRACTICE_PAGE_VIEWED: "practice_page_viewed",
  PRACTICE_QUESTION_LOADED: "practice_question_loaded",
  PRACTICE_QUESTION_ANSWERED: "practice_question_answered",
  PRACTICE_QUESTION_ERROR: "practice_question_error",
  PRACTICE_SESSION_CREATED_FROM_DIAGNOSTIC: "practice_session_created_from_diagnostic",
  PRACTICE_SESSION_CREATION_FAILED_FROM_DIAGNOSTIC: "practice_session_creation_failed_from_diagnostic",
  PRACTICE_SESSION_STARTED: "practice_session_started",
  PRACTICE_SESSION_COMPLETED: "practice_session_completed",
  PRACTICE_SESSION_SUMMARY_VIEWED: "practice_session_summary_viewed",
  PRACTICE_QUOTA_EXCEEDED: "practice_quota_exceeded",
  QUESTION_EXPLANATION_VIEWED: "question_explanation_viewed",

  // Subscription & Billing
  SUBSCRIPTION_CREATED: "subscription_created",
  SUBSCRIPTION_UPDATED: "subscription_updated",
  SUBSCRIPTION_CANCELLED: "subscription_cancelled",
  PAYMENT_FAILED: "payment_failed",
  CHECKOUT_INITIATED: "checkout_initiated",
  CHECKOUT_SESSION_CREATED: "checkout_session_created",
  CHECKOUT_ERROR: "checkout_error",
  UPGRADE_CTA_CLICKED: "upgrade_cta_clicked",
  UPGRADE_SIGNUP_REDIRECT: "upgrade_signup_redirect",
  BILLING_PORTAL_ACCESSED: "billing_portal_accessed",
  GATE_VIEWED: "gate_viewed",
  GATE_CTA_CLICKED: "gate_cta_clicked",
  GATE_DISMISSED: "gate_dismissed",
  ENTITLEMENT_CHECK_FAILED: "entitlement_check_failed",

  // Pricing
  PRICING_PAGE_VIEWED: "pricing_page_viewed",
  PRICING_PLAN_SELECTED: "pricing_plan_selected",

  // Errors
  UNHANDLED_ERROR: "unhandled_error",
  ERROR_RECOVERY_ATTEMPTED: "error_recovery_attempted",

  // Email Verification
  EMAIL_VERIFICATION_PAGE_VIEWED: "email_verification_page_viewed",
  EMAIL_CONFIRMED: "email_confirmed",
  EMAIL_VERIFICATION_ERROR: "email_verification_error",

  // Conversion Events
  TRIAL_STARTED: "trial_started",
  TRIAL_TO_PAID_CONVERSION: "trial_to_paid_conversion",

  // Feature Discovery
  FEATURE_DISCOVERED: "feature_discovered",
  FEATURE_USED: "feature_used",

  // Beta Onboarding Flow
  BETA_STARTED: "beta_started",
  START_DIAGNOSTIC_CLICKED: "start_diagnostic_clicked",
  DIAGNOSTIC_SESSION_CREATED: "diagnostic_session_created",
  SKIP_DIAGNOSTIC_CLICKED: "skip_diagnostic_clicked",
  BETA_BANNER_VIEWED: "beta_banner_viewed",
  BETA_BANNER_DISMISSED: "beta_banner_dismissed",

  // Email Campaign Events
  EMAIL_CAMPAIGN_LANDING: "email_campaign_landing",
  CAMPAIGN_ATTRIBUTION_SET: "campaign_attribution_set",
  EMAIL_CAMPAIGN_TRACKING_PIXEL_LOADED: "email_campaign_tracking_pixel_loaded",
} as const;

// User property keys for consistency
export const USER_PROPERTIES = {
  EMAIL: "email",
  USER_ID: "user_id",
  SUBSCRIPTION_TIER: "subscription_tier",
  SUBSCRIPTION_STATUS: "subscription_status",
  IS_PAYING_CUSTOMER: "is_paying_customer",
  IS_TRIAL: "is_trial",
  CUSTOMER_SINCE: "customer_since",
  CHURNED_AT: "churned_at",
  EXAM_TYPE: "exam_type",
  READINESS_SCORE: "readiness_score",
  TOTAL_PRACTICE_QUESTIONS: "total_practice_questions",
  ACCURACY_PERCENTAGE: "accuracy_percentage",
  PLAN_TIER: "plan_tier",
  IS_EARLY_ACCESS: "is_early_access",
  EMAIL_VERIFIED: "email_verified",
} as const;

// Helper types
export type AnalyticsEvent = (typeof ANALYTICS_EVENTS)[keyof typeof ANALYTICS_EVENTS];
export type UserProperty = (typeof USER_PROPERTIES)[keyof typeof USER_PROPERTIES];

// Helper function to track events with proper typing
export function trackEvent(
  posthog: PostHogClient | PostHog,
  event: AnalyticsEvent,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  distinctId?: string
) {
  if (!posthog) return;

  // Check if it's server-side PostHog (has distinctId parameter in capture)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if (distinctId && posthog && typeof (posthog as any).capture === "function") {
    // Server-side PostHog
    (posthog as PostHog).capture({
      distinctId,
      event,
      properties: properties || {},
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } else if (posthog && typeof (posthog as any).capture === "function") {
    // Client-side PostHog
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (posthog as any).capture(event, properties);
  }
}

// Helper function to identify users with proper typing
export function identifyUser(
  posthog: PostHogClient | PostHog,
  userId: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Partial<Record<UserProperty, any>>
) {
  if (!posthog) return;

  // Check if it's server-side PostHog (has shutdown method)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((posthog as any)?.shutdown) {
    // Server-side PostHog
    (posthog as PostHog).identify({
      distinctId: userId,
      properties: properties || {},
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } else if (posthog && typeof (posthog as any).identify === "function") {
    // Client-side PostHog
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (posthog as any).identify(userId, properties);
  }
}

// Helper function to track conversion events
export function trackConversion(
  posthog: PostHogClient | PostHog,
  conversionType: string,
  value: number,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  const conversionData = {
    conversion_type: conversionType,
    conversion_value: value,
    ...properties,
  };

  trackEvent(posthog, ANALYTICS_EVENTS.TRIAL_TO_PAID_CONVERSION, conversionData, userId);
}

// Helper function to track errors consistently
export function trackError(
  posthog: PostHogClient | PostHog,
  error: Error | string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  context?: Record<string, any>,
  userId?: string
) {
  const errorData = {
    error_message: typeof error === "string" ? error : error.message,
    error_stack: typeof error === "object" ? error.stack : undefined,
    error_name: typeof error === "object" ? error.name : "Error",
    ...context,
  };

  trackEvent(posthog, ANALYTICS_EVENTS.UNHANDLED_ERROR, errorData, userId);
}

// Helper function to calculate and track engagement metrics
export function trackEngagement(
  posthog: PostHogClient | PostHog,
  engagementType: "session_duration" | "page_depth" | "feature_interaction",
  value: number,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>,
  userId?: string
) {
  const eventData = {
    engagement_type: engagementType,
    engagement_value: value,
    ...properties,
  };

  trackEvent(posthog, ANALYTICS_EVENTS.FEATURE_USED, eventData, userId);
}
</file>

<file path="app/dashboard/page.tsx">
"use client";

import React, { useEffect, useState, useMemo } from "react";
import { useAuth } from "@/components/providers/AuthProvider";
import { ReadinessSnapshotCard } from "@/components/dashboard/ReadinessSnapshotCard";
import { DashboardHeader } from "@/components/dashboard/DashboardHeader";
import { ExamBlueprintTable } from "@/components/dashboard/ExamBlueprintTable";
import { NextBestStepCard } from "@/components/dashboard/NextBestStepCard";
import { RecentActivityList, type Activity } from "@/components/dashboard/RecentActivityList";
import { Button } from "@/components/ui/button";
import { colorSemantic } from "@/lib/design-system";
import { usePostHog } from "posthog-js/react";
import { X } from "lucide-react";
import { useStartBasicCheckout } from "@/hooks/useStartBasicCheckout";
import { PMLE_BLUEPRINT } from "@/lib/constants/pmle-blueprint";
import type { DomainStat } from "@/components/dashboard/ExamBlueprintTable";

// Import types from the API route
import type { DashboardData, SuccessResponse, ErrorResponse } from "@/app/api/dashboard/route";
import type { ExamReadinessSummary, DashboardSummarySuccessResponse, ErrorResponse as DashboardSummaryErrorResponse } from "@/app/api/dashboard/summary/route";

// Import beta onboarding constants
import { FEATURE_FLAGS, getBetaVariantContent } from "@/lib/constants/beta-onboarding";
import {
  getPmleAccessLevelForUser,
  type AccessLevel,
} from "@/lib/access/pmleEntitlements";
import type { BillingStatusResponse } from "@/app/api/billing/status/route";

const DashboardPage = () => {
  const { user } = useAuth();
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(null);
  const [examReadiness, setExamReadiness] = useState<ExamReadinessSummary | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showBetaBanner, setShowBetaBanner] = useState(false);
  const [betaVariant, setBetaVariant] = useState<'A' | 'B'>('A');
  const [accessLevel, setAccessLevel] = useState<AccessLevel>("ANONYMOUS");
  const posthog = usePostHog();
  const { startBasicCheckout } = useStartBasicCheckout();

  // Fetch billing status to compute access level
  useEffect(() => {
    if (!user) {
      setAccessLevel("ANONYMOUS");
      return;
    }

    const fetchBillingStatus = async () => {
      try {
        const response = await fetch("/api/billing/status");
        if (response.ok) {
          const data = (await response.json()) as BillingStatusResponse;
          const level = getPmleAccessLevelForUser(user, data);
          setAccessLevel(level);
        }
      } catch (err) {
        console.error("Error fetching billing status:", err);
        // Default to FREE if fetch fails (user is logged in)
        setAccessLevel(getPmleAccessLevelForUser(user, null));
      }
    };

    fetchBillingStatus();
  }, [user]);

  // Track dashboard page view (middleware ensures auth)
  useEffect(() => {
    if (user) {
      posthog?.capture("dashboard_viewed", {
        user_id: user.id,
        access_level: accessLevel,
      });
    }
  }, [user, posthog, accessLevel]);

  // Check if we should show the beta banner
  useEffect(() => {
    if (FEATURE_FLAGS.BETA_ONBOARDING_FLOW) {
      const urlParams = new URLSearchParams(window.location.search);
      const fromBetaWelcome = urlParams.get('from') === 'beta_welcome';
      const variant = urlParams.get('beta_variant') as 'A' | 'B' | null;
      let dismissed = null;
      try {
        dismissed = localStorage.getItem('beta_diagnostic_banner_dismissed');
      } catch {
        // no-op
      }
      
      if (variant) {
        setBetaVariant(variant === 'B' ? 'B' : 'A');
        try {
          localStorage.setItem('beta_variant', variant === 'B' ? 'B' : 'A');
        } catch {
          // no-op
        }
      }
      
      if (fromBetaWelcome && !dismissed) {
        setShowBetaBanner(true);
      }
    }
  }, []);

  useEffect(() => {
    // Middleware ensures user is authenticated
    if (!user) return;

    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch("/api/dashboard");
        const data: SuccessResponse | ErrorResponse = await response.json();

        if (!response.ok) {
          throw new Error((data as ErrorResponse).error || "Failed to fetch dashboard data");
        }

        setDashboardData((data as SuccessResponse).data);

        // Track successful dashboard load with metrics
        posthog?.capture("dashboard_loaded", {
          user_id: user.id,
          readiness_score: (data as SuccessResponse).data.readinessScore,
          total_diagnostic_sessions: (data as SuccessResponse).data.diagnostic.totalSessions,
          total_practice_questions: (data as SuccessResponse).data.practice.totalQuestionsAnswered,
          correct_answers: (data as SuccessResponse).data.practice.correctAnswers,
          accuracy_percentage: (data as SuccessResponse).data.practice.accuracyPercentage,
          has_diagnostic_data: (data as SuccessResponse).data.diagnostic.totalSessions > 0,
          has_practice_data: (data as SuccessResponse).data.practice.totalQuestionsAnswered > 0,
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Unknown error occurred";
        setError(errorMessage);

        // Track dashboard load error
        posthog?.capture("dashboard_error", {
          user_id: user?.id,
          error: errorMessage,
        });
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
  }, [user, posthog]);

  // Fetch exam readiness summary separately
  useEffect(() => {
    if (!user) return;

    const fetchExamReadiness = async () => {
      try {
        const response = await fetch("/api/dashboard/summary?examKey=pmle");
        const data: DashboardSummarySuccessResponse | DashboardSummaryErrorResponse = await response.json();

        if (response.ok && 'status' in data && data.status === 'ok') {
          setExamReadiness(data.data);
        } else {
          // Log error but don't break the dashboard - fall back to empty state
          const errorMessage = 'error' in data ? data.error : "Unknown error";
          console.error('Failed to fetch exam readiness summary:', errorMessage);
          posthog?.capture("dashboard_readiness_summary_error", {
            user_id: user.id,
            error: errorMessage,
          });
        }
      } catch (err) {
        // Log error but don't break the dashboard
        console.error('Error fetching exam readiness summary:', err);
        posthog?.capture("dashboard_readiness_summary_error", {
          user_id: user.id,
          error: err instanceof Error ? err.message : "Unknown error",
        });
      }
    };

    fetchExamReadiness();
  }, [user, posthog]);

  const handleDismissBanner = () => {
    setShowBetaBanner(false);
    try {
      localStorage.setItem('beta_diagnostic_banner_dismissed', 'true');
    } catch {
      // no-op
    }
  };

  const handleStartDiagnostic = async () => {
    try {
      const response = await fetch('/api/diagnostic/session', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          examKey: 'pmle',
          source: 'dashboard_readiness_card',
        }),
      });

      if (response.ok) {
        const { sessionId } = await response.json();
        window.location.href = `/diagnostic/${sessionId}`;
      }
    } catch (error) {
      console.error('Error starting diagnostic:', error);
    }
  };


  // Mock domain stats (placeholder until API provides this data)
  const mockDomainStats: DomainStat[] = useMemo(() => {
    return PMLE_BLUEPRINT.map((domain) => {
      // Mock data - in production this would come from API
      const baseQuestions = Math.floor(Math.random() * 50) + 10;
      const answered = Math.floor(baseQuestions * (0.5 + Math.random() * 0.5));
      const accuracy = Math.floor(Math.random() * 40) + 60; // 60-100%
      
      return {
        domainCode: domain.domainCode,
        questionsAnswered: answered,
        totalQuestions: baseQuestions,
        accuracy,
      };
    });
  }, []);

  // Calculate weakest domain for recommendations
  const weakestDomain = useMemo(() => {
    if (mockDomainStats.length === 0) return null;
    const weakest = mockDomainStats.reduce((min, stat) =>
      stat.accuracy < min.accuracy ? stat : min
    );
    const domainConfig = PMLE_BLUEPRINT.find((d) => d.domainCode === weakest.domainCode);
    return domainConfig ? { ...weakest, displayName: domainConfig.displayName } : null;
  }, [mockDomainStats]);

  // Mock recent activities (placeholder until API provides this data)
  const mockActivities: Activity[] = useMemo(() => {
    return [
      {
        type: "exam_completed",
        title: "Completed a 50-question exam",
        score: 88,
        timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000), // 2 hours ago
      },
      {
        type: "domain_mastered",
        title: "Mastered 'Stakeholder Engagement'",
        timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000), // 1 day ago
      },
      {
        type: "quiz_completed",
        title: "Finished a 25-question quiz",
        score: 75,
        timestamp: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // 3 days ago
      },
    ];
  }, []);

  // Calculate blueprint coverage
  const blueprintCoverage = useMemo(() => {
    const totalAnswered = mockDomainStats.reduce((sum, stat) => sum + stat.questionsAnswered, 0);
    const totalPossible = mockDomainStats.reduce((sum, stat) => sum + stat.totalQuestions, 0);
    return totalPossible > 0 ? Math.round((totalAnswered / totalPossible) * 100) : 0;
  }, [mockDomainStats]);

  // Show loading state
  if (!user || loading) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: colorSemantic.background.default }}>
        <div className="container mx-auto px-4 py-8">
          <div className="flex items-center justify-center h-64">
            <div style={{ color: colorSemantic.text.muted }}>
              {!user ? "Loading..." : "Loading dashboard..."}
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Show error state
  if (error) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: colorSemantic.background.default }}>
        <div className="container mx-auto px-4 py-8">
          <div className="max-w-4xl mx-auto">
            <div
              className="rounded-lg p-6 text-center border"
              style={{
                backgroundColor: colorSemantic.error.light,
                borderColor: colorSemantic.error.base + "40",
              }}
            >
              <h2
                className="text-lg font-semibold mb-2"
                style={{ color: colorSemantic.error.dark }}
              >
                Error Loading Dashboard
              </h2>
              <p className="mb-4" style={{ color: colorSemantic.error.base }}>
                {error}
              </p>
              <Button onClick={() => window.location.reload()} tone="danger">
                Try Again
              </Button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Show dashboard content
  if (!dashboardData) {
    return (
      <div className="min-h-screen" style={{ backgroundColor: colorSemantic.background.default }}>
        <div className="container mx-auto px-4 py-8">
          <div className="flex items-center justify-center h-64">
            <div style={{ color: colorSemantic.text.muted }}>No dashboard data available</div>
          </div>
        </div>
      </div>
    );
  }

  // Get variant-specific content for banner
  const variantContent = getBetaVariantContent(betaVariant);

  return (
    <div className="space-y-6">
      {/* Beta Diagnostic Banner */}
      {showBetaBanner && (
        <div className="mb-6">
          <div
            className="rounded-lg p-4 border flex items-center justify-between"
            style={{
              backgroundColor: colorSemantic.info.light,
              borderColor: colorSemantic.info.base + "40",
            }}
          >
            <div className="flex items-center gap-3">
              <div className="text-2xl">{betaVariant === 'B' ? '' : ''}</div>
              <div>
                <p className="font-medium" style={{ color: colorSemantic.info.dark }}>
                  {variantContent.skipBanner.message}
                </p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Button
                onClick={handleStartDiagnostic}
                size="sm"
                tone="accent"
                data-testid="dashboard-beta-start-btn"
              >
                {variantContent.skipBanner.cta}
              </Button>
              <Button
                onClick={handleDismissBanner}
                variant="ghost"
                size="sm"
                tone="neutral"
                className="size-8 p-1"
                aria-label="Dismiss beta banner"
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Header */}
      <DashboardHeader />

      {/* Next Best Step Card - Promoted */}
      {weakestDomain && (
        <NextBestStepCard
          domain={weakestDomain.displayName}
          questionCount={25}
          estimatedTime="30 mins"
          onStartSession={async () => {
            try {
              // Get domain code from display name
              const domainCode = weakestDomain.domainCode;
              if (!domainCode) {
                console.error("Domain code not found for:", weakestDomain.displayName);
                window.location.href = '/practice/question';
                return;
              }

              // Create practice session via API
              const response = await fetch('/api/practice/session', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  examKey: 'pmle',
                  domainCodes: [domainCode],
                  questionCount: 10,
                  source: 'dashboard_next_best_step',
                }),
              });

              if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                console.error('Failed to create practice session:', errorData);
                // Fallback to old practice question page
                window.location.href = `/practice/question?domain=${encodeURIComponent(weakestDomain.displayName)}`;
                return;
              }

              const data = await response.json() as { route?: string; sessionId?: string };
              if (data.route) {
                window.location.href = data.route;
              } else if (data.sessionId) {
                window.location.href = `/practice/session/${data.sessionId}`;
              } else {
                window.location.href = '/practice/question';
              }
            } catch (error) {
              console.error('Error creating practice session:', error);
              // Fallback to old practice question page
              window.location.href = `/practice/question?domain=${encodeURIComponent(weakestDomain.displayName)}`;
            }
          }}
          onChooseAnotherMode={() => {
            window.location.href = '/practice/question';
          }}
        />
      )}

      {/* Two-column section: Readiness + Activity */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Readiness Snapshot Card */}
        <ReadinessSnapshotCard
          score={examReadiness?.currentReadinessScore ?? 0}
          hasCompletedDiagnostic={examReadiness?.hasCompletedDiagnostic ?? false}
          overallAccuracy={dashboardData.practice.accuracyPercentage}
          blueprintCoverage={blueprintCoverage}
          weakestDomain={weakestDomain?.displayName}
          weakestDomainWeight={weakestDomain ? (() => {
            const domain = PMLE_BLUEPRINT.find((d) => d.domainCode === weakestDomain.domainCode);
            return domain ? Math.round(domain.weight * 100) : undefined;
          })() : undefined}
          onStartDiagnostic={handleStartDiagnostic}
          onUpgrade={() => startBasicCheckout("dashboard_readiness_card")}
          showUpgradeCTA={accessLevel !== "SUBSCRIBER"}
        />

        {/* Recent Activity List */}
        <RecentActivityList activities={mockActivities} />
      </div>

      {/* Exam Blueprint Table */}
      <ExamBlueprintTable domainStats={mockDomainStats} />
    </div>
  );
};

export default DashboardPage;
</file>

<file path="app/diagnostic/[sessionId]/summary/page.tsx">
"use client";
import React, { useState, useEffect, useCallback, useRef } from "react";
import { useParams, useRouter } from "next/navigation";
import { useAuth } from "@/components/providers/AuthProvider";
import { usePostHog } from "posthog-js/react";
import { trackEvent, ANALYTICS_EVENTS } from "@/lib/analytics/analytics";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { UpsellModal } from "@/components/diagnostic/UpsellModal";
import { useUpsell } from "@/hooks/useUpsell";
import { useTriggerDetection } from "@/hooks/useTriggerDetection";
import { useStartBasicCheckout } from "@/hooks/useStartBasicCheckout";
import { QuestionSummary, DomainBreakdown, SessionSummary } from "@/components/diagnostic/types";
import { getExamReadinessTier, getDomainTier, getDomainTierColors, READINESS_PASS_THRESHOLD } from "@/lib/readiness";
import { PMLE_BLUEPRINT } from "@/lib/constants/pmle-blueprint";
import { useToastQueue, Toast } from "@/components/ui/toast";
import {
  getPmleAccessLevelForUser,
  canUseFeature,
  type AccessLevel,
} from "@/lib/access/pmleEntitlements";
import type { BillingStatusResponse } from "@/app/api/billing/status/route";

// Extended types for UI-specific fields
interface ExtendedQuestionSummary extends QuestionSummary {
  timeSpent?: number;
  isFlagged?: boolean;
  confidence?: 'low' | 'medium' | 'high';
}

interface ExtendedSessionSummary extends SessionSummary {
  totalTimeSpent?: number;
  averageTimePerQuestion?: number;
  flaggedCount?: number;
}

// Helper function to get complete stroke color class name for SVG
// This ensures Tailwind can detect the classes at build time
const getStrokeColorClass = (tierId: string): string => {
  if (tierId === 'low') return 'text-red-600';
  if (tierId === 'building') return 'text-orange-600';
  if (tierId === 'ready') return 'text-blue-600';
  return 'text-emerald-600'; // strong
};

const formatTime = (seconds: number) => {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s`;
};

// Helper to map display name back to domain code
const getDomainCodeFromDisplayName = (displayName: string): string | null => {
  const config = PMLE_BLUEPRINT.find(d => d.displayName === displayName);
  return config?.domainCode || null;
};

// Minimum attempts required for a domain to be eligible for practice
const MIN_DOMAIN_ATTEMPTS_FOR_PRACTICE = 1;

// Select weakest 2-3 domains with sufficient attempts
const selectWeakestDomains = (domainBreakdown: DomainBreakdown[]): string[] => {
  // Filter domains with sufficient attempts and sort by percentage (lowest first)
  const eligibleDomains = domainBreakdown
    .filter(d => d.total >= MIN_DOMAIN_ATTEMPTS_FOR_PRACTICE)
    .sort((a, b) => a.percentage - b.percentage);
  
  // Select top 2-3 weakest domains
  const selectedDomains = eligibleDomains.slice(0, 3);
  
  // Convert display names to domain codes
  const domainCodes = selectedDomains
    .map(d => getDomainCodeFromDisplayName(d.domain))
    .filter((code): code is string => code !== null);
  
  return domainCodes;
};

// Components
const StatusChip = ({ 
  type, 
  className = "" 
}: { 
  type: 'correct' | 'incorrect' | 'flagged';
  className?: string;
}) => {
  const configs = {
    correct: {
      icon: "",
      text: "Correct",
      classes: "text-emerald-700 border border-emerald-200 bg-emerald-50"
    },
    incorrect: {
      icon: "",
      text: "Incorrect", 
      classes: "text-rose-700 border border-rose-200 bg-rose-50"
    },
    flagged: {
      icon: "",
      text: "Flagged",
      classes: "text-amber-700 border border-amber-200 bg-amber-50"
    }
  };

  const config = configs[type];
  
  return (
    <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.classes} ${className}`}>
      <span>{config.icon}</span>
      {config.text}
    </span>
  );
};

const LockedSection = ({
  children,
  isLocked,
}: {
  children: React.ReactNode;
  isLocked: boolean;
}) => {
  if (!isLocked) {
    return <>{children}</>;
  }

  return (
    <div className="relative">
      {/* Blurred content */}
      <div className="blur-sm pointer-events-none select-none">
        {children}
      </div>
      {/* Overlay with lock icon */}
      <div className="absolute inset-0 flex items-center justify-center bg-white/70 backdrop-blur-sm rounded-2xl">
        <div className="text-center p-6 max-w-md">
          <div className="mb-4">
            <svg
              className="w-12 h-12 mx-auto text-slate-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
              />
            </svg>
          </div>
          <h3 className="text-lg font-semibold text-slate-900 mb-2">
            Sign up free to unlock
          </h3>
          <p className="text-sm text-slate-600">
            Create a free account to see your full breakdown and study plan.
          </p>
        </div>
      </div>
    </div>
  );
};

const VerdictBlock = ({ 
  summary, 
  onStartPractice,
  onRetakeDiagnostic,
  isLoading 
}: {
  summary: ExtendedSessionSummary;
  onStartPractice: () => void;
  onRetakeDiagnostic: () => void;
  isLoading?: boolean;
}) => {
  const readinessTier = getExamReadinessTier(summary.score);
  const strokeColorClass = getStrokeColorClass(readinessTier.id);
  const duration = summary.totalTimeSpent ? 
    formatTime(summary.totalTimeSpent) : 
    Math.round((new Date(summary.completedAt).getTime() - new Date(summary.startedAt).getTime()) / 60000) + "m";
  
  // Constructive messaging for 0-score diagnostics
  const isZeroScore = summary.score === 0;
  const verdictIntro = isZeroScore 
    ? "This was your first attempt. Here's where to start building your foundation."
    : null;

  return (
    <div className="rounded-2xl border border-slate-200 bg-white p-4 md:p-6 shadow-sm mb-8">
      {verdictIntro && (
        <div className="mb-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
          <p className="text-sm text-blue-700">{verdictIntro}</p>
        </div>
      )}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Left: Gauge and Readiness */}
        <div className="flex items-center gap-6">
          <div className="relative w-24 h-24">
            <svg className="w-24 h-24 transform -rotate-90" viewBox="0 0 36 36">
              <path
                className="text-slate-100"
                stroke="currentColor"
                strokeWidth="3"
                fill="transparent"
                d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
              />
              <path
                className={strokeColorClass}
                stroke="currentColor"
                strokeWidth="3"
                fill="transparent"
                strokeDasharray={`${summary.score}, 100`}
                d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
              />
            </svg>
            <div className="absolute inset-0 flex items-center justify-center">
              <span className="text-lg font-bold text-slate-900">{summary.score}%</span>
            </div>
          </div>
          <div>
            <div className="text-2xl font-bold text-slate-900 mb-1">
              Readiness: {readinessTier.label}
            </div>
            <div className="text-sm text-slate-500">
              Pass typically {READINESS_PASS_THRESHOLD}%
            </div>
          </div>
        </div>

        {/* Right: Key Facts */}
        <div className="space-y-3">
          <div className="flex justify-between text-sm">
            <span className="text-slate-600">Exam:</span>
            <span className="font-medium text-slate-900">{summary.examType}  Oct &apos;24</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-slate-600">Score:</span>
            <span className="font-medium text-slate-900">{summary.score}% ({summary.totalQuestions} Qs)</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-slate-600">Time taken:</span>
            <span className="font-medium text-slate-900">{duration}</span>
          </div>
          {summary.flaggedCount !== undefined && (
            <div className="flex justify-between text-sm">
              <span className="text-slate-600">Flagged:</span>
              <span className="font-medium text-slate-900">{summary.flaggedCount}</span>
            </div>
          )}
        </div>
      </div>

      {/* CTAs */}
      <div className="flex flex-col sm:flex-row gap-3 mt-6">
        <Button onClick={onStartPractice} tone="accent" size="md" disabled={isLoading}>
          {isLoading ? "Creating practice session..." : "Start 10-min practice on your weakest topics"}
        </Button>
        <Button
          onClick={onRetakeDiagnostic}
          variant="outline"
          tone="accent"
          size="md"
          disabled={isLoading}
        >
          Retake diagnostic (20 Q)
        </Button>
      </div>
    </div>
  );
};

const DomainPerformance = ({ 
  domains, 
  onDomainClick 
}: { 
  domains: DomainBreakdown[];
  onDomainClick: (domain: string) => void;
}) => {
  // Sort domains by percentage (ascending - worst first)
  const sortedDomains = [...domains].sort((a, b) => a.percentage - b.percentage);

  return (
    <div className="rounded-2xl border border-slate-200 bg-white p-4 md:p-6 shadow-sm mb-8">
      <h2 className="text-xl font-semibold tracking-tight text-slate-900 mb-4">Domain Performance</h2>
      <div className="space-y-3">
        {sortedDomains.map((domain) => (
          <div 
            key={domain.domain}
            onClick={() => onDomainClick(domain.domain)}
            className="flex items-center gap-4 p-3 rounded-xl hover:bg-slate-50 cursor-pointer transition-colors"
          >
            <div className="flex-1">
              <div className="flex items-center justify-between mb-1">
                <span className="font-medium text-slate-900">{domain.domain}</span>
                <span className="text-sm font-medium text-slate-900">{domain.percentage}%</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="flex-1 bg-slate-100 h-2 rounded">
                  <div 
                    className="bg-indigo-600 h-2 rounded transition-all duration-300"
                    style={{ width: `${domain.percentage}%` }}
                  />
                </div>
                <span className="text-xs text-slate-500">{domain.correct}/{domain.total}</span>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

const StudyPlan = ({ 
  domains, 
  onStartPractice,
  isLoading 
}: { 
  domains: DomainBreakdown[];
  onStartPractice: (domainCodes: string[]) => void;
  isLoading?: boolean;
}) => {
  // Handle legacy sessions without domain breakdown
  if (domains.length === 0) {
    return (
      <div className="rounded-2xl border border-slate-200 bg-white p-4 md:p-6 shadow-sm mb-8">
        <h2 className="text-xl font-semibold tracking-tight text-slate-900 mb-4">Study Plan</h2>
        <div className="p-4 bg-amber-50 rounded-lg border border-amber-200 mb-4">
          <p className="text-sm text-amber-700 mb-2">
            <strong>Note:</strong> Domain-level breakdown isn&apos;t available for this earlier diagnostic session.
          </p>
          <p className="text-sm text-amber-700">
            Take a new diagnostic to unlock domain-specific study guidance and a personalized study plan.
          </p>
        </div>
        <div className="space-y-3">
          <p className="text-sm text-slate-600">
            In the meantime, focus on reviewing exam-wide concepts and practicing with our question bank.
          </p>
          <Button
            onClick={() => onStartPractice([])}
            size="sm"
            variant="outline"
            tone="accent"
            disabled={isLoading}
          >
            {isLoading ? "Creating..." : "Start general practice (10 questions)"}
          </Button>
        </div>
      </div>
    );
  }

  const foundation = domains.filter(d => d.percentage < 40);
  const core = domains.filter(d => d.percentage >= 40 && d.percentage < 70);
  const stretch = domains.filter(d => d.percentage >= 70);


  const StudyGroup = ({ 
    title, 
    description, 
    domains, 
    timeEstimate 
  }: { 
    title: string;
    description: string;
    domains: DomainBreakdown[];
    timeEstimate: string;
  }) => (
    <div className="mb-6">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-lg font-semibold text-slate-900">{title}</h3>
        <span className="text-sm text-slate-500">{timeEstimate}</span>
      </div>
      <p className="text-sm text-slate-600 mb-4">{description}</p>
      <div className="space-y-2">
        {domains.map((domain) => {
          const tier = getDomainTier(domain.percentage);
          const colors = getDomainTierColors(tier.id);
          return (
            <div key={domain.domain} className="flex items-center justify-between p-3 rounded-lg border border-slate-200">
              <div className="flex items-center gap-3">
                <span className="font-medium text-slate-900">{domain.domain}</span>
                <span className={`px-2 py-1 rounded text-xs font-medium ${colors.bg} ${colors.text}`}>
                  {tier.label}
                </span>
              </div>
              <Button
                onClick={() => onStartPractice([domain.domain])}
                size="sm"
                variant="outline"
                tone="accent"
                className="text-xs"
                disabled={isLoading}
              >
                {isLoading ? "Creating..." : "Start practice (10)"}
              </Button>
            </div>
          );
        })}
      </div>
    </div>
  );

  return (
    <div className="rounded-2xl border border-slate-200 bg-white p-4 md:p-6 shadow-sm mb-8">
      <h2 className="text-xl font-semibold tracking-tight text-slate-900 mb-6">Study Plan</h2>
      
      {foundation.length > 0 && (
        <StudyGroup 
          title="Foundation First"
          description="Critical gaps that need immediate attention. Master these foundational concepts before moving on."
          domains={foundation}
          timeEstimate="35-45 min"
        />
      )}
      
      {core.length > 0 && (
        <StudyGroup 
          title="Core"
          description="Important topics that need strengthening to reach passing level. Focus here after mastering foundation concepts."
          domains={core}
          timeEstimate="60-90 min"
        />
      )}
      
      {stretch.length > 0 && (
        <StudyGroup 
          title="Stretch"
          description="Areas where you're already strong. Practice to maintain and perfect your knowledge."
          domains={stretch}
          timeEstimate="30-45 min"
        />
      )}

      <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
        <p className="text-sm text-blue-700">
          <strong>Tip:</strong> Focus on &apos;Foundation&apos; first (~3545 min), then &apos;Core&apos; (~6090 min). 
          Consider retaking the diagnostic when your weakest domains reach {READINESS_PASS_THRESHOLD}% to track progress.
        </p>
      </div>
    </div>
  );
};

const QuestionReview = ({ 
  questions, 
  activeFilter, 
  onFilterChange,
  selectedDomain,
  onDomainChange,
  onTrackReviewEntry,
  onTrackReviewExit,
  onTrackExpansion,
  onExplanationViewed,
  canAccessExplanations,
  onUpgrade,
}: {
  questions: ExtendedQuestionSummary[];
  activeFilter: 'all' | 'incorrect' | 'flagged' | 'low-confidence';
  onFilterChange: (filter: 'all' | 'incorrect' | 'flagged' | 'low-confidence') => void;
  selectedDomain: string | null;
  onDomainChange: (domain: string | null) => void;
  onTrackReviewEntry?: () => void;
  onTrackReviewExit?: () => void;
  onTrackExpansion?: () => void;
  onExplanationViewed?: (question: ExtendedQuestionSummary) => void;
  canAccessExplanations: boolean;
  onUpgrade?: () => void;
}) => {
  const [expandedQuestions, setExpandedQuestions] = useState<Set<string>>(new Set());
  const [searchQuery, setSearchQuery] = useState('');
  const reviewSectionRef = useRef<HTMLDivElement>(null);

  // Track review section visibility for engagement trigger
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            onTrackReviewEntry?.();
          } else {
            onTrackReviewExit?.();
          }
        });
      },
      { threshold: 0.3 }
    );

    if (reviewSectionRef.current) {
      observer.observe(reviewSectionRef.current);
    }

    return () => observer.disconnect();
  }, [onTrackReviewEntry, onTrackReviewExit]);

  const toggleExpanded = useCallback((question: ExtendedQuestionSummary) => {
    setExpandedQuestions(prev => {
      const newSet = new Set(prev);
      if (newSet.has(question.id)) {
        newSet.delete(question.id);
      } else {
        newSet.add(question.id);
        // Track expansion for upsell trigger
        onTrackExpansion?.();
        // Track explanation viewed for analytics
        onExplanationViewed?.(question);
      }
      return newSet;
    });
  }, [onTrackExpansion, onExplanationViewed]);

  // Filter questions
  const filteredQuestions = questions.filter(q => {
    // Apply filter
    if (activeFilter === 'incorrect' && q.isCorrect) return false;
    if (activeFilter === 'flagged' && !q.isFlagged) return false;
    if (activeFilter === 'low-confidence' && q.confidence !== 'low') return false;
    
    // Apply domain filter
    if (selectedDomain && q.domain !== selectedDomain) return false;
    
    // Apply search
    if (searchQuery && !q.stem.toLowerCase().includes(searchQuery.toLowerCase())) return false;
    
    return true;
  });

  const domains = Array.from(new Set(questions.map(q => q.domain).filter(Boolean)));

  return (
    <div ref={reviewSectionRef} className="rounded-2xl border border-slate-200 bg-white p-6 shadow-sm mb-8">
      <h2 className="text-xl font-semibold tracking-tight text-slate-900 mb-6">Question Review</h2>
      
      {/* Controls */}
      <div className="flex flex-col sm:flex-row gap-4 mb-6">
        {/* Filter Pills */}
        <div className="flex flex-wrap gap-2">
          {[
            { key: 'all', label: 'All' },
            { key: 'incorrect', label: 'Incorrect' },
            { key: 'flagged', label: 'Flagged' },
            { key: 'low-confidence', label: 'Low Confidence' }
          ].map(filter => (
            <button
              key={filter.key}
              onClick={() => onFilterChange(filter.key as 'all' | 'incorrect' | 'flagged' | 'low-confidence')}
              className={`rounded-full px-3 py-1 text-sm border transition-colors ${
                activeFilter === filter.key
                  ? 'border-slate-900 bg-slate-900 text-white'
                  : 'border-slate-300 text-slate-700 hover:bg-slate-50'
              }`}
            >
              {filter.label}
            </button>
          ))}
        </div>

        {/* Domain Dropdown */}
        <select
          value={selectedDomain || ''}
          onChange={(e) => onDomainChange(e.target.value || null)}
          className="px-3 py-2.5 min-h-[44px] border border-slate-300 rounded-lg text-base md:text-sm"
        >
          <option value="">All Domains</option>
          {domains.map(domain => (
            <option key={domain} value={domain}>{domain}</option>
          ))}
        </select>

        {/* Search */}
        <input
          type="text"
          placeholder="Search questions..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="px-3 py-2.5 min-h-[44px] border border-slate-300 rounded-lg text-base md:text-sm flex-1 min-w-0"
        />
      </div>

      {/* Question Cards */}
      <div className="space-y-3">
        {filteredQuestions.map((question) => {
          const isExpanded = expandedQuestions.has(question.id);
          
          return (
            <div key={question.id} className="border border-slate-200 rounded-xl">
              {/* Collapsed Summary */}
              <div className="p-4">
                <div className="flex items-center gap-2 mb-2">
                  <StatusChip type={question.isCorrect ? 'correct' : 'incorrect'} />
                  {question.isFlagged && <StatusChip type="flagged" />}
                  {question.domain && (
                    <span className="px-2 py-1 bg-slate-100 text-slate-700 rounded text-xs font-medium">
                      {question.domain}
                    </span>
                  )}
                  {question.timeSpent && (
                    <span className="text-xs text-slate-500">
                      {formatTime(question.timeSpent)}
                    </span>
                  )}
                </div>
                
                <div className="text-sm text-slate-700 mb-3" style={{ 
                  display: '-webkit-box',
                  WebkitLineClamp: 2,
                  WebkitBoxOrient: 'vertical',
                  overflow: 'hidden'
                }}>
                  {question.stem}
                </div>
                
                <div className="flex items-center gap-3">
                  {canAccessExplanations ? (
                    <button
                      onClick={() => toggleExpanded(question)}
                      className="text-sm text-indigo-600 hover:text-indigo-700 font-medium"
                    >
                      {isExpanded ? 'Hide' : 'View'} explanation
                    </button>
                  ) : (
                    <button
                      onClick={() => {
                        onTrackExpansion?.();
                        onUpgrade?.();
                      }}
                      className="text-sm text-indigo-600 hover:text-indigo-700 font-medium"
                    >
                      View explanation (Premium)
                    </button>
                  )}
                  <button className="text-sm text-slate-500 hover:text-slate-700">
                    Practice similar
                  </button>
                  <button className="text-sm text-slate-500 hover:text-slate-700">
                    Bookmark
                  </button>
                </div>
              </div>

              {/* Expanded Details */}
              {isExpanded && (
                <div className="border-t border-slate-200 p-4 bg-slate-50">
                  <div className="space-y-4">
                    {/* Full Question */}
                    <div>
                      <h4 className="font-medium text-slate-900 mb-2">Question:</h4>
                      <p className="text-slate-700">{question.stem}</p>
                    </div>

                    {/* Options */}
                    <div>
                      <h4 className="font-medium text-slate-900 mb-2">Answer Choices:</h4>
                      <div className="space-y-2">
                        {question.options.map((option) => (
                          <div 
                            key={option.label}
                            className={`p-2 rounded border ${
                              option.label === question.correctAnswer ? 'bg-green-50 border-green-200' :
                              option.label === question.userAnswer ? 'bg-red-50 border-red-200' :
                              'bg-white border-slate-200'
                            }`}
                          >
                            <span className="font-medium">{option.label}:</span> {option.text}
                            {option.label === question.correctAnswer && (
                              <span className="ml-2 text-green-600 text-sm"> Correct</span>
                            )}
                            {option.label === question.userAnswer && option.label !== question.correctAnswer && (
                              <span className="ml-2 text-red-600 text-sm"> Your answer</span>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>

                    {/* Explanation */}
                    {canAccessExplanations && question.explanation ? (
                      <div>
                        <h4 className="font-medium text-slate-900 mb-2">Explanation:</h4>
                        <p className="text-slate-700">{question.explanation}</p>
                      </div>
                    ) : !canAccessExplanations ? (
                      <div className="p-4 bg-blue-50 rounded-lg border border-blue-200">
                        <p className="text-sm text-blue-700 mb-2">
                          <strong>Explanations are available for subscribers.</strong>
                        </p>
                        <p className="text-sm text-blue-600">
                          Upgrade to unlock detailed explanations for all questions and improve your understanding.
                        </p>
                        <Button
                          size="sm"
                          tone="accent"
                          className="mt-3"
                          onClick={() => onUpgrade?.()}
                        >
                          Upgrade for explanations
                        </Button>
                      </div>
                    ) : null}
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </div>

      {filteredQuestions.length === 0 && (
        <div className="text-center py-8 text-slate-500">
          No questions match your current filters.
        </div>
      )}
    </div>
  );
};

const QuickActions = ({ 
  onRetake, 
  onPractice, 
  onExport, 
  onShare,
  isLoading 
}: {
  onRetake: () => void;
  onPractice: () => void;
  onExport: () => void;
  onShare: () => void;
  isLoading?: boolean;
}) => (
  <div className="rounded-2xl border border-slate-200 bg-white p-4 md:p-6 shadow-sm">
    <h3 className="font-semibold text-slate-900 mb-4">Quick Actions</h3>
    <div className="space-y-3">
      <Button
        onClick={onRetake}
        variant="outline"
        tone="accent"
        size="sm"
        fullWidth
        className="justify-start text-sm"
      >
         Retake diagnostic
      </Button>
      <Button
        onClick={onPractice}
        variant="outline"
        tone="accent"
        size="sm"
        fullWidth
        className="justify-start text-sm"
        disabled={isLoading}
      >
        {isLoading ? "Creating..." : " Start 10-min practice"}
      </Button>
      <Button
        onClick={onExport}
        variant="outline"
        tone="accent"
        size="sm"
        fullWidth
        className="justify-start text-sm"
      >
         Export PDF
      </Button>
      <Button
        onClick={onShare}
        variant="outline"
        tone="accent"
        size="sm"
        fullWidth
        className="justify-start text-sm"
      >
         Share results
      </Button>
    </div>

    <div className="mt-4 pt-4 border-t border-slate-200">
      <h4 className="text-sm font-medium text-slate-900 mb-2">Schedule Study</h4>
      <div className="flex gap-2">
        <Button size="sm" variant="outline" tone="accent" className="flex-1 text-xs">
          15m
        </Button>
        <Button size="sm" variant="outline" tone="accent" className="flex-1 text-xs">
          30m
        </Button>
        <Button size="sm" variant="outline" tone="accent" className="flex-1 text-xs">
          45m
        </Button>
      </div>
    </div>
  </div>
);

const DiagnosticSummaryPage = () => {
  const params = useParams();
  const router = useRouter();
  const { user, isLoading: isAuthLoading } = useAuth();
  const posthog = usePostHog();
  const sessionId = params?.sessionId as string;

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [summary, setSummary] = useState<ExtendedSessionSummary | null>(null);
  const [domainBreakdown, setDomainBreakdown] = useState<DomainBreakdown[]>([]);
  const [creatingPracticeSession, setCreatingPracticeSession] = useState(false);
  const [accessLevel, setAccessLevel] = useState<AccessLevel>("ANONYMOUS");
  const [showSignupPanel, setShowSignupPanel] = useState(true);
  const [hasTrackedGatedView, setHasTrackedGatedView] = useState(false);
  
  // UI State
  const [activeFilter, setActiveFilter] = useState<'all' | 'incorrect' | 'flagged' | 'low-confidence'>('all');
  const [selectedDomain, setSelectedDomain] = useState<string | null>(null);
  
  // Toast queue for error messages
  const { toasts, addToast, dismissToast } = useToastQueue();

  // Derive anonymous flag
  const isAnonymous = accessLevel === "ANONYMOUS";

  // Calculate critical domains for upsell triggers (using shared tier helper)
  const criticalDomainCount = domainBreakdown.filter(d => getDomainTier(d.percentage).id === "critical").length;
  const weakDomains = domainBreakdown.filter(d => d.percentage < 60).map(d => d.domain);

  const { startBasicCheckout } = useStartBasicCheckout();
  
  // Initialize upsell hook
  const upsell = useUpsell({
    score: summary?.score || 0,
    enableExitIntent: process.env.NODE_ENV !== 'production' || false, // Feature flag
    enableDeepScroll: process.env.NODE_ENV !== 'production' || false, // Feature flag
    weakDomains,
  });

  // Initialize trigger detection
  const triggers = useTriggerDetection({
    onTrigger: upsell.maybeOpen,
    score: summary?.score || 0,
    criticalDomainCount,
    enableExitIntent: process.env.NODE_ENV !== 'production' || false,
    enableDeepScroll: process.env.NODE_ENV !== 'production' || false,
  });

  // Fetch billing status to compute access level
  useEffect(() => {
    if (isAuthLoading) {
      return; // Wait for auth state
    }

    const fetchBillingStatus = async () => {
      try {
        const response = await fetch("/api/billing/status");
        if (response.ok) {
          const data = (await response.json()) as BillingStatusResponse;
          const level = getPmleAccessLevelForUser(user, data);
          setAccessLevel(level);
        }
      } catch (err) {
        console.error("Error fetching billing status:", err);
        // Default to ANONYMOUS if fetch fails
        setAccessLevel(getPmleAccessLevelForUser(user, null));
      }
    };

    fetchBillingStatus();
  }, [user, isAuthLoading]);

  useEffect(() => {
    const fetchSummary = async () => {
      if (!sessionId) {
        setError("Session ID not found");
        setLoading(false);
        return;
      }

      if (isAuthLoading) {
        return; // Wait for auth state
      }

      try {
        let apiUrl = `/api/diagnostic/summary/${sessionId}`;

        // Include anonymous session ID if user is not logged in
        if (!user) {
          const anonymousSessionId = localStorage.getItem("anonymousSessionId");
          if (anonymousSessionId) {
            apiUrl += `?anonymousSessionId=${anonymousSessionId}`;
          }
        }

        const response = await fetch(apiUrl);
        const data = (await response.json()) as {
          error?: string;
          summary?: ExtendedSessionSummary;
          domainBreakdown?: DomainBreakdown[];
        };

        if (!response.ok) {
          if (response.status === 404) {
            setError("session_not_found");
          } else if (response.status === 403) {
            setError("access_denied");
          } else if (response.status === 400) {
            setError("session_not_completed");
          } else if (response.status === 410) {
            setError("session_expired");
          } else {
            setError(data.error || "Failed to load summary");
          }
          return;
        }

        if (data.summary) {
          setSummary(data.summary);
        }
        setDomainBreakdown(data.domainBreakdown || []);

        // Track summary view
        if (data.summary) {
          trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_SUMMARY_VIEWED, {
            sessionId: data.summary.sessionId,
            examType: data.summary.examType,
            examKey: "pmle",
            score: data.summary.score,
            totalQuestions: data.summary.totalQuestions,
            correctAnswers: data.summary.correctAnswers,
            domainCount: data.domainBreakdown?.length || 0,
            readinessTier: getExamReadinessTier(data.summary.score).id,
          });
        }

        // Clean up localStorage since session is completed
        localStorage.removeItem("testero_diagnostic_session_id");

      } catch (err) {
        console.error("Error fetching summary:", err);
        setError("Failed to load diagnostic summary");
      } finally {
        setLoading(false);
      }
    };

    fetchSummary();
  }, [sessionId, user, isAuthLoading, posthog, accessLevel]);

  // Track gated summary view for anonymous users
  useEffect(() => {
    if (summary && accessLevel === "ANONYMOUS" && !hasTrackedGatedView && posthog) {
      trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_SUMMARY_GATED_VIEWED, {
        sessionId: summary.sessionId,
        examKey: "pmle",
        score: summary.score,
        examType: summary.examType,
        source: "diagnostic_summary",
      });
      setHasTrackedGatedView(true);
    }
  }, [summary, accessLevel, hasTrackedGatedView, posthog]);

  // Event handlers
  const handleStartPractice = useCallback(async (domainCodes?: string[]) => {
    // Check if should trigger paywall modal (non-subscribers)
    if (accessLevel !== "SUBSCRIBER") {
      const triggered = triggers.checkPaywallTrigger('practice');
      if (triggered) return; // Modal opened, don't proceed
    }
    
    if (!summary) {
      addToast({
        tone: "danger",
        title: "Couldn't start practice",
        description: "Diagnostic summary not loaded. Please refresh the page.",
      });
      return;
    }
    
    // Determine domain codes to use
    let codesToUse: string[];
    if (domainCodes && domainCodes.length > 0) {
      // If domain codes provided (from Study Plan), convert display names to codes if needed
      codesToUse = domainCodes
        .map(domain => {
          // Check if it's already a domain code (contains underscore) or if it's a display name
          if (domain.includes('_')) {
            return domain; // Already a code
          }
          return getDomainCodeFromDisplayName(domain) || domain;
        })
        .filter((code): code is string => code !== null);
    } else {
      // Compute weakest domains for top CTA
      codesToUse = selectWeakestDomains(domainBreakdown);
    }
    
    if (codesToUse.length === 0) {
      addToast({
        tone: "danger",
        title: "Couldn't start practice",
        description: "No eligible domains found for practice. Please try again later.",
      });
      return;
    }
    
    // Track study plan start practice clicked
    trackEvent(posthog, ANALYTICS_EVENTS.STUDY_PLAN_START_PRACTICE_CLICKED, {
      sessionId: summary.sessionId,
      examKey: "pmle",
      domainCodes: codesToUse,
      questionCount: 10,
      source: domainCodes && domainCodes.length > 0 ? "domain_row" : "weakest",
    });
    
    setCreatingPracticeSession(true);
    
    try {
      const response = await fetch('/api/practice/session', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          examKey: 'pmle',
          domainCodes: codesToUse,
          questionCount: 10,
          source: 'diagnostic_summary',
          sourceSessionId: summary.sessionId,
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        
        // Check for quota exceeded error
        if (response.status === 403 && errorData.code === 'FREE_QUOTA_EXCEEDED') {
          upsell.openNow('quota_exceeded');
          return;
        }

        const errorMessage = errorData.error || 'Failed to create practice session';
        
        // Track error
        trackEvent(posthog, ANALYTICS_EVENTS.PRACTICE_SESSION_CREATION_FAILED_FROM_DIAGNOSTIC, {
          diagnosticSessionId: summary.sessionId,
          domainCodes: codesToUse,
          statusCode: response.status,
          error: errorMessage,
        });
        
        addToast({
          tone: "danger",
          title: "Couldn't start practice",
          description: errorMessage || "Something went wrong. Please try again.",
        });
        return;
      }
      
      const data = await response.json() as {
        sessionId: string;
        route: string;
        questionCount: number;
      };
      
      // Track success
      trackEvent(posthog, ANALYTICS_EVENTS.PRACTICE_SESSION_CREATED_FROM_DIAGNOSTIC, {
        diagnosticSessionId: summary.sessionId,
        practiceSessionId: data.sessionId,
        examKey: "pmle",
        domainCodes: codesToUse,
        questionCount: data.questionCount,
      });
      
      // Navigate to practice session
      router.push(data.route || `/practice?sessionId=${data.sessionId}`);
    } catch (err) {
      console.error('Error creating practice session:', err);
      
      // Track error
      trackEvent(posthog, ANALYTICS_EVENTS.PRACTICE_SESSION_CREATION_FAILED_FROM_DIAGNOSTIC, {
        diagnosticSessionId: summary.sessionId,
        domainCodes: codesToUse,
        errorType: 'network_error',
        error: err instanceof Error ? err.message : 'Network error',
      });
      
      addToast({
        tone: "danger",
        title: "Couldn't start practice",
        description: "Network error. Please check your connection and try again.",
      });
    } finally {
      setCreatingPracticeSession(false);
    }
  }, [posthog, triggers, accessLevel, router, summary, domainBreakdown, addToast, upsell]);

  const handleRetakeDiagnostic = useCallback(() => {
    router.push("/diagnostic");
  }, [router]);

  const handleDomainClick = useCallback((domain: string) => {
    // Track domain click analytics
    if (summary && posthog) {
      const domainCode = getDomainCodeFromDisplayName(domain) || domain;
      const domainData = domainBreakdown.find(d => d.domain === domain);
      const domainTier = domainData ? getDomainTier(domainData.percentage).id : null;
      
      trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_DOMAIN_CLICKED, {
        sessionId: summary.sessionId,
        examKey: "pmle",
        domainCode,
        domainTier,
      });
    }
    
    setSelectedDomain(selectedDomain === domain ? null : domain);
    setActiveFilter('all');
  }, [selectedDomain, summary, posthog, domainBreakdown]);

  const handleExport = useCallback(() => {
    // Implementation for PDF export
    posthog?.capture("summary_exported", { format: "pdf" });
  }, [posthog]);

  const handleShare = useCallback(() => {
    // Implementation for sharing
    posthog?.capture("summary_shared");
  }, [posthog]);

  const handleExplanationViewed = useCallback((question: ExtendedQuestionSummary) => {
    if (summary && posthog) {
      trackEvent(posthog, ANALYTICS_EVENTS.QUESTION_EXPLANATION_VIEWED, {
        sessionId: summary.sessionId,
        examKey: "pmle",
        questionId: question.id,
        domain: question.domain,
        isCorrect: question.isCorrect,
      });
    }
  }, [summary, posthog]);

  // Handle study plan generation with upsell check - currently not used but ready for implementation
  // const handleGenerateStudyPlan = useCallback(() => {
  //   // Check if should trigger paywall modal
  //   if (!user?.user_metadata?.has_subscription) {
  //     const triggered = triggers.checkPaywallTrigger('study_plan');
  //     if (triggered) return; // Modal opened, don't proceed
  //   }
  //   
  //   // Implementation for generating study plan
  //   posthog?.capture("study_plan_generated", { 
  //     source: "diagnostic_summary",
  //     score: summary?.score,
  //   });
  //   
  //   // Navigate to study path
  //   router.push('/study-path');
  // }, [triggers, user, posthog, summary, router]);

  // Upsell modal handlers
  const handleUpsellCTA = useCallback(() => {
    upsell.handleCTAClick();
    const source =
      upsell.variant === "quota_exceeded"
        ? "practice_quota_paywall"
        : upsell.trigger === "paywall"
          ? "diagnostic_summary_paywall"
          : `upsell_${upsell.trigger ?? "unknown"}`;

    startBasicCheckout(source);
  }, [startBasicCheckout, upsell]);

  const handleDismissUpsell = useCallback(() => {
    upsell.dismiss();
  }, [upsell]);

  const handleSignupCTAClick = useCallback(() => {
    if (summary && posthog) {
      trackEvent(posthog, ANALYTICS_EVENTS.DIAGNOSTIC_SUMMARY_SIGNUP_CTA_CLICKED, {
        sessionId: summary.sessionId,
        examKey: "pmle",
        accessLevel,
        source: "diagnostic_summary_anonymous",
      });
    }

    startBasicCheckout("diagnostic_summary_anonymous_banner");
  }, [summary, posthog, accessLevel, startBasicCheckout]);

  const handleContinueWithoutAccount = useCallback(() => {
    setShowSignupPanel(false);
  }, []);

  // Error states (keeping existing error handling)
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-lg text-slate-600">Loading diagnostic summary...</div>
      </div>
    );
  }

  if (error === "session_not_found") {
    return (
      <main className="max-w-2xl mx-auto px-6 py-8">
        <Card>
          <CardContent className="text-center py-8">
            <h1 className="text-2xl font-bold mb-4">Summary Not Found</h1>
            <p className="text-red-600 mb-6">
              The diagnostic session could not be found or may have expired.
            </p>
            <Button onClick={() => router.push("/diagnostic")}>Start New Diagnostic</Button>
          </CardContent>
        </Card>
      </main>
    );
  }

  if (error === "access_denied") {
    return (
      <main className="max-w-2xl mx-auto px-6 py-8">
        <Card>
          <CardContent className="text-center py-8">
            <h1 className="text-2xl font-bold mb-4">Access Denied</h1>
            <p className="text-red-600 mb-6">
              You don&apos;t have permission to view this diagnostic summary.
            </p>
            <Button onClick={() => router.push("/diagnostic")}>Start New Diagnostic</Button>
          </CardContent>
        </Card>
      </main>
    );
  }

  if (error === "session_not_completed") {
    return (
      <main className="max-w-2xl mx-auto px-6 py-8">
        <Card>
          <CardContent className="text-center py-8">
            <h1 className="text-2xl font-bold mb-4">Diagnostic Not Completed</h1>
            <p className="text-red-600 mb-6">
              This diagnostic session hasn&apos;t been completed yet.
            </p>
            <Button onClick={() => router.push(`/diagnostic/${sessionId}`)}>
              Continue Diagnostic
            </Button>
          </CardContent>
        </Card>
      </main>
    );
  }

  if (error === "session_expired") {
    return (
      <main className="max-w-2xl mx-auto px-6 py-8">
        <Card>
          <CardContent className="text-center py-8">
            <h1 className="text-2xl font-bold mb-4">Session Expired</h1>
            <p className="text-red-600 mb-6">
              Your diagnostic session expired before completion. Diagnostic sessions expire after a period of inactivity for security reasons.
            </p>
            <p className="text-slate-600 mb-6">
              Please start a new diagnostic test to continue.
            </p>
            <Button onClick={() => router.push("/diagnostic")}>
              Start New Diagnostic
            </Button>
          </CardContent>
        </Card>
      </main>
    );
  }

  if (error) {
    return (
      <main className="max-w-2xl mx-auto px-6 py-8">
        <Card>
          <CardContent className="text-center py-8">
            <h1 className="text-2xl font-bold mb-4">Error</h1>
            <p className="text-red-600 mb-6">{error}</p>
            <Button onClick={() => router.push("/diagnostic")}>Start New Diagnostic</Button>
          </CardContent>
        </Card>
      </main>
    );
  }

  if (!summary) {
    return (
      <main className="max-w-2xl mx-auto px-6 py-8">
        <div className="text-center">No summary data available</div>
      </main>
    );
  }

  return (
    <div className="min-h-screen bg-slate-50">
      {/* Toast Notifications */}
      <div className="fixed top-4 right-4 z-50 space-y-2">
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            {...toast}
            onClose={() => dismissToast(toast.id)}
          />
        ))}
      </div>
      
      {/* Top Header */}
      <header className="bg-white border-b border-slate-200">
        <div className="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
          <h1 className="text-lg font-semibold text-slate-900">Diagnostic Results</h1>
          <div className="flex items-center gap-4">
            <span className="text-sm text-slate-500">
              {new Date(summary.completedAt).toLocaleDateString()}  {summary.examType}
            </span>
            <div className="flex items-center gap-2">
              <Button onClick={handleExport} size="sm" variant="ghost" tone="neutral">
                 Export
              </Button>
              <Button onClick={handleShare} size="sm" variant="ghost" tone="neutral">
                 Share
              </Button>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
          {/* Left Content (8-9 cols) */}
          <div className="lg:col-span-9 space-y-8">
            {/* Verdict Block */}
            <VerdictBlock 
              summary={summary}
              onStartPractice={() => handleStartPractice()}
              onRetakeDiagnostic={handleRetakeDiagnostic}
              isLoading={creatingPracticeSession}
            />

            {/* Domain Performance */}
            {domainBreakdown.length > 0 && (
              <LockedSection isLocked={isAnonymous}>
                <DomainPerformance 
                  domains={domainBreakdown}
                  onDomainClick={handleDomainClick}
                />
              </LockedSection>
            )}

            {/* Legacy session notice */}
            {summary && domainBreakdown.length === 0 && (
              <div className="rounded-2xl border border-amber-200 bg-amber-50 p-4 md:p-6 shadow-sm mb-8">
                <h3 className="text-lg font-semibold text-amber-900 mb-2">
                  Domain Breakdown Unavailable
                </h3>
                <p className="text-sm text-amber-700 mb-4">
                  This diagnostic session was completed before domain-level analysis was available. 
                  Take a new diagnostic to get domain-specific readiness insights and a personalized study plan.
                </p>
                <Button onClick={handleRetakeDiagnostic} tone="accent" size="sm">
                  Take New Diagnostic
                </Button>
              </div>
            )}

            {/* Study Plan */}
            <div ref={triggers.setStudyPlanRef}>
              <LockedSection isLocked={isAnonymous}>
                <StudyPlan 
                  domains={domainBreakdown}
                  onStartPractice={handleStartPractice}
                  isLoading={creatingPracticeSession}
                />
              </LockedSection>
            </div>

            {/* Question Review */}
            {canUseFeature(accessLevel, "DIAGNOSTIC_SUMMARY_FULL") ? (
              <QuestionReview
                questions={summary.questions}
                activeFilter={activeFilter}
                onFilterChange={setActiveFilter}
                selectedDomain={selectedDomain}
                onDomainChange={setSelectedDomain}
                onTrackReviewEntry={triggers.trackReviewSectionEntry}
                onTrackReviewExit={triggers.trackReviewSectionExit}
                onTrackExpansion={triggers.trackExplanationExpansion}
                onExplanationViewed={handleExplanationViewed}
                canAccessExplanations={canUseFeature(accessLevel, "EXPLANATIONS")}
                onUpgrade={() => startBasicCheckout("diagnostic_summary_explanations")}
              />
            ) : (
              <LockedSection isLocked={isAnonymous}>
                <div className="rounded-2xl border border-slate-200 bg-white p-6 shadow-sm mb-8">
                  <h2 className="text-xl font-semibold tracking-tight text-slate-900 mb-6">Question Review</h2>
                  <div className="space-y-3">
                    <div className="text-sm text-slate-600">
                      Review your answers, see correct solutions, and access detailed explanations for each question.
                    </div>
                  </div>
                </div>
              </LockedSection>
            )}
          </div>

          {/* Right Rail (3-4 cols) */}
          <div className="lg:col-span-3 space-y-6">
            {/* Signup Panel for Anonymous Users */}
            {isAnonymous && showSignupPanel && (
              <div className="rounded-2xl border border-blue-200 bg-gradient-to-r from-blue-50 to-indigo-50 p-4 md:p-6 shadow-sm">
                <h3 className="font-semibold text-slate-900 mb-2">
                  Create a free account to unlock your full breakdown
                </h3>
                <p className="text-sm text-slate-600 mb-4">
                  Sign up to see your domain performance, personalized study plan, and detailed question review.
                </p>
                <div className="space-y-2">
                  <Button
                    onClick={handleSignupCTAClick}
                    tone="accent"
                    size="sm"
                    fullWidth
                  >
                    Sign up free
                  </Button>
                  <Button
                    onClick={handleContinueWithoutAccount}
                    variant="outline"
                    tone="neutral"
                    size="sm"
                    fullWidth
                  >
                    Continue without account
                  </Button>
                </div>
              </div>
            )}

            <QuickActions 
              onRetake={handleRetakeDiagnostic}
              onPractice={() => handleStartPractice()}
              onExport={handleExport}
              onShare={handleShare}
              isLoading={creatingPracticeSession}
            />

            {/* Upgrade CTA for non-subscribed users (logged in but not subscribers) */}
            {!isAnonymous && accessLevel !== "SUBSCRIBER" && (
              <div className="rounded-2xl border border-blue-200 bg-gradient-to-r from-blue-50 to-indigo-50 p-4 md:p-6 shadow-sm">
                <h3 className="font-semibold text-slate-900 mb-2">Ready to Pass?</h3>
                <p className="text-sm text-slate-600 mb-4">
                  Get personalized study plans and unlimited practice
                </p>
                <Button
                  onClick={() => {
                    startBasicCheckout("diagnostic_summary_sidebar");
                  }}
                  tone="accent"
                  size="sm"
                  fullWidth
                >
                  Upgrade to Premium
                </Button>
                <p className="text-xs text-slate-500 mt-2 text-center">7-day money-back guarantee</p>
              </div>
            )}
          </div>
        </div>
      </main>

      {/* Upsell Modal */}
      <UpsellModal
        isOpen={upsell.isOpen}
        variant={upsell.variant}
        trigger={upsell.trigger}
        onClose={upsell.dismiss}
        onCTAClick={handleUpsellCTA}
        onDismiss={handleDismissUpsell}
      />

    </div>
  );
};

export default DiagnosticSummaryPage;
</file>

</files>
